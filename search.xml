<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>vue组件实例_二</title>
      <link href="/2018/12/06/vue%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B-%E4%BA%8C/"/>
      <url>/2018/12/06/vue%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>一个复用组件</p><p>[TOC]</p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>每一行的列表是一个组件，列表内可能出现按钮组件或者箭头组件，点击按钮组件可以自定义事件，同时可以根据不同的参数来决定当前列表是带按钮的列表or带箭头的列表。</p><p><img src="https://blog-10039692.file.myqcloud.com/1490929795562_1084_1490929795668.png" alt="img"></p><h2 id="List组件"><a href="#List组件" class="headerlink" title="List组件"></a>List组件</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- quiList.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"qui-list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">'list-tips'</span>&gt;</span>&#123;&#123;tipsText&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- component是一个容器，决定里面装什么内容的是is=“” --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- keep-alive保持组件在内存中是常驻的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentView"</span> <span class="attr">v-on:btnClickEvent</span> = <span class="string">'clickEvent'</span> <span class="attr">:msg</span>=<span class="string">msg</span> <span class="attr">class</span>=<span class="string">"small"</span> <span class="attr">keep-alive</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> quiButton <span class="keyword">from</span> <span class="string">'../components/quiButton.vue'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> quiArrow <span class="keyword">from</span> <span class="string">'../components/quiArrow.vue'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    props:&#123;</span></span><br><span class="line"><span class="undefined">        msg:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">default</span>:<span class="string">'下载'</span></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        tipsText:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">default</span>:<span class="string">'默认的文案'</span></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        currentView:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">default</span>:<span class="string">'qui-btn'</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    components:&#123;</span></span><br><span class="line"><span class="javascript">        <span class="string">'qui-btn'</span>:quiButton,</span></span><br><span class="line"><span class="javascript">        <span class="string">'qui-arrow'</span>:quiArrow</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    methods:&#123;</span></span><br><span class="line"><span class="javascript">        clickEvent:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">"按钮点击事件"</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.$emit(<span class="string">"clickEvent"</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><p>组件的复用，在queList中复用了quiButton，quiArrow</p><h3 id="动态切换"><a href="#动态切换" class="headerlink" title="动态切换"></a>动态切换</h3><p>实现quiButton和quiArrow根据参数来动态切换的是component这个标签</p><p>component是一个容器，决定里面装什么内容的是is=“”</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"qui-button(qui-arrow)"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="List页面"><a href="#List页面" class="headerlink" title="List页面"></a>List页面</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pageQuiList.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pageQuiList"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qui-list</span> <span class="attr">tipsText</span> = <span class="string">"自定义文案，默认右边是按钮"</span> <span class="attr">msg</span>=<span class="string">"弹层"</span>&gt;</span><span class="tag">&lt;/<span class="name">qui-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qui-list</span> <span class="attr">v-on:clickEvent</span> = <span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">qui-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">qui-list</span> <span class="attr">ref</span> = <span class="string">"child1"</span> <span class="attr">tipsText</span> = <span class="string">"最右边是箭头"</span> <span class="attr">currentView</span> = <span class="string">"qui-arrow"</span>&gt;</span><span class="tag">&lt;/<span class="name">qui-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> quiList <span class="keyword">from</span> <span class="string">"../components/quiList.vue"</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name:<span class="string">"pageQuiList"</span>,</span></span><br><span class="line"><span class="undefined">    components:&#123;</span></span><br><span class="line"><span class="javascript">        <span class="string">'qui-list'</span>:quiList</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="javascript">        test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">'自定义的测试事件'</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有一个bug调了一会儿，第二个按键没有触发test事件，原因是忘记在子组件quiList的方法clickEvent中emit，这样事件就不会上传至父组件，父组件就无法监听到这个事件并触发test</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a><a href="https://cloud.tencent.com/developer/article/1020416" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1020416</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2018/12/06/leetcode58-387/"/>
      <url>/2018/12/06/leetcode58-387/</url>
      
        <content type="html"><![CDATA[<p>两道string的简单题:最后单词的长度&amp;第一个不重复的值</p><a id="more"></a><h2 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58. Length of Last Word"></a>58. Length of Last Word</h2><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxx07y0byij30qw0d475p.jpg" alt="image-20181206142249340"></p><p>python一句话就可以AC</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> len(s.strip().split(<span class="string">" "</span>)[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><p>不用内置函数的方法:</p><p>从后向前遍历，如果遇到空格则忽略并且继续，直到遇到第一个不是空格的停下来并且记录下这个值temp</p><p>然后继续遍历，直到遍历到第一个不是空格的值停下来并记录下这个值index</p><p>然后返回temp-index</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l = len(s)</span><br><span class="line">        index = l<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span>(index&gt;=<span class="number">0</span> <span class="keyword">and</span> s[index]==<span class="string">" "</span>):</span><br><span class="line">            index-=<span class="number">1</span></span><br><span class="line">        temp = index</span><br><span class="line">        <span class="keyword">while</span>(index&gt;=<span class="number">0</span> <span class="keyword">and</span> s[index]!=<span class="string">" "</span>):</span><br><span class="line">            index-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> temp - index</span><br></pre></td></tr></table></figure><h2 id="387-First-Unique-Character-in-a-String"><a href="#387-First-Unique-Character-in-a-String" class="headerlink" title="387. First Unique Character in a String"></a>387. First Unique Character in a String</h2><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxwzz2j63rj30r80bo3ze.jpg" alt="image-20181206141411623"></p><p>本来想着暴力求解，结果超时了</p><p>看的别人的解法，用hash表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash_table = &#123;e:index <span class="keyword">for</span> e,index <span class="keyword">in</span> enumerate(s)&#125;</span><br></pre></td></tr></table></figure><p>然后遍历字符串，如果字符的索引跟hash表保存的索引一致则返回这个索引，不一致则把hash表保存的值改为-1继续遍历(因为不一致就肯定不是这个值，如果不改的话后面会出现一致的值，导致结果错误)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        hash_table = &#123;e:index <span class="keyword">for</span> index, e <span class="keyword">in</span> enumerate(s)&#125;</span><br><span class="line">        flag=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> index,item <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span>(index==hash_table[item]):</span><br><span class="line">                flag=<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_table[item]=<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>python语法:</p><p>enumerate可以用在任何可枚举的数据结构上，返回索引和值</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxx031t1q7j30rk0lidi2.jpg" alt="image-20181206141806378"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> string </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue组件实例_一</title>
      <link href="/2018/12/05/vue%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B-%E4%B8%80/"/>
      <url>/2018/12/05/vue%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>一个制作组件的vue实例</p><p>[TOC]</p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>需求：组件库是做UI和前端日常需求中经常用到的，把一个按钮，导航，列表之类的元素封装起来，方便日常使用，调用方法只需直接写上<strong><qui-button></qui-button></strong>或者<strong><qui-nav></qui-nav></strong>这样的代码就可以</p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxvooa0txuj30860c4aao.jpg" alt="image-20181205105742634"></p><p>###main.js和App.vue</p><ol><li>main.js是入口文件，初始化vue实例</li><li>App.vue是主组件，所有页面都是在App.vue下进行的切换</li></ol><h3 id="路由-router-amp-单页面-pages"><a href="#路由-router-amp-单页面-pages" class="headerlink" title="路由 router &amp; 单页面 pages"></a>路由 router &amp; 单页面 pages</h3><p>前端可以根据带锚点的方式实现简单路由</p><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,  <span class="comment">//http://localhost:8080/#/</span></span><br><span class="line">      name: <span class="string">'index'</span>,</span><br><span class="line">      component: index</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/btn'</span>,  <span class="comment">//http://localhost:8080/#/btn</span></span><br><span class="line">      name: <span class="string">'btn'</span>,</span><br><span class="line">      component: pageQuiButton</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/list'</span>,  <span class="comment">//http://localhost:8080/#/list</span></span><br><span class="line">      name: <span class="string">'list'</span>,</span><br><span class="line">      component: pageQuiList</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/nav'</span>,   <span class="comment">//http://localhost:8080/#/nav</span></span><br><span class="line">      name: <span class="string">'nav'</span>,</span><br><span class="line">      component: pageQuiNav</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>设置了路由之后就可以通过路由访问不同的页面</p><p>四个路由分别对应pages中的四个vue文件所展示的页面</p><h3 id="组件-Conponents"><a href="#组件-Conponents" class="headerlink" title="组件 Conponents"></a>组件 Conponents</h3><p>定义了三个组件，按键，列表和导航栏并且分别在pages的页面中得到使用</p><h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><p>整体代码（实现组件自定义属性，事件和其他内容）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//quiButton.js</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"qui-btn"</span> v-on:click=<span class="string">"btnClickEvent"</span>&gt;</span><br><span class="line">    &lt;slot name=<span class="string">"icon"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line">    &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  export default &#123;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/pop是可以在组件上注册的自定义特性。当一个值传递给prop特性时他就变成了那个组件实例的一个属性。</span></span><br><span class="line"><span class="regexp">        props:&#123;</span></span><br><span class="line"><span class="regexp">          msg:&#123;</span></span><br><span class="line"><span class="regexp">            default:'下载'</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">        methods:&#123;</span></span><br><span class="line"><span class="regexp">            btnClickEvent:function()&#123;</span></span><br><span class="line"><span class="regexp">                alert(this.msg);</span></span><br><span class="line"><span class="regexp">                /</span><span class="regexp">/ emit将事件传递给组件外部或者上级，不然父组件无法监听到</span></span><br><span class="line"><span class="regexp">                this.$emit('btnClickEvent'); </span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pageQuiButton.js</span></span><br><span class="line">&lt;&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">'pageQuiButton'</span>&gt;</span><br><span class="line">    &lt;!--使用 --&gt;</span><br><span class="line">    &lt;!--监听到子组件的btnClickEvent事件后就去触发父组件的doSth事件 --&gt;</span><br><span class="line">    &lt;qui-btn msg=<span class="string">"确定"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"small"</span> v-on:btnClickEvent=<span class="string">"doSth1"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">qui-btn</span>&gt;</span></span></span><br><span class="line">    &lt;qui-btn msg="取消" class="small" v-on:btnClickEvent="doSth2"&gt;</span><br><span class="line">      &lt;!-- 插槽slot="icon" 对应组件中的name='icon',渲染时会将img整个替换成组件中对应name的slot标签 --&gt;</span><br><span class="line">      &lt;img slot="icon" class="ico" src="../assets/delete.png"style="width:25px"/&gt;</span><br><span class="line">    &lt;/qui-btn&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import quiBtn from '../components/quiButton.vue'</span><br><span class="line">    export default&#123;</span><br><span class="line">      name:'pageQuiButton',</span><br><span class="line">      components:&#123;</span><br><span class="line">        'qui-btn':quiBtn</span><br><span class="line">      &#125;,</span><br><span class="line">      methods:&#123;</span><br><span class="line">        doSth1:function()&#123;</span><br><span class="line">          alert('1');</span><br><span class="line">        &#125;,</span><br><span class="line">        doSth2:function()&#123;</span><br><span class="line">          alert('2')</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="自定义属性-props"><a href="#自定义属性-props" class="headerlink" title="自定义属性 props"></a>自定义属性 props</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pop是可以在组件上注册的自定义特性。当一个值传递给prop特性时他就变成了那个组件实例的一个属性。</span></span><br><span class="line">        props:&#123;</span><br><span class="line">          msg:&#123;</span><br><span class="line">            <span class="keyword">default</span>:<span class="string">'下载'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//然后在使用对应的组件时直接写msg='想自定义的值'即可</span></span><br></pre></td></tr></table></figure><h3 id="自定义事件-on-emit"><a href="#自定义事件-on-emit" class="headerlink" title="自定义事件  on emit"></a>自定义事件  on emit</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先需要子组件将事件向上传递给父组件</span></span><br><span class="line">btnClickEvent:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="keyword">this</span>.msg);</span><br><span class="line">                <span class="comment">// emit将事件传递给组件外部或者上级，不然父组件无法监听到</span></span><br><span class="line">                <span class="keyword">this</span>.$emit(<span class="string">'btnClickEvent'</span>); </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//随后父组件中对该事件进行监听，当该事件被触发时执行自定义的事件</span></span><br><span class="line">&lt;qui-btn msg=<span class="string">"确定"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"small"</span> v-on:btnClickEvent=<span class="string">"doSth1"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">qui-btn</span>&gt;</span></span></span><br><span class="line">&lt;qui-btn msg="取消" class="small" v-on:btnClickEvent="doSth2"&gt;&lt;/qui-btn&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义其他内容-slot"><a href="#自定义其他内容-slot" class="headerlink" title="自定义其他内容 slot"></a>自定义其他内容 slot</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在组件中使用插槽来占位</span></span><br><span class="line">&lt;slot name=<span class="string">"icon"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用时用自定义的内容去替换插槽</span></span><br><span class="line">&lt;qui-btn msg=<span class="string">"取消"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"small"</span> v-on:btnClickEvent=<span class="string">"doSth2"</span>&gt;</span><br><span class="line">      &lt;!-- 插槽slot=<span class="string">"icon"</span> 对应组件中的name=<span class="string">'icon'</span>,渲染时会将img整个替换成组件中对应name的slot标签 --&gt;</span><br><span class="line">      &lt;img slot=<span class="string">"icon"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ico"</span> src=<span class="string">"../assets/delete.png"</span>style=<span class="string">"width:25px"</span>/&gt;</span><br><span class="line"> &lt;<span class="regexp">/qui-btn&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/var/folders/6p/_f33fscs7j316s490d30bm6c0000gn/T/abnerworks.Typora/image-20181205111808445.png" alt="image-20181205111808445"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a><a href="https://cloud.tencent.com/developer/article/1020338?fromSource=waitui" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1020338?fromSource=waitui</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> 自定义组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode14_Longest_Common_Prefix</title>
      <link href="/2018/12/04/leetcode14-Longest-Common-Prefix/"/>
      <url>/2018/12/04/leetcode14-Longest-Common-Prefix/</url>
      
        <content type="html"><![CDATA[<p>寻找字符串的共同前缀</p><a id="more"></a><h1 id="leetcode14-Longest-Common-Prefix"><a href="#leetcode14-Longest-Common-Prefix" class="headerlink" title="leetcode14_Longest_Common_Prefix"></a>leetcode14_Longest_Common_Prefix</h1><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxv0n7qgekj30r20dsab5.jpg" alt="image-20181204210621899"></p><p>题目要求必须是所有字符串的共同前缀，所以可以保留第一个字符串作为比较值，一个指针记录当前相同的长度</p><p>然后遍历所有的字符串，如果当前指针上的值都相等则后移，否则就结束并输出结果</p><p>前两次没有AC有两个问题</p><ol><li>没有判断当输入的字符串数组为空的时候（leetcode的题基本都要这一步</li><li>第一个字符串不一定是最长的，也就是说以第一个为参考字符串会导致越界，所以要判断一句是否越界，如果越界则结束并输出结果</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span>(strs==[]):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        first = strs[<span class="number">0</span>]</span><br><span class="line">        l=<span class="number">0</span></span><br><span class="line">        flag=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;len(first)):</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> strs:</span><br><span class="line">                <span class="keyword">if</span>(l&gt;=len(item)):</span><br><span class="line">                    flag=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span>(item[l]!=first[l]):</span><br><span class="line">                    flag=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">0</span>):</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> first[:l]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> string </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Delaunay Triangulation&amp;Voronoi Diagram</title>
      <link href="/2018/12/04/%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/"/>
      <url>/2018/12/04/%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>Delaunay Triangulation&amp;Voronoi Diagram</p><a id="more"></a><h2 id="三角剖分-Delaunay-Triangulation"><a href="#三角剖分-Delaunay-Triangulation" class="headerlink" title="三角剖分(Delaunay Triangulation)"></a>三角剖分(Delaunay Triangulation)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>以一个二维空间为例，把一个二维空间剖开成一块块的碎片，满足以下两个条件:</p><p>（1）每块碎片都是曲边三角形； </p><p>（2）曲面上任何两个这样的曲边三角形，要么不相交，要么恰好相交于一条公共边（不能同时交两条或两条以上的边）</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxv1u9prcfj30ci0c6110.jpg" alt="image-20181204214744538"></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol><li>更快计算最小生成树（平面图o(nlogn))</li></ol><h2 id="Voronoi-Diagram"><a href="#Voronoi-Diagram" class="headerlink" title="Voronoi Diagram"></a>Voronoi Diagram</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>沃洛诺伊图（Voronoi Diagram）解决了这样一个问题：如何根据已知点划分平面，使得格子与点一一对应，并使平面上任取一点都与最近的已知点围在一起。做法也很简单，把这些点连接成三角形网络，然后作每一条边的中垂线，这些中垂线形成的划分就是所求。</strong></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxv1tzzxtsj30df0cgqcr.jpg" alt="image-20181204214719304"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://blog.csdn.net/shenziheng1/article/details/54865138" target="_blank" rel="noopener">https://blog.csdn.net/shenziheng1/article/details/54865138</a></li><li><a href="https://www.zhihu.com/question/20317274" target="_blank" rel="noopener">https://www.zhihu.com/question/20317274</a></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 拓扑 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cnn&amp;capsule</title>
      <link href="/2018/11/29/CNN/"/>
      <url>/2018/11/29/CNN/</url>
      
        <content type="html"><![CDATA[<p>cnn和capsule的学习笔记</p><a id="more"></a><h1 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h1><p>为什么使用CNN</p><ol><li><p>Some patterns are much smaller than the whole image</p></li><li><p>The same patterns appear in different regions</p></li><li>Subsampling pixels will not change the Objetc</li></ol><h2 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h2><p>卷积层的参数是由一些可学习的滤波器集合构成的</p><p>这些滤波器用作检测图像不同的特征</p><h3 id="卷积层的作用"><a href="#卷积层的作用" class="headerlink" title="卷积层的作用"></a>卷积层的作用</h3><p>例1 ：灰度图</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fw3eu0azcrj311w0s0kdd.jpg" alt="img"></p><p>如滤波器1，检测的就是存在右对角线全为正数这个特征，这个特征出现在原图像的左上角和左下角，体现在结果中就是左上和左下的值最大。</p><p>例2 RGB图</p><p>滤波器也是三维，每一个滤波器会考虑三种颜色，而不是分开计算</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fw3fc37wilj30sc0jddu0.jpg" alt="img"></p><h3 id="卷积层和全连接层的关系"><a href="#卷积层和全连接层的关系" class="headerlink" title="卷积层和全连接层的关系"></a>卷积层和全连接层的关系</h3><p>其实卷积层的每一个滤波器操作就是一个全连接层拿掉部分权重之后的运算结果</p><p>在全连接层中，每一个神经元都有自己的权重，</p><p>但是卷积得到的的神经元共享同一组权重（filter)</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fw3fjg29nzj30rg0jutqe.jpg" alt="img"></p><p>输出数据体在空间上的尺寸可以通过输入数据体尺寸（W），卷积层中神经元的感受野尺寸（F），步长（S）和零填充的数量（P）的函数来计算。（<strong><em>注：这里假设输入数组的空间形状是正方形，即高度和宽度相等</em></strong>）输出数据体的空间尺寸为<strong>(W-F +2P)/S+1</strong>。</p><h2 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h2><p>它的作用是逐渐降低数据体的空间尺寸，这样的话就能减少网络中参数的数量，使得计算资源耗费变少，也能有效控制过拟合。</p><p>使用MAX操作，对输入数据体的每一个深度切片独立进行操作，改变它的空间尺寸。最常见的形式是汇聚层使用尺寸<strong>2x2</strong>的滤波器，以步长为2来对每个深度切片进行降采样，将其中75%的激活信息都丢掉。<strong>每个MAX操作是从4个数字中取最大值（也就是在深度切片中某个2x2的区域）</strong>。深度保持不变。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fw3fxcv5kfj30qk0jn7il.jpg" alt="img"></p><p>只保留每个框中最大的值（也可以取平均值）</p><p>经过卷积层运算后，图像比原图像要小，图像channel的数量等于滤波器的数量</p><p><img src="/var/folders/6p/_f33fscs7j316s490d30bm6c0000gn/T/abnerworks.Typora/image-20181010212044189.png" alt="image-20181010212044189"></p><h2 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h2><p>最后把所有的特征图（feature map）L拉直，然后进行全连接</p><p><img src="/var/folders/6p/_f33fscs7j316s490d30bm6c0000gn/T/abnerworks.Typora/image-20181010212917864.png" alt="image-20181010212917864"></p><h2 id="CNN-in-Keras"><a href="#CNN-in-Keras" class="headerlink" title="CNN in Keras"></a>CNN in Keras</h2><p><img src="/var/folders/6p/_f33fscs7j316s490d30bm6c0000gn/T/abnerworks.Typora/image-20181010213649412.png" alt="image-20181010213649412"></p><p>第二次做卷积时，虽然滤波器的长宽仍然是3*3，但是必须考虑到前面卷积得到的结果是一个深度为25的特征图，所以参数数量：$25 \times 3 \times 3 = 225$</p><h1 id="Capsule-net"><a href="#Capsule-net" class="headerlink" title="Capsule net"></a>Capsule net</h1><p>一个胶囊网络基本上是一个试图执行反向图形解析的神经网络。</p><p>Geoffrey Hinton 介绍 Capsule 为：「Capsule 是一组神经元，其输入输出向量表示特定实体类型的实例化参数（即特定物体、概念实体等出现的概率与某些属性）。我们使用输入输出向量的长度表征实体存在的概率，向量的方向表示实例化参数（即实体的某些图形属性）。同一层级的 capsule 通过变换矩阵对更高级别的 capsule 的实例化参数进行预测。当多个预测一致时（本论文使用动态路由使预测一致），更高级别的 capsule 将变得活跃。」</p><p>A capsule is any function that tries to predict the presence and the instantiation parameters of a particular object at a given location.</p><p>胶囊是用来预测给定位置某个特定对象的出现以及对象内部参数的方法。</p><h2 id="CNN的缺陷-amp-amp-胶囊的改进"><a href="#CNN的缺陷-amp-amp-胶囊的改进" class="headerlink" title="CNN的缺陷&amp;&amp;胶囊的改进"></a>CNN的缺陷&amp;&amp;胶囊的改进</h2><h3 id="CNN缺陷"><a href="#CNN缺陷" class="headerlink" title="CNN缺陷"></a>CNN缺陷</h3><p>组成高层特征的低层特征之间并不存在位姿（平移和旋转）关系。CNN解决这个问题的方法是使用最大池化或后续卷积层来减少通过网络的数据的空间大小，从而增加了上层网络神经元的“视野”，因此它们得以检测输入图像较大区域的高阶特征。</p><p><strong><em>卷积神经网络的内部数据表示没有考虑简单和复杂对象之间的重要空间层级。</em></strong></p><h3 id="CapsuleNet改进"><a href="#CapsuleNet改进" class="headerlink" title="CapsuleNet改进"></a>CapsuleNet改进</h3><p>Hinton主张，为了正确地分类和辨识对象，保留对象部件间的分层位姿关系很重要。胶囊结合了对象之间的相对关系，在数值上表示为4维位姿矩阵。</p><p><strong>益处：</strong></p><ol><li><strong>增加了对于三维空间的理解，提高了识别不同角度相同物体的准确度</strong></li><li><strong>相比CNN需要的数据，它只需要学习一小部分数据，就能达到最先进的效果</strong></li></ol><p>想法很早就提出，但是没有一种算法可以实现并成功学习胶囊网络。</p><p>新算法“囊间动态路由”的提出，允许胶囊之间相互通信，并创建类似计算机图形中场景图的表示</p><h2 id="Capsule-工作机制"><a href="#Capsule-工作机制" class="headerlink" title="Capsule 工作机制"></a>Capsule 工作机制</h2><p><strong>所有胶囊检测中的特征的状态的重要信息，都将以向量的形式被胶囊封装。</strong></p><p>胶囊将检测某个特征值的概率作为向量的长度，特征的状态被编码成向量的方向。</p><p>因此，当图像中某个特征发生位姿变化时，向量的长度不限（概率不变），方向改变（状态改变）</p><p>这就是Hinton所说的<strong>活动等变形</strong>：神经活动随着物体在图像中的“外观流形上的移动”而改变，改变的同时检测概率保持恒定。</p><p>工作步骤</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxui6ksgduj31xo0jw1kx.jpg" alt="img"></p><p>人造神经元可以用3个步骤来表示：                  </p><ol><li>输入标量的标量加权</li><li>加权输入标量之和</li><li>标量到标量的非线性变换</li></ol><p>胶囊具有上面3个步骤的向量版，并且新增了输入的防射变换这一步骤：</p><ol><li><strong>输入向量的矩阵乘法</strong></li><li><strong>输入向量的标量加权</strong></li><li><strong>加权输入向量之和</strong></li><li><strong>向量到向量的非线性变换</strong></li></ol><h3 id="输入向量的矩阵乘法"><a href="#输入向量的矩阵乘法" class="headerlink" title="输入向量的矩阵乘法"></a>输入向量的矩阵乘法</h3><p>输入的向量来自上一层胶囊的输出。</p><p>向量的长度代表上一层胶囊检测到的对应对象的概率，向量的方向编码了检测到的对象的内部信息（位姿信息）</p><p>这些向量和权重矩阵W相乘，W中编码了一些高层特征和底层特征之间的关系，如空间关系。</p><h3 id="输入向量的标量加权"><a href="#输入向量的标量加权" class="headerlink" title="输入向量的标量加权"></a>输入向量的标量加权</h3><p>在神经网络中，通过反向传播来实现权重的学习</p><p>在胶囊网络中，使用“动态路由”来决定胶囊输出的去向(<strong>囊间动态路由算法</strong>)</p><p>动态路由算法的精髓就是：底层胶囊的输出应该被送往哪一个高层胶囊</p><p>低层胶囊具备测量哪个高层胶囊更能接受其输出的机制，并据此自动调整权重，使对应胶囊K的权重C变高，对应胶囊J的权重C变低。</p><h3 id="加权输入向量之和"><a href="#加权输入向量之和" class="headerlink" title="加权输入向量之和"></a>加权输入向量之和</h3><p>和神经网络中的求和过程相同，只不过是向量的求和，而不是标量</p><h3 id="向量到向量的非线性变化"><a href="#向量到向量的非线性变化" class="headerlink" title="向量到向量的非线性变化"></a>向量到向量的非线性变化</h3><p>CapsNet的另一大创新是新颖的非线性激活函数，这个函数接受一个向量，然后在不改变方向的前提下，压缩它的长度到1以下。</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*RB03q9MINVgRPK_VBcBnsg.png" alt="img"></p><p>公式右边的蓝色矩形缩放输入向量至单位长度，左边的红色矩形进行一些额外的缩放。</p><p>输出向量的长度代表胶囊检测的给定特征的概率。</p><h2 id="视频笔记"><a href="#视频笔记" class="headerlink" title="视频笔记"></a>视频笔记</h2><p>地址：<a href="https://www.youtube.com/watch?v=pPN8d0E3900" target="_blank" rel="noopener">https://www.youtube.com/watch?v=pPN8d0E3900</a></p><p>图中表示该网络中有50个capsule，箭头代表capsule输出的向量</p><p>黑色箭头检测矩形，蓝色箭头三角形</p><p><img src="/var/folders/6p/_f33fscs7j316s490d30bm6c0000gn/T/abnerworks.Typora/image-20181012121203787.png" alt="image-20181012121203787"></p><ol><li><p>使用卷积层将图像变成若干个feature map，然后reshape这些数组，得到向量，这些向量就是第一层胶囊的输入。(we runa couple convolutional layers, we reshape the output to get vectors, and we squash them.This gives us the output of the primary capsules.)</p></li><li><p><strong>每一个胶囊都试图预测下一层胶囊的输出 (Every capsule in the first layer tries to predict the output of every capsule in the next layer.)</strong></p></li></ol><p>   <strong>routing by agreement</strong></p><p>   举例：</p><p>   第一层胶囊有两个，矩形胶囊和三角形胶囊</p><p>   第二层胶囊有两个，房子胶囊和船胶囊</p><p>   <img src="/var/folders/6p/_f33fscs7j316s490d30bm6c0000gn/T/abnerworks.Typora/image-20181013190349786.png" alt="image-20181013190349786"></p><p>   当第一层的矩形胶囊检测到一个旋转了16°的矩形时，他会预测房子胶囊会检测到一个旋转了16°的房子，船胶囊会检测到一个旋转了16°的船。这和矩形的方向一致。</p><p>   <img src="/var/folders/6p/_f33fscs7j316s490d30bm6c0000gn/T/abnerworks.Typora/image-20181013190410470.png" alt="image-20181013190410470"></p><p>   当第一层的三角形胶囊检测到了一个旋转了如上图所示的三角形，他会预测房子胶囊会检测到一个倒着的房子，船胶囊会检测到一个旋转了16°的船。这与三角形的方向一致。</p><p>   这两个胶囊在预测船胶囊的结果上相同，但是在预测房子胶囊的结果上面不相同。这时候，假定这个组合是一个船是非常合理的。</p><p>   因此，第一层胶囊的输出结果将只送往船胶囊，房子胶囊不会收到前面两个胶囊的输出。</p><p>   这种路径选择方法被称为routing by agreement，他有三个优点</p><ol><li>上一层的胶囊输出只会传给合适的下层胶囊，使得下层胶囊可以得到一个简洁的输入，并且能提高检测物体姿势的精度</li><li>通过查看激活路径，可以清楚地得到零件的层次结构，并且准确知道哪一个零件属于哪一个物体</li><li><p>有助于解析具有重叠对象的拥堵场景</p><p>选择方法：不断求平均值，把离群点的权重变小，然后迭代3-5次（K-MEANS?)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> cnn </category>
          
          <category> capsule </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode26_remove-duplicates-from-sorted-array</title>
      <link href="/2018/11/29/leetcode26-remove-duplicates-from-sorted-array/"/>
      <url>/2018/11/29/leetcode26-remove-duplicates-from-sorted-array/</url>
      
        <content type="html"><![CDATA[<p>双指针的题目</p><a id="more"></a><h1 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a>26. Remove Duplicates from Sorted Array</h1><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxpaaul1ktj30qq0h4acf.jpg" alt="image-20181129220656888"></p><p>题意很简单，去除数组中重复的数，返回剩余数组的长度l</p><p>注意：只能在原始数组上修改，原始数组的前l项是去重后的数组</p><p>思路:</p><p>双指针</p><p>保存一个low指针始终指向确认被加入去重后数组的元素</p><p>一个i指针顺序遍历数组</p><p>如果i和low相等，则不作操作，继续遍历</p><p>如果i和low不相等，则让low+1,并且把i的值赋给low然后继续遍历 (不相等就添加新值)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> nums==[]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span>(nums[low]!=nums[i]):</span><br><span class="line">                    low+=<span class="number">1</span></span><br><span class="line">                    nums[low] = nums[i]</span><br><span class="line">            <span class="keyword">return</span> low+<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第三周总结_全排列链表</title>
      <link href="/2018/11/25/%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93-%E5%85%A8%E6%8E%92%E5%88%97%E9%93%BE%E8%A1%A8/"/>
      <url>/2018/11/25/%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93-%E5%85%A8%E6%8E%92%E5%88%97%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>考试周题目做的有点杂，主要类型是全排列和总结</p><a id="more"></a><h2 id="Sum"><a href="#Sum" class="headerlink" title="Sum"></a>Sum</h2><p>周一是一道sum的题目，leetcode上面还有2sum,3sum等相同类型的题</p><p>给定一个数组和一个目标值，判断数组中是否有两个（或三个）数加起来等于目标值</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxdg9cmndbj31bs04ujs5.jpg" alt="img"></p><p>这个题目要求的是输出索引，所以需要建立一个字典来保存</p><p>步骤：</p><ol><li>遍历数组</li><li>如果t-n[i]不在字典中则把n[i]放入字段  key=n[i] value=i+1，然后继续遍历</li><li>如果t-n[i]在字典中，则输出[d[t-n[i]],i+1]</li></ol><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>全排列的题目做了两道，都是用的DFS的思想去解。跟之前做过的递归题相比，这次处理的不是构造好的树，而是数组。</p><h4 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46_Permutations"></a><a href="http://cuteanian.top/2018/11/20/leetcode46-Permutations/">46_Permutations</a></h4><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxeu2yad7ej30u20f6dgz.jpg" alt="img"></p><p>步骤:</p><ol><li>如果深度等于想要的排列长度就把当前cur添加进结果数组</li><li>如果不等于则继续遍历<ol><li>如果遍历的值被用过则下一个值</li><li>没有被用过则添加进cur然后继续递归下一个值</li><li>cur添加进结果数组后得到返回值回溯到上一个调用的函数中，把最后加入cur的值pop掉，并改成未被使用，然后继续向后搜索</li></ol></li></ol><h4 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47_Permutations_II"></a><a href="http://cuteanian.top/2018/11/21/leetcode47-Permutations-II/">47_Permutations_II</a></h4><p>跟46是一个类型的题，唯一的区别是要求输出的全排列给出的数组有重复的数，就导致结果需要去重</p><p>一句去重的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(used[i]==<span class="number">1</span> <span class="keyword">or</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> used[i<span class="number">-1</span>]==used[i] <span class="keyword">and</span> used[i<span class="number">-1</span>]==<span class="number">0</span>):</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>如果两个相邻的数相等并且前面的数没有被用过，则说明前面的数刚刚被移出cur，再加入一个相同的数会产生重复，因此需要跳过</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h4 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206_Reverse_Linked_List"></a><a href="http://cuteanian.top/2018/11/22/leetcode206-Reverse-Linked-List/">206_Reverse_Linked_List</a></h4><p>链表的反转</p><ol><li>最简单的思路：遍历链表，入栈，然后出栈并返回一个新链表</li><li>递归的思路: next=None时return，然后依次加入到新链表并返回</li><li><p>三个指针</p><p>三个指针的思路:</p></li></ol><p>一个pre指针指向前一个节点，一个cur指针指向当前节点，一个temp指针保存当前节点的下一个节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cur!=<span class="keyword">None</span>):</span><br><span class="line">    temp = cur.next  <span class="comment">#保存下当前节点的下一个节点</span></span><br><span class="line">    cur.next = pre   <span class="comment">#当前节点指向前一个节点</span></span><br><span class="line">    pre = cur        <span class="comment">#前一个节点后移</span></span><br><span class="line">    cur = temp       <span class="comment">#当前节点后移</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 链表 </category>
          
          <category> 全排列 </category>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode234_Palindrome_Linked_List</title>
      <link href="/2018/11/23/leetcode234-Palindrome-Linked-List/"/>
      <url>/2018/11/23/leetcode234-Palindrome-Linked-List/</url>
      
        <content type="html"><![CDATA[<p>判断链表是否是回文链表</p><a id="more"></a><h1 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234. Palindrome Linked List"></a>234. Palindrome Linked List</h1><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxi8zvdspqj30qw0bidgf.jpg" alt="image-20181123200254616"></p><p>链表跟数组比就是不能直接下标访问，所以要麻烦点</p><ol><li>首先要找到链表的中点，快慢指针，慢指针一次一步，快指针一次两步，当快指针到头的时候慢指针指向的就是链表的中点</li><li>然后把后半部分保存进栈，再出栈跟前半部分作比较，不一样的话就返回False</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        f=s=head</span><br><span class="line">        isP=[]</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">None</span> <span class="keyword">or</span> head.next==<span class="keyword">None</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">while</span>(f!=<span class="keyword">None</span> <span class="keyword">and</span> f.next!=<span class="keyword">None</span>):</span><br><span class="line">            f=f.next.next</span><br><span class="line">            s=s.next</span><br><span class="line">        <span class="keyword">while</span>(s!=<span class="keyword">None</span>):</span><br><span class="line">            isP.append(s.val)</span><br><span class="line">            s=s.next</span><br><span class="line">        <span class="keyword">while</span>(len(isP)):</span><br><span class="line">            <span class="keyword">if</span>(isP.pop()!=head.val):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode206_Reverse_Linked_List</title>
      <link href="/2018/11/22/leetcode206-Reverse-Linked-List/"/>
      <url>/2018/11/22/leetcode206-Reverse-Linked-List/</url>
      
        <content type="html"><![CDATA[<p>链表的反转问题</p><a id="more"></a><h1 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h1><p>最先想到的就是用栈保存，然后再出栈返回一个新的链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l = []</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">None</span>):</span><br><span class="line">            l.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">if</span>(len(l)):</span><br><span class="line">            r = ListNode(l.pop())</span><br><span class="line">            p = r</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">while</span>(len(l)):</span><br><span class="line">            n = ListNode(l.pop())</span><br><span class="line">            p.next = n</span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><p>三个指针的方法</p><p>四行代码分为四步:</p><ol><li>保存当前节点的下一个节点</li><li>当前节点的下一个节点指向前一个节点</li><li>把当前节点设为前一个节点</li><li>当前节点后移</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        pre = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span>(head):</span><br><span class="line">            temp = head.next  <span class="comment"># 保存下一个节点</span></span><br><span class="line">            head.next = pre   <span class="comment"># 当前节点指向前一个节点(实现反转) </span></span><br><span class="line">            pre = head        <span class="comment"># 前一个节点设为当前节点</span></span><br><span class="line">            head = temp       <span class="comment"># 当前节点后移</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><p>递归的方法</p><p>就判断一下递归结束的条件，然后创建一个新的链表返回即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    p = <span class="keyword">None</span></span><br><span class="line">    r = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">None</span>):</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        self.reverse(head)</span><br><span class="line">        <span class="keyword">return</span> self.r</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self,n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(n.next==<span class="keyword">None</span>):</span><br><span class="line">            self.p = ListNode(n.val)</span><br><span class="line">            self.r = self.p</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.reverseList(n.next)</span><br><span class="line">            temp = ListNode(n.val)</span><br><span class="line">            self.p.next =temp</span><br><span class="line">            self.p = self.p.next</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> list </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode47_Permutations_II</title>
      <link href="/2018/11/21/leetcode47-Permutations-II/"/>
      <url>/2018/11/21/leetcode47-Permutations-II/</url>
      
        <content type="html"><![CDATA[<p>还是全排列问题</p><a id="more"></a><h1 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a>47. Permutations II</h1><p>跟昨天那道题唯一的区别是输入的数组中有重复的值，也就导致结果会出现重复</p><p>可以使用排序去重的方法</p><p>跟昨天代码唯一不同的地方在于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(zero[i]==1 or i&gt;0 and nums[i-1] == nums[i] and zero[i-1]==0 ):</span><br></pre></td></tr></table></figure><p>如果满足当前遍历的值跟前面的值相等，并且前面的值未被使用的条件</p><p>则说明，前面的数刚刚被移除出cur，如果再加入一个相同的数则会产生重复，所以跳过这个值继续搜索。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        zero = []</span><br><span class="line">        cur = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            zero.append(<span class="number">0</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(self,nums,n,d,cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span>(d == n):</span><br><span class="line">                result.append(cur[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                    <span class="keyword">if</span>(zero[i]==<span class="number">1</span> <span class="keyword">or</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>] == nums[i] <span class="keyword">and</span> zero[i<span class="number">-1</span>]==<span class="number">0</span> ):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        zero[i]=<span class="number">1</span></span><br><span class="line">                        cur.append(nums[i])</span><br><span class="line">                        DFS(self,nums,n,d+<span class="number">1</span>,cur)</span><br><span class="line">                        cur.pop()</span><br><span class="line">                        zero[i]=<span class="number">0</span></span><br><span class="line">        DFS(self,nums,len(nums),<span class="number">0</span>,cur)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> DFS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode46_Permutations</title>
      <link href="/2018/11/20/leetcode46-Permutations/"/>
      <url>/2018/11/20/leetcode46-Permutations/</url>
      
        <content type="html"><![CDATA[<p>DFS搜索的问题</p><a id="more"></a><p>本来是想做39，结果发现要用到全排列的知识，就先把排列的四个题做了吧</p><h1 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h1><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxeu2yad7ej30u20f6dgz.jpg" alt="image-20181120211013064"></p><p>就是DFS的思想，之前是在树的结构上，这次是数组的搜索，也是一样的</p><ol><li>如果深度等于想要的排列长度就把当前cur添加进结果数组</li><li>如果不等于则继续遍历<ol><li>如果遍历的值被用过则下一个值</li><li>没有被用过则添加进cur然后继续递归下一个值</li><li>cur添加进结果数组后得到返回值回溯到上一个调用的函数中，把最后加入cur的值pop掉，并改成未被使用，然后继续向后搜索</li></ol></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        cur = []</span><br><span class="line">        used = []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            used.append(<span class="number">0</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(nums,n,d,cur,used)</span>:</span></span><br><span class="line">            <span class="keyword">if</span>(n==d):</span><br><span class="line">                result.append(cur[:])   <span class="comment">#必须是添加cur[:]是数组的复制，否则添加的是数组的引用，会出现问题</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                    <span class="keyword">if</span>(used[i]==<span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        used[i]=<span class="number">1</span></span><br><span class="line">                        cur.append(nums[i])</span><br><span class="line">                        DFS(nums,n,d+<span class="number">1</span>,cur,used)</span><br><span class="line">                        cur.pop()</span><br><span class="line">                        used[i]=<span class="number">0</span></span><br><span class="line">        DFS(nums,len(nums),<span class="number">0</span>,cur,used)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> DFS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Interpretable_Machine_Learning</title>
      <link href="/2018/11/19/Interpretable-Machine-Learning/"/>
      <url>/2018/11/19/Interpretable-Machine-Learning/</url>
      
        <content type="html"><![CDATA[<p>机器学习的可解释性</p><p>[TOC]</p><a id="more"></a><h1 id="2-Interpretable"><a href="#2-Interpretable" class="headerlink" title="2. Interpretable"></a>2. Interpretable</h1><h2 id="2-1-Importance"><a href="#2-1-Importance" class="headerlink" title="2.1 Importance"></a>2.1 Importance</h2><p>A correct prediction only partially solves your original problem. The following reasons(Why) drive the demand for interpretability and explanations</p><ol><li>To facilitate learning and satisfy curiosity as to why certain predictions or behaviors are created by machines, interpretability and explanations are crucial. </li><li>The more a machine’s decision affects a person’s life, the more important it will be for the machine to explain its behavior.</li><li>Interpretability makes it possible to extract this additional knowledge captured by the model.</li><li>Machine learning models take on real-world tasks that require <strong>safety measures</strong> and testing.</li><li>Interpretability is a useful debugging tool for <strong>detecting bias</strong> in machine learning models.</li><li>The process of integrating machines and algorithms into our daily lives requires interpretability to increase <strong>social acceptance</strong>.</li><li>Machine learning models can only be <strong>debugged and audited</strong> when they can be interpreted.</li></ol><h2 id="2-2-Taxonomy-of-Interpretability-Methods"><a href="#2-2-Taxonomy-of-Interpretability-Methods" class="headerlink" title="2.2 Taxonomy of Interpretability Methods"></a>2.2 Taxonomy of Interpretability Methods</h2><h3 id="Intrinsic-amp-amp-Post-hoc"><a href="#Intrinsic-amp-amp-Post-hoc" class="headerlink" title="Intrinsic &amp;&amp; Post hoc"></a>Intrinsic &amp;&amp; Post hoc</h3><p><strong>Intrinsic</strong> interpretability refers to machine learning models that are considered interpretable due to their simple structure, such as short decision trees or sparse linear models. </p><p><strong>Post hoc</strong> interpretability refers to the application of interpretability methods after model training.</p><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>The various interpretability methods can be roughly differentiated according to their results.</p><ol><li>Feature summary statistic</li><li>Feature summary visualization</li><li><p>Model internals(e.g.:learned weight)</p></li><li><p>Data point（for images and text)</p></li><li>Intrinsically interpertable model</li></ol><h3 id="Model-specific-amp-amp-model-agnostic"><a href="#Model-specific-amp-amp-model-agnostic" class="headerlink" title="Model-specific &amp;&amp; model-agnostic"></a>Model-specific &amp;&amp; model-agnostic</h3><p>Model-specific interpretation tools are limited to specific model classes.(e.g.:intrinsic)</p><p>Model-agnostic tools can be used on any machine learning model (e.g.:post hoc)</p><h3 id="Local-or-Global"><a href="#Local-or-Global" class="headerlink" title="Local or Global"></a>Local or Global</h3><p>Does the interpretation method explain an individual prediction or the entire model behavior? Or is the scope somewhere in between?</p><h2 id="2-3-Scope-of-Interpretability"><a href="#2-3-Scope-of-Interpretability" class="headerlink" title="2.3 Scope of Interpretability"></a>2.3 Scope of Interpretability</h2><h3 id="Algorithm-Transparency"><a href="#Algorithm-Transparency" class="headerlink" title="Algorithm Transparency"></a>Algorithm Transparency</h3><p><em>How does the algorithm create the model?</em></p><p>Algorithm transparency only requires knowledge of the algorithm and not of the data or learned models</p><h3 id="Global-Holistic-Model-Interpretablity"><a href="#Global-Holistic-Model-Interpretablity" class="headerlink" title="Global,Holistic Model Interpretablity"></a>Global,Holistic Model Interpretablity</h3><p><em>How does the trained model make predictions?</em></p><p>To explain the global model output, you need the trained model, knowledge of the algorithm and the data. </p><p>Global is very difficulit to achieve in practice</p><h3 id="Global-Model-Interpretability-on-a-Modular-Level"><a href="#Global-Model-Interpretability-on-a-Modular-Level" class="headerlink" title="Global Model Interpretability on a Modular Level"></a>Global Model Interpretability on a Modular Level</h3><p><em>How do parts of the model affect predictions?</em></p><h3 id="Local-Interpretability-for-a-Single-Prediction"><a href="#Local-Interpretability-for-a-Single-Prediction" class="headerlink" title="Local Interpretability for a Single Prediction"></a>Local Interpretability for a Single Prediction</h3><p><em>Why did the model make a certain prediction for an instance?</em></p><p>You can zoom in on a single instance and examine what kind of prediction the model makes for this input, and explain why it made this decision.</p><h3 id="Local-Interpretability-for-a-Group-of-Predictions"><a href="#Local-Interpretability-for-a-Group-of-Predictions" class="headerlink" title="Local Interpretability for a Group of Predictions"></a>Local Interpretability for a Group of Predictions</h3><p><em>Why did the model make specific predictions for a group of instances?</em></p><h2 id="2-4-Evaluating-Interpretability"><a href="#2-4-Evaluating-Interpretability" class="headerlink" title="2.4 Evaluating Interpretability"></a>2.4 Evaluating Interpretability</h2><p>Doshi-Velez and Kim (2017) propose three main levels for the evaluation of interpretability:</p><h3 id="Application-level-evaluation-real-task"><a href="#Application-level-evaluation-real-task" class="headerlink" title="Application level evaluation(real task)"></a>Application level evaluation(real task)</h3><p>Put the explanation into the product and have it tested by the end user.</p><h3 id="Human-level-evaluation-simple-task"><a href="#Human-level-evaluation-simple-task" class="headerlink" title="Human level evaluation(simple task)"></a>Human level evaluation(simple task)</h3><p> A simplified application level evaluation.</p><p> The difference is that these experiments are not carried out with the domain experts, but with laypersons.</p><h3 id="Function-level-evaluation-proxy-task"><a href="#Function-level-evaluation-proxy-task" class="headerlink" title="Function level evaluation (proxy task)"></a>Function level evaluation (proxy task)</h3><p>Does not require humans. </p><h2 id="2-5-Properties-of-Explanations"><a href="#2-5-Properties-of-Explanations" class="headerlink" title="2.5 Properties of Explanations"></a>2.5 Properties of Explanations</h2><p>These properties can be used to judge how good an explanation (method) is. It’s not clear for all these properties how to measure them correctly, so one of the challenges is to formalize how they could be calculated.</p><p><strong>Properties of Explanation Methods</strong></p><ol><li><strong>Express power </strong>is the “language” or structure of the explanations the method is able to generate. </li><li><strong>Translucency</strong> describes how much the explanation method relies on looking into the machine learning model, like its parameters. </li><li><strong>Portability</strong> describes the range of machine learning models with which the explanation method can be used. </li><li><strong>Algorithmic Complexity</strong> describes the computational complexity of the method that generates the explanation. </li></ol><p><strong>Properties of Individual Explanations</strong></p><ol><li><strong>Accuracy</strong>: How well does an explanation predict unseen data?</li><li><strong>Fidelity</strong>: How well does the explanation approximate the prediction of the black box model?</li><li><strong>Consistency</strong>: How much does an explanation differ between models that have been trained on the same task and that produce similar predictions?</li><li><strong>Stability</strong>: How similar are the explanations for similar instances? </li><li><strong>Comprehensibility</strong>: How well do humans understand the explanations?</li><li><strong>Certainty</strong>: Does the explanation reflect the certainty of the machine learning model?</li><li><strong>Degree of Importance</strong>: How well does the explanation reflect the importance of features or parts of the explanation?</li><li><p><strong>Novelty</strong>: Does the explanation reflect whether a data instance to be explained comes from a “new” region far removed from the distribution of training data?</p></li><li><p><strong>Representativeness</strong>: How many instances does an explanation cover?</p></li></ol><h2 id="2-6-Human-friendly-Explanations"><a href="#2-6-Human-friendly-Explanations" class="headerlink" title="2.6 Human-friendly Explanations"></a>2.6 Human-friendly Explanations</h2><h3 id="What-is-a-good-explanation"><a href="#What-is-a-good-explanation" class="headerlink" title="What is a good explanation"></a>What is a good explanation</h3><ol><li><strong>Explanations are contrastive</strong>: Humans usually don’t ask why a certain prediction was made, but rather why this prediction was made instead of another prediction. </li><li><strong>Explanations are selected</strong> :<strong>What it means for interpretable machine learning</strong>: Make the explanation very short, give only 1 to 3 reasons, even if the world is more complex. </li><li><strong>Explanations are social</strong>: Be mindful of the social setting of your machine learning application and of the target audience.</li><li><strong>Explanations focus on the abnormal</strong>. If one of the input features for a prediction was abnormal in any sense (like a rare category of a categorical feature) and the feature influenced the prediction, it should be included in an explanation, even if other ‘normal’ features have the same influence on the prediction as the abnormal one. </li><li><strong>Explanations are truthful</strong>. The explanation should predict the event as truthfully as possible, which is sometimes called <strong>fidelity</strong> in the context of machine learning. </li><li><strong>Good explanations are coherent with prior beliefs of the explainee</strong>.</li><li><strong>Good explanations are general and probable</strong>.</li></ol><h1 id="3-Datasets"><a href="#3-Datasets" class="headerlink" title="3. Datasets"></a>3. Datasets</h1><ol><li>Bike sharing counts(Regression)</li><li>YouTube Spam Comments(Text Classification)</li><li>Risk Factors For Cervical Cancer(Classfication)</li></ol><h1 id="4-Interpretable-Models"><a href="#4-Interpretable-Models" class="headerlink" title="4. Interpretable Models"></a>4. Interpretable Models</h1><p><img src="/var/folders/6p/_f33fscs7j316s490d30bm6c0000gn/T/abnerworks.Typora/image-20181206161452656.png" alt="image-20181206161452656"></p><h2 id="4-1-Linear-Regression-Model"><a href="#4-1-Linear-Regression-Model" class="headerlink" title="4.1 Linear Regression Model"></a>4.1 Linear Regression Model</h2><h3 id="Interpretation"><a href="#Interpretation" class="headerlink" title="Interpretation"></a>Interpretation</h3><p> $R^{2}$ measurement.  $R^{2}$ tells you how much of the total variance of your target outcome is explained by the model. The higher  $R^{2}$ the better your model explains the data.</p><p>$R^{2} = 1 - SSE/SST$</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxx3rsaex1j306801m746.jpg" alt="image-20181206162539535"></p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxx3rxt86yj306401z746.jpg" alt="image-20181206162549601"></p><p>There is a catch, because R2R2 increases with the number of features in the model, even if they carry no information about the target value at all. So it is better to use the adjusted R-squared, which accounts for the number of features used in the model. </p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxx3t0q9drj30eu01xt8m.jpg" alt="image-20181206162652114"></p><p>while p is the number of feature and n the number of instances.</p><p>The importance of a feature in a linear regression model can be measured by the absolute value of its t-statistic. The t-statistic is the estimated weight scaled with it’s standard error.</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxx3un9dn6j3042025dfp.jpg" alt="image-20181206162824717"></p><h1 id="5-Model-Agnostic-Methods"><a href="#5-Model-Agnostic-Methods" class="headerlink" title="5. Model-Agnostic Methods"></a>5. Model-Agnostic Methods</h1><h2 id="5-1-Partial-Dependence-Plot-PDP"><a href="#5-1-Partial-Dependence-Plot-PDP" class="headerlink" title="5.1 Partial Dependence Plot(PDP)"></a>5.1 Partial Dependence Plot(PDP)</h2><p>The partial dependence plot (PDP or PD plot) shows the marginal effect of a feature on the predicted outcome of a previously fit model.</p><p>For classification, where the machine model outputs probabilities, the partial dependence function displays the probability for a certain class given different values for features xSxS. A straightforward way to handle multi-class problems is to plot one line or one plot per class.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>In practice, the set of features xSxS usually only contains one feature or a maximum of two, because one feature produces 2D plots and two features produce 3D plots.</p><p>The influence of the weather features on the predicted bike counts:</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxx5nm3m50j30m40fjt9i.jpg" alt="image-20181206173039784"></p><h3 id="5-2-Advantages-amp-Disadvantages"><a href="#5-2-Advantages-amp-Disadvantages" class="headerlink" title="5.2 Advantages &amp; Disadvantages"></a>5.2 Advantages &amp; Disadvantages</h3><h4 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h4><ol><li>The computation of partial dependence plots is <strong>intuitive</strong>: </li><li>If the feature for which you computed the PDP is uncorrelated with the other model features, then the PDPs are perfectly representing how the feature influences the target on average.</li><li>Partial dependence plots are <strong>simple to implement</strong>.</li><li><strong>Causal interpretation</strong></li></ol><h4 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages"></a>Disadvantages</h4><ol><li><p>The <strong>maximum number of features</strong> you can look at jointly is realistically two or three</p></li><li><p>Some PD plots don’t include the <strong>feature distribution</strong>. </p></li><li>The <strong>assumption of independence</strong> poses the biggest issue of PD plots.</li><li><strong>Heterogeneous effects might be hidden</strong></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://christophm.github.io/interpretable-ml-book/" target="_blank" rel="noopener">https://christophm.github.io/interpretable-ml-book/</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode167TwoSum</title>
      <link href="/2018/11/19/leetcode167TwoSum/"/>
      <url>/2018/11/19/leetcode167TwoSum/</url>
      
        <content type="html"><![CDATA[<p>群里今天的题是4sum，找出四个数的和是给定值</p><p>想了一下不知道咋搞，查的时候看到leetcode上有一堆类似的题，2sum,3sum</p><p>那就这周的五个题就做这个类型吧，也不知道算啥类型就写了个sum</p><a id="more"></a><h1 id="167-Two-Sum-II-Input-array-is-sorted"><a href="#167-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="167. Two Sum II - Input array is sorted"></a>167. Two Sum II - Input array is sorted</h1><p>这个题目也不是最原型的题目，这个是给了一个给定顺序的数组，要求返回索引值</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxdg9cmndbj31bs04ujs5.jpg" alt="image-20181119162622697"></p><p>最原型的题目是无序的数组，然后返回数组值，用一个map保存然后输出的时候判断一下大小即可。</p><p>这次要输出索引值，换成字典</p><ol><li>每一次遍历时判断字典中是否已经有target-numbers[i],有的话直接返回[d[numbers[i]],i+1]</li><li>没有则把t-n[i]的值和i一起存入字典</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers, target)</span>:</span></span><br><span class="line">        d = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            com = target - numbers[i]</span><br><span class="line">            <span class="keyword">if</span>(d.has_key(numbers[i])):</span><br><span class="line">                <span class="keyword">return</span> [d[numbers[i]],i+<span class="number">1</span>]</span><br><span class="line">            d.setdefault(com,i+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> sum </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>双指针总结</title>
      <link href="/2018/11/18/%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/18/%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>按照主题的第二周的刷题，这周都是双指针的题目</p><a id="more"></a><p>一共五道题</p><p>这五个题涉及到的双指针可以解决的类型有：</p><ol><li>数组的原地排序（两个数905,三个数75）</li><li>回文序列 125</li><li>寻找环     287</li></ol><p>后面遇到其他的类型再继续添加</p>]]></content>
      
      
      <categories>
          
          <category> 双指针 </category>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue基础五</title>
      <link href="/2018/11/16/vue%E5%9F%BA%E7%A1%80%E4%BA%94/"/>
      <url>/2018/11/16/vue%E5%9F%BA%E7%A1%80%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>vue组件基础</p><a id="more"></a><h1 id="Vue基础-五-组件基础"><a href="#Vue基础-五-组件基础" class="headerlink" title="Vue基础(五) 组件基础"></a>Vue基础(五) 组件基础</h1><p>组件是可以复用的vue实例，并且带有一个名字，我们可以在一个通过 <code>new Vue</code> 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 button-counter 的新组件</span></span><br><span class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;<span class="attr">el</span>:<span class="string">"#components-demo"</span>&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"components-demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为组件是可复用的 Vue 实例，所以它们与 <code>new Vue</code> 接收相同的选项，例如 <code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code> 以及生命周期钩子等。仅有的例外是像 <code>el</code>这样根实例特有的选项。</p><h2 id="组件的复用"><a href="#组件的复用" class="headerlink" title="组件的复用"></a>组件的复用</h2><p>可以将组件复用任意的次数，每个组件都会维护他自己的count。</p><p>因为每用一次组件，就会有一个新的实例被创建</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"components-demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="data必须是一个函数"><a href="#data必须是一个函数" class="headerlink" title="data必须是一个函数"></a>data必须是一个函数</h3><p>组件的data选项必须是函数，这样每个实例就可以维护一份被返回对象的独立的拷贝，否则他们会共享一个count值。</p><h2 id="组件的组织"><a href="#组件的组织" class="headerlink" title="组件的组织"></a>组件的组织</h2><p>通常一个应用会以一棵嵌套的组件树的形势来组织:</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxa901m53pj30ge05t74f.jpg" alt="image-20181116215836008"></p><p>可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。</p><p>为了让Vue可以识别需要进行组件的注册Vue.component就是组件的全局注册</p><p>待续</p><h2 id="通过Prop向子组件传递数据"><a href="#通过Prop向子组件传递数据" class="headerlink" title="通过Prop向子组件传递数据"></a>通过Prop向子组件传递数据</h2><p>pop是可以在组件上注册的自定义特性。当一个值传递给prop特性时他就变成了那个组件实例的一个属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'title'</span>],</span><br><span class="line">  template: <span class="string">'&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中title就变成了blog-post这个组件实例的一个属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"My journey With Vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>待续</p><h3 id="单个根元素"><a href="#单个根元素" class="headerlink" title="单个根元素"></a>单个根元素</h3><p>vue每个组件必须只有一个根元素</p><p>如果模板中包含更多的东西时不能直接写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template:<span class="string">'&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">  &lt;div v-html="content"&gt;&lt;/div&gt;'</span></span><br></pre></td></tr></table></figure><p>但是可以把他包含在一个父元素中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template:</span><br><span class="line"><span class="string">'&lt;div class="blog-post"&gt;</span></span><br><span class="line"><span class="string">  &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">  &lt;div v-html="content"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;'</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">"post in posts"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">"post.id"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:post</span>=<span class="string">"post"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'post'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="blog-post"&gt;</span></span><br><span class="line"><span class="string">      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-html="post.content"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#blog-post-demo'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        posts:[</span><br><span class="line">            &#123;<span class="attr">title</span>:,<span class="attr">content</span>:&#125;,</span><br><span class="line">            ...</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="通过事件向父级组件发送消息"><a href="#通过事件向父级组件发送消息" class="headerlink" title="通过事件向父级组件发送消息"></a>通过事件向父级组件发送消息</h2><p>子组件通过emit来触发事件，把消息传递出去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'post'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="blog-post"&gt;</span></span><br><span class="line"><span class="string">      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="emit('enlarge-text')"&gt;</span></span><br><span class="line"><span class="string">        Enlarge text</span></span><br><span class="line"><span class="string">      &lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-html="post.content"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#blog-posts-events-demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    posts: [<span class="comment">/* ... */</span>],</span><br><span class="line">    postFontSize: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'blog-post-event-demo'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-on:energe-text:</span>"<span class="attr">postFontSize</span>+=<span class="string">0.1</span>"&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以使用emit的第二个参数来抛出值，这个参数抛出的值在v-on中用$event来接收</p><p>如果事件处理函数是一个方法，那么这个值会被作为方法的第一个参数传入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"$emit('enlarge-text', 0.1)"</span>&gt;</span></span><br><span class="line">  Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用$event接收</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enlarge-text</span>=<span class="string">"postFontSize += $event"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enlarge-text</span>=<span class="string">"onEnlargeText"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在组件上使用v-model"><a href="#在组件上使用v-model" class="headerlink" title="在组件上使用v-model"></a>在组件上使用v-model</h3><p>如果想让自定义输入组件支持v-model需要这样做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'custom-input'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'value'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      v-bind:value="value"</span></span><br><span class="line"><span class="string">      v-on:input="$emit('input', $event.target.value)"</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-model</span>=<span class="string">"searchText"</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="通过插槽分发内容"><a href="#通过插槽分发内容" class="headerlink" title="通过插槽分发内容"></a>通过插槽分发内容</h2><h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode287Find_the_Duplicate_Number</title>
      <link href="/2018/11/16/leetcode287Find-the-Duplicate-Number/"/>
      <url>/2018/11/16/leetcode287Find-the-Duplicate-Number/</url>
      
        <content type="html"><![CDATA[<p>寻找数组中重复的数值</p><a id="more"></a><h1 id="287-Find-the-Duplicate-Number"><a href="#287-Find-the-Duplicate-Number" class="headerlink" title="287. Find the Duplicate Number"></a>287. Find the Duplicate Number</h1><p>Given an array <em>nums</em> containing <em>n</em> + 1 integers where each integer is between 1 and <em>n</em> (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxa7e1v7rsj311m0b8aar.jpg" alt="image-20181116210250287"></p><ol><li>You <strong>must not</strong> modify the array (assume the array is read only).</li><li>You must use only constant, <em>O</em>(1) extra space.</li><li>Your runtime complexity should be less than <em>O</em>(<em>n</em>2).</li><li>There is only one duplicate number in the array, but it could be repeated more than once.</li></ol><p>难点在于时间复杂度和空间复杂度要求比较高，所以不能暴力解</p><p>注意题目给的两个条件:</p><ol><li>只有一个重复的数值</li><li>数组中最大值不超过n-1</li></ol><p>看到别人很巧妙的解法</p><p>思路:</p><ol><li>利用条件2可以把数组转换为一个链表</li><li>由条件1可以知道这个链表是一个有环链表，并且入环点就是重复的值</li></ol><p>如数组 [1,2,3,5,4,2]转换为链表</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxa7lcdnfxj309c040q3d.jpg" alt="image-20181116210953831"></p><p>然后这个问题就转换成了寻找链表入环点的问题</p><p>就很自然想到了快慢指针，然后始终会在一个点相遇</p><p>最后要解决的问题就是相遇点和入环点之间的关系</p><p>先上结论：</p><p>相遇点到入环点的距离 = 链表头到入环点的距离</p><p>证明:</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxa80kcsuvj309804c3z9.jpg" alt="image-20181116211410215"></p><p>如图所示：</p><p>S是起始点，O是入环点，x是相遇点</p><p>x是从o到X的距离  m是从x到o的距离</p><p>慢指针走过的路程：SO+x</p><p>快指针走过的路程:   SO+x+m</p><p>相遇时满足条件：SO+x+m = 2(SO+x)</p><p>整理得到m = SO+x</p><p>有了这个结论后，我们让慢指针回到起始点，然后和快指针一起往前走，他们就一定会在入环点相遇</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        s = nums[nums[<span class="number">0</span>]]</span><br><span class="line">        f = nums[nums[s]]</span><br><span class="line">        <span class="keyword">while</span>(s!=f):</span><br><span class="line">            s = nums[s]</span><br><span class="line">            f = nums[nums[f]]</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(s!=f):</span><br><span class="line">            s = nums[s]</span><br><span class="line">            f = nums[f]</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue基础四</title>
      <link href="/2018/11/15/vue%E5%9F%BA%E7%A1%80%E5%9B%9B/"/>
      <url>/2018/11/15/vue%E5%9F%BA%E7%A1%80%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>vue 事件、表单绑定</p><a id="more"></a><h1 id="vue基础-事件，表单绑定"><a href="#vue基础-事件，表单绑定" class="headerlink" title="vue基础 事件，表单绑定"></a>vue基础 事件，表单绑定</h1><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>v-on监听事件，并在触发时运行一些代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"counter += 1"</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-1'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="事件处理方法"><a href="#事件处理方法" class="headerlink" title="事件处理方法"></a>事件处理方法</h3><p>v-on可以接受一个需要调用的方法</p><p>也可以在内联js语句中调用方法</p><p>也可以把特殊变量$event传入方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- `greet` 是在下面定义的方法名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"greet"</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"sayHi(‘hi’)"</span>&gt;</span>SayHi<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"warn(‘Warn’,$event)"</span>&gt;</span>Warn<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-2'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: <span class="string">'Vue.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 在 `methods` 对象中定义方法</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    greet: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 在方法里指向当前 Vue 实例</span></span><br><span class="line">      alert(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>)</span><br><span class="line">      <span class="comment">// `event` 是原生 DOM 事件</span></span><br><span class="line">      <span class="keyword">if</span> (event) &#123;</span><br><span class="line">        alert(event.target.tagName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    sayHi:<span class="function"><span class="keyword">function</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">          alert(message)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    warn:<span class="function"><span class="keyword">function</span>(<span class="params">message,event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(event) event.preventDefault()</span><br><span class="line">        alert(message)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以用 JavaScript 直接调用方法</span></span><br><span class="line">example2.greet() <span class="comment">// =&gt; 'Hello Vue.js!'</span></span><br></pre></td></tr></table></figure><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>目的：让方法只有简单的数据逻辑，没有DOM事件细节</p><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li><li><code>.once</code></li><li><code>.passive</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><h3 id="系统修饰符"><a href="#系统修饰符" class="headerlink" title="系统修饰符"></a>系统修饰符</h3><h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><p>你可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。</p><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"edit me"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Multiline message is:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"white-space: pre-line;"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"add multiple lines"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h4><p>单个</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"checked"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"checkbox"</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><p>多个</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'example-3'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"jack"</span> <span class="attr">value</span>=<span class="string">"Jack"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"jack"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"john"</span> <span class="attr">value</span>=<span class="string">"John"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"john"</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"mike"</span> <span class="attr">value</span>=<span class="string">"Mike"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"mike"</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-3'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    checkedNames: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"One"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"Two"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example4 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#example-4'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        picked:<span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="选择框"><a href="#选择框" class="headerlink" title="选择框"></a>选择框</h4><p>单选 字符串  如果是多选用数组</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">'example-5'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span> = <span class="string">''</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">'A'</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">'B'</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;selected&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example5 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#example-5'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        selected:<span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以用v-for动态渲染</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"options"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">'option in options'</span> <span class="attr">v-bind:value</span>=<span class="string">"option.value"</span>&gt;</span></span><br><span class="line">        &#123;&#123;option.text&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'...'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: <span class="string">'A'</span>,</span><br><span class="line">    options: [</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'One'</span>, <span class="attr">value</span>: <span class="string">'A'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'Two'</span>, <span class="attr">value</span>: <span class="string">'B'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'Three'</span>, <span class="attr">value</span>: <span class="string">'C'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h3><p>把值绑定到 Vue 实例的一个动态属性上，这时可以用 <code>v-bind</code> 实现，并且这个属性的值可以不是字符串。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">v-model</span>=<span class="string">"pick"</span> <span class="attr">v-bind:value</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当被选中 vm.pick = a --&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内联对象字面量 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-bind:value</span>=<span class="string">"&#123; number: 123 &#125;"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当被选中  vm.selected = &#123;number:123&#125; --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>.lazy</p><p>在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步 (除了<a href="https://cn.vuejs.org/v2/guide/forms.html#vmodel-ime-tip" target="_blank" rel="noopener">上述</a>输入法组合文字时)。你可以添加 <code>lazy</code> 修饰符，从而转变为使用 <code>change</code>事件进行同步：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">"msg"</span> &gt;</span></span><br></pre></td></tr></table></figure><p>.number </p><p>用户输入自动转成数值类型</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"number"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>.trim</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span> = <span class="string">"msg"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://cn.vuejs.org/v2/guide/events.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/events.html</a></li><li></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode75_Sort_Colors</title>
      <link href="/2018/11/15/leetcode75-Sort-Colors/"/>
      <url>/2018/11/15/leetcode75-Sort-Colors/</url>
      
        <content type="html"><![CDATA[<p>双指针三个元素的原地排序</p><a id="more"></a><p>Given an array with <em>n</em> objects colored red, white or blue, sort them <strong>in-place</strong> so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p><p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p><p><strong>Note:</strong> You are not suppose to use the library’s sort function for this problem.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,0,2,1,1,0]</span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p>还是双指针的题，自己只想到了暴力思路</p><p>先把0放在前面， 然后再遍历一次把1放在前面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        l = len(nums)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        k=l<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>):</span><br><span class="line">                nums[i],num[j] = nums[j],nums[i]</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">1</span>):</span><br><span class="line">                nums[i],num[j] = nums[j],nums[i]</span><br><span class="line">                j+=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>看了别人提交的代码，三个指针</p><p>其实最开始也是想到了这个思路，就是什么时候i+=1混乱了，导致[1,2,0]的样例通不过。</p><p>如果是跟k交换，i不要加1，要等下一轮迭代再判断一次交换过来的值才可以。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        l = len(nums)</span><br><span class="line">        i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        k=l<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=k):</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">1</span>):</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span>(nums[i]==<span class="number">0</span>):</span><br><span class="line">                nums[i],nums[j] = nums[j],nums[i]</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[i],nums[k] = nums[k],nums[i]</span><br><span class="line">                k-=<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode27移除元素</title>
      <link href="/2018/11/14/leetcode27%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/2018/11/14/leetcode27%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>双指针移除元素</p><a id="more"></a><h1 id="leetcode27移除元素"><a href="#leetcode27移除元素" class="headerlink" title="leetcode27移除元素"></a>leetcode27移除元素</h1><p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> and return the new length.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fx7wdbssfkj31cq0iwq5w.jpg" alt="image-20181114211103822"></p><p>题目虽然要求的是返回移除后的数组长度l，但是最后的输出值是移除元素后的数组。（输出原数组的前l项）</p><p>所以不能只得到长度，要对数组进行操作，把数组的前l项变为移除val后的值。</p><p>因为还是特意找的双指针的题目，所以知道双指针的思路后发现跟之前做过的一个把所有的0移到后面的题目是一样的，把所有val值后移即可</p><p>思路：</p><ol><li>两个指针i,j，j始终在后面</li><li>如果i指向不是val的值则交换并且j+1</li><li>如果指向的是val则j和数组不作操作,i+1。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        l = len(nums)</span><br><span class="line">        result = l</span><br><span class="line">        j=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            <span class="keyword">if</span>(val != nums[i]):</span><br><span class="line">                temp = nums[i]</span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">                nums[j] = temp</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode125Valid_Palindrome</title>
      <link href="/2018/11/13/leetcode125Valid-Palindrome/"/>
      <url>/2018/11/13/leetcode125Valid-Palindrome/</url>
      
        <content type="html"><![CDATA[<p>判断一个字符串是否是回文字符串</p><a id="more"></a><p>既然第一天做了双指针的问题，就干脆这周都做双指针的问题吧~应该相对比较好理解，考试压力大刷点简单的题目&gt;&lt;</p><h1 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125. Valid Palindrome"></a>125. Valid Palindrome</h1><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fx6mkgaxhqj31ci0bi758.jpg" alt="image-20181113184618313"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(len(s)==<span class="number">0</span> <span class="keyword">or</span> len(s)==<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        ss = [ch <span class="keyword">for</span> ch <span class="keyword">in</span> s.lower() <span class="keyword">if</span> ch.isalpha() <span class="keyword">or</span> ch.isdigit()]</span><br><span class="line">        l = len(ss)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l/<span class="number">2</span>):</span><br><span class="line">            print(i,l-i<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span>(ss[i]!=ss[l-i<span class="number">-1</span>]):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>就很简单的先把数组中非字母非数字的字符去掉，然后双指针比较，如果不相同则返回Flase</p><p><strong>Python列表的过滤</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[expr <span class="keyword">for</span> iter_val <span class="keyword">in</span> iterable <span class="keyword">if</span> cond_expr]</span><br><span class="line"></span><br><span class="line"><span class="comment">#求奇数</span></span><br><span class="line">b = [val <span class="keyword">for</span> val <span class="keyword">in</span> a <span class="keyword">if</span> val%<span class="number">2</span>==<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Machine_Learning_Explanations_with_Topological_Data_Analysis</title>
      <link href="/2018/11/12/Machine-Learning-Explanations-with-Topological-Data-Analysis/"/>
      <url>/2018/11/12/Machine-Learning-Explanations-with-Topological-Data-Analysis/</url>
      
        <content type="html"><![CDATA[<p>用拓扑数据分析来解释深度学习</p><p>[TOC]</p><a id="more"></a><h1 id="Machine-Learning-Explanations-with-Topological-Data-Analysis"><a href="#Machine-Learning-Explanations-with-Topological-Data-Analysis" class="headerlink" title="Machine Learning Explanations with  Topological Data Analysis"></a>Machine Learning Explanations with  Topological Data Analysis</h1><p>术语解释</p><p><strong>simplicial complexes</strong>：单纯复形是拓扑学中的概念，指由点，线，三角形等单纯形“粘合”而得的拓扑对象。</p><p><strong>cover of dataset</strong>:A cover of a data set is a collection of subsets of the data such that every data point is in at least one of the subsets.</p><p><strong>nerve</strong>:The nerve is a simplicial complex created from a cover by collapsing each cover element into vertices and connecting vertices when the cover elements had points in common.</p><p><strong>nerve of a cover</strong> :  A construction of an <a href="https://ipfs.io/ipfs/QmXoypizjW3WknFiJnKLwHCnL72vedxjQkDDP1mXWo6uco/wiki/Abstract_simplicial_complex.html" target="_blank" rel="noopener">abstract simplicial complex</a> from an <a href="https://ipfs.io/ipfs/QmXoypizjW3WknFiJnKLwHCnL72vedxjQkDDP1mXWo6uco/wiki/Cover_(topology" target="_blank" rel="noopener">open covering</a>.html)of a <a href="https://ipfs.io/ipfs/QmXoypizjW3WknFiJnKLwHCnL72vedxjQkDDP1mXWo6uco/wiki/Topological_space.html" target="_blank" rel="noopener">topological space</a> <em>X</em>.</p><p><strong>lens:</strong> A secondary representation of the data that encodes some interested aspect or information about the data set.    ??</p><p><strong>pullback cover</strong>:</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>We will demonstrate a novel application of Mapper to the domain of explanatory machine learning and show how Mapper can be used to understand not just the shape of data, but also understand a machine learning model.</p><p>提出了Mapper的一个新的应用来解释机器学习。</p><h2 id="Topological-Building-Blocks"><a href="#Topological-Building-Blocks" class="headerlink" title="Topological Building Blocks"></a>Topological Building Blocks</h2><p>Both Mapper and Persistent Homology make use of <strong>simplicial complexes</strong> as the tool for understanding complicated shape. A simplicial complex is a generalization of a graph, with a few special features.</p><p>simplicial complexes are built from the <strong>nerve of a cover</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fx5lwcfjcfj30cj07c3z9.jpg" alt="image-20181112213732110"></p><p>Mapper constructs a single cover in a supervised manner and provides a representation suitable for exploratory data analysis.</p><p>In this work, we will focus on understanding the exploratory power of Mapper and how we can apply it to understand a machine learning model. </p><h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2><p> Mapper can be thought of as a method of estimating and capturing this essential high dimensional structure.</p><p>Mapper是一个评价刻画高维数据的方法。</p><p>单纯复形在探索数据间的关系时美观实用</p><ol><li>creating a lens</li><li>computing the <strong>pullback cover</strong> of our constructed lens cover.</li><li>compute the nerve of our constructed pullback cover. </li></ol><h2 id="Data-and-Model"><a href="#Data-and-Model" class="headerlink" title="Data and Model"></a>Data and Model</h2><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxewzivxijj30g7093t98.jpg" alt="image-20181119182128358"></p><p> A Logistic Regression model to 91.5% test set accuracy using Scikit-Learn</p><h2 id="Mapper-for-explaining-machine-learning"><a href="#Mapper-for-explaining-machine-learning" class="headerlink" title="Mapper for explaining machine learning"></a>Mapper for explaining machine learning</h2><p>Designing a new type of cover specifically for machine learning classifiers. </p><p>method: rank and threshold the predicted probabilities for each observation and generate a cover element for similarly ranked observations.</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxewzf52ngj30dl0begm4.jpg" alt="image-20181120214611985"></p><pre><code>new covering technique</code></pre><h2 id="Instance-Based-Explanation"><a href="#Instance-Based-Explanation" class="headerlink" title="Instance Based Explanation"></a>Instance Based Explanation</h2><p>Instance based explanation is a particular type of explainable machine learning that focuses on explaining predictions through other observations. </p><h2 id="A-Global-View"><a href="#A-Global-View" class="headerlink" title="A Global View"></a>A Global View</h2><p>Each node represents a heterogenous set of leaves that are the model considers similar and each edge represents a relationship between nodes. </p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxewzcpkabj30jp0hkta6.jpg" alt="image-20181120223402308"></p><p>同一类的会较高概率聚在一起</p><h2 id="Local-Instances"><a href="#Local-Instances" class="headerlink" title="Local Instances"></a>Local Instances</h2><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxewzaiqz2j305u08vwfc.jpg" alt="image-20181120225031149"></p><p>This particular <em>Chestnut</em> was chosen for demonstration because, while the classification was correct, the confidence in prediction was not very large. </p><p>These three graphs show different levels of information about the instance. The first shows only the nodes that contain this particular <em>Chestnut</em>. The middle graph shows all nodes that contain any <em>Chestnut</em> leaves at all. The third graph shows the same region of <em>Chestnut</em> nodes, but also shows all of neighboring nodes, colored by their majority leaf type. The edges of the third graph are also colored based on the majority class comprising that edge.</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxex2p3vmjj30ni07wwf5.jpg" alt="image-20181120225347431"></p><h2 id="Escape-Routes"><a href="#Escape-Routes" class="headerlink" title="Escape Routes"></a>Escape Routes</h2><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxg0qkljzgj30gm0ecjry.jpg" alt="image-20181121214604224"></p><h2 id="Scaling-Up"><a href="#Scaling-Up" class="headerlink" title="Scaling Up"></a>Scaling Up</h2><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxg0u6wmmdj30p70ncguu.jpg" alt="image-20181121214934738"></p><p> MNIST data set</p><p>跟人判断的边界一样，模型在一些相似的物体上的界限会比较模糊</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxg14ouwzmj30r70q6grj.jpg" alt="image-20181121215346899"></p><p>边界点上的样子，可以看出是慢慢过渡的</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Using this representation, we can extract insights into what the model is thinking, where it gets confused.By connecting and compressing the input and output spaces of the model, we gain a keen understanding of the data and how the model interprets the data.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a><a href="https://sauln.github.io/blog/tda_explanations/" target="_blank" rel="noopener">https://sauln.github.io/blog/tda_explanations/</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode905按照奇偶顺序排列数组</title>
      <link href="/2018/11/12/leetcode905%E6%8C%89%E7%85%A7%E5%A5%87%E5%81%B6%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/"/>
      <url>/2018/11/12/leetcode905%E6%8C%89%E7%85%A7%E5%A5%87%E5%81%B6%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>按照奇偶顺序排列数组</p><a id="more"></a><p>这周跟一下刷题群的进度，第一个题就很简单了，两个思路，一个是分配新的空间，一个是直接在数组上修改</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fx5hrqj7nlj31d2086t9j.jpg" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># def sortArrayByParity(self, A):</span></span><br><span class="line">    <span class="comment">#     a = []</span></span><br><span class="line">    <span class="comment">#     b = []</span></span><br><span class="line">    <span class="comment">#     for i in A:</span></span><br><span class="line">    <span class="comment">#         if(i%2==0):</span></span><br><span class="line">    <span class="comment">#             a.append(i)</span></span><br><span class="line">    <span class="comment">#         else:</span></span><br><span class="line">    <span class="comment">#             b.append(i)</span></span><br><span class="line">    <span class="comment">#     return a+b</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArrayByParity</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=len(A)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j):</span><br><span class="line">            <span class="keyword">if</span>(A[i]%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">and</span> A[j]%<span class="number">2</span>==<span class="number">0</span>):</span><br><span class="line">                temp = A[i]</span><br><span class="line">                A[i] = A[j]</span><br><span class="line">                A[j] = temp</span><br><span class="line">            <span class="keyword">elif</span>(A[i]%<span class="number">2</span>==<span class="number">0</span>):</span><br><span class="line">                i=i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span>(A[j]%<span class="number">2</span>==<span class="number">1</span>):</span><br><span class="line">                j=j<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第一周简单递归总结</title>
      <link href="/2018/11/11/%E7%AC%AC%E4%B8%80%E5%91%A8%E7%AE%80%E5%8D%95%E9%80%92%E5%BD%92%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/11/%E7%AC%AC%E4%B8%80%E5%91%A8%E7%AE%80%E5%8D%95%E9%80%92%E5%BD%92%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>11.5-11.9第一周递归的刷题总结</p><a id="more"></a><p>这一周的一共做了五个题目都是可以用递归的思想去解答，也都是跟二叉树相关的题目</p><ol><li>二叉树的合并</li><li>二叉树的反转</li><li>找出二叉树中最长的路径</li><li>按层次输出二叉树的节点</li><li>判断一棵树是不是另一颗树的子树</li></ol><p>其中合并，反转都是简单的一个递归函数就可以解决</p><p>把问题分解成小的问题，然后每次解决掉这个小问题后继续递归左右子树</p><h2 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h2><p>最简单的是反转：</p><p><a href="http://cuteanian.top/2018/11/06/leetcode226%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/">http://cuteanian.top/2018/11/06/leetcode226%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</a></p><p>问题分解成每一个节点的左右节点的反转，然后再去递归这个节点的左右子树</p><p>遇到空就返回，然后依次返回直到回到最开始调用reverse的根节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self,t)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="keyword">None</span>):</span><br><span class="line">        t.left,t.right = t.right,t.left</span><br><span class="line">        self.reverse(t.left)</span><br><span class="line">        self.reverst(t.right)</span><br><span class="line">    <span class="keyword">return</span> t</span><br></pre></td></tr></table></figure><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p><a href="http://cuteanian.top/2018/11/05/leetcode617%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/">http://cuteanian.top/2018/11/05/leetcode617%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</a></p><p>合并的问题稍微有些复杂，但也是一个递归函数就可以解决，复杂点在于每一个小任务需要做的事情比反转要多</p><p>需要新生成一颗树，因为要返回的是一个合并后的树</p><p>每一次递归都会给这个新树增加新的节点，递归的最后依然会回到最开始调用merge的那个函数，返回第一次创建的mergeT</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self,t1,t2)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(t1==<span class="keyword">None</span>):</span><br><span class="line">        <span class="keyword">return</span> t2</span><br><span class="line">    <span class="keyword">if</span>(t2==<span class="keyword">None</span>):</span><br><span class="line">        <span class="keyword">return</span> t1</span><br><span class="line">    mergeT = TreeNone(t1.val+t2.val)</span><br><span class="line">    mergeT.left = self.merge(t1.left,t2.left)</span><br><span class="line">    mergeT.right = self.mergt(t1.right,t2.right)</span><br><span class="line">    <span class="keyword">return</span> mergeT</span><br></pre></td></tr></table></figure><h2 id="找出二叉树中最长的路径"><a href="#找出二叉树中最长的路径" class="headerlink" title="找出二叉树中最长的路径"></a>找出二叉树中最长的路径</h2><p><a href="http://cuteanian.top/2018/11/07/leetcode543%E6%89%BE%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E8%B7%AF%E5%BE%84/">http://cuteanian.top/2018/11/07/leetcode543%E6%89%BE%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E8%B7%AF%E5%BE%84/</a></p><p>首先可以考虑一个简单的题目，找出二叉树的深度</p><p>非常简单基础的递归思路</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDeep</span><span class="params">(self,t)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(t==<span class="keyword">None</span>):</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+max(self.findDeep(t.left),self.findDeep(t.right))</span><br></pre></td></tr></table></figure><p>找出二叉树中最长的路径不是像深度一样可以简单的遍历，只需要判断单边的最大即可</p><p>通过观察可以发现，最长路径一定有一个转折点，最长路径=转折点左子树深度+转折点右子树深度</p><p>一个简单的想法就是递归每一个节点，计算他们作为转折点时的路径长度，然后返回最长的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    max = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        self.findMax(root)</span><br><span class="line">        <span class="keyword">return</span> self.max</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMax</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">None</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = self.findMax(node.left)</span><br><span class="line">            r = self.findMax(node.right)</span><br><span class="line">            <span class="keyword">if</span>(l+r&gt;self.max):</span><br><span class="line">                self.max = l+r</span><br><span class="line">            <span class="keyword">return</span> max(l,r)+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>为什么一个递归函数不能解决问题：</p><p>这个问题划分为小问题的时候有三步:</p><ol><li>计算当前节点的左右子树的最大深度</li><li>判断左+右是否比当前保存的值要大，大的话更新</li><li>最后返回max</li></ol><p>在第一步计算深度的时候，我们需要函数的返回值是该节点左右子树的深度，这与题目最后需要返回的max冲突，所以需要另外开辟一个递归函数，让这个函数去更新max的值，最后由主函数去返回max的值。</p><p>当然也可以在主函数中返回左右子树的深度，但是这样就没有地方去返回max，在函数中输出max可以看到最后max的值就是我们想要得到的结果，思想都是一样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">None</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l = self.diameterOfBinaryTree(root.left)</span><br><span class="line">        r = self.diameterOfBinaryTree(root.right)</span><br><span class="line">        self.max = max(self.max,l+r)</span><br><span class="line">        print(self.max)</span><br><span class="line">        <span class="keyword">return</span> max(l,r)+<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="按层次输出二叉树的节点"><a href="#按层次输出二叉树的节点" class="headerlink" title="按层次输出二叉树的节点"></a>按层次输出二叉树的节点</h2><p><a href="http://cuteanian.top/2018/11/08/leetcode102%E6%8C%89%E5%B1%82%E6%AC%A1%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9/">http://cuteanian.top/2018/11/08/leetcode102%E6%8C%89%E5%B1%82%E6%AC%A1%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9/</a></p><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>这个题目第一感受是可以用BFS，但是问题在于用BFS反而难判断每一层的结束在哪儿</p><p>用DFS更容易去保存深度</p><p>如果当前结果数组的长度小于该节点的深度，则新加入一个数组并把当前值push进去</p><p>否则就可以直接把当前值push进去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    result=[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        self.result=[]</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">None</span>):</span><br><span class="line">            self.DFS(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(self,node,depth)</span>:</span></span><br><span class="line">         <span class="keyword">if</span>(node!=<span class="keyword">None</span>):</span><br><span class="line">            print(node.val,depth)</span><br><span class="line">            <span class="keyword">if</span>(len(self.result)&lt;depth+<span class="number">1</span>):  <span class="comment"># 如果result没有当前节点层次的数组就新建并且添加当前值</span></span><br><span class="line">                self.result.append([node.val])</span><br><span class="line">            <span class="keyword">else</span>:                          <span class="comment">#如果有就直接添加当前值</span></span><br><span class="line">                self.result[depth].append(node.val)</span><br><span class="line">            self.DFS(node.left,depth+<span class="number">1</span>)</span><br><span class="line">            self.DFS(node.right,depth+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p>BFS需要保存两个队列，一个是传统用于BFS遍历的队列，当这个队列为空时遍历结束。</p><p>传统BFS更新时是每出队一个节点，就把该节点的左右孩子加入到队列中</p><p>这个题目更新时思路是：</p><ol><li>每次出队的是一个层次的所有节点，然后把这一个层次的所有节点的左右孩子（下个层次的所有节点）加入到队列中。</li><li>用一个新的队列nextqueue来保存下个层次的所有节点，也用这个新的队列去更新queue</li><li>queue中始终保存的是当前层次的所有节点</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        queue = []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">None</span>):</span><br><span class="line">            queue.append(root)</span><br><span class="line">        <span class="keyword">while</span>(queue):          <span class="comment">#当总队列为空时结束</span></span><br><span class="line">            nextqueue = []</span><br><span class="line">            thislevelval = []</span><br><span class="line">         <span class="comment">#遍历当前层次的所有节点，把当前层次的节点的值写入数组，把下一层次的所有节点加入到nextqueue中</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue: </span><br><span class="line">                thislevelval.append(node.val)</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">None</span>):</span><br><span class="line">                    nextqueue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">None</span>):</span><br><span class="line">                    nextqueue.append(node.right)</span><br><span class="line">            <span class="comment"># 用下一层次的节点替换当queue并继续遍历</span></span><br><span class="line">            queue = nextqueue</span><br><span class="line">            <span class="comment"># 当前层次值数组加入到结果数组中</span></span><br><span class="line">            result.append(thislevelval)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="判断一颗树是不是另一颗树的子树"><a href="#判断一颗树是不是另一颗树的子树" class="headerlink" title="判断一颗树是不是另一颗树的子树"></a>判断一颗树是不是另一颗树的子树</h2><p><a href="http://cuteanian.top/2018/11/09/572%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%A6%E4%B8%80%E9%A2%97%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/">http://cuteanian.top/2018/11/09/572%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%A6%E4%B8%80%E9%A2%97%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/</a></p><p>子树的概念必须是从s的一个节点开始下面所有的节点都和t相等，也就是从s的这个节点开始和t完全一致</p><p>这样就可以借助判断两个二叉树是否相等的思想来解答了</p><ol><li>依次判断s的节点，看从该节点开始是否和t相等</li><li>如果相等则返回true，不相等则继续递归s</li><li>直至返回true，或者s==None返回false。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(Object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubtree</span><span class="params">(self,s,t)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">None</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span>(self.isSametree(s,t)):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.isSubtree(s.left,t) <span class="keyword">or</span> self.isSubstree(s.right,t))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self,s,t)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> s <span class="keyword">and</span> <span class="keyword">not</span> t):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span>(<span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> t):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">elif</span>(s.val!=t.val):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isSameTree(s.left,r.left) <span class="keyword">and</span> self.isSametree(s.right,r.right)</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 递归 </category>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode572判断一棵树是不是另一颗树的子树</title>
      <link href="/2018/11/09/572%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%A6%E4%B8%80%E9%A2%97%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/"/>
      <url>/2018/11/09/572%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%A6%E4%B8%80%E9%A2%97%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>判断一棵树是不是另一颗树的子树</p><a id="more"></a><h2 id="572-Subtree-of-Another-Tree"><a href="#572-Subtree-of-Another-Tree" class="headerlink" title="572. Subtree of Another Tree"></a>572. Subtree of Another Tree</h2><p>Given two non-empty binary trees <strong>s</strong> and <strong>t</strong>, check whether tree <strong>t</strong> has exactly the same structure and node values with a subtree of <strong>s</strong>. A subtree of <strong>s</strong> is a tree consists of a node in <strong>s</strong> and all of this node’s descendants. The tree <strong>s</strong> could also be considered as a subtree of itself.</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fx1vpyz5mij31ck0icdh5.jpg" alt="img"></p><p><img src="/var/folders/6p/_f33fscs7j316s490d30bm6c0000gn/T/abnerworks.Typora/image-20181109161600432.png" alt="img"></p><p>最开始的想法是先序后者其他序遍历然后保存字符串进行比较看t是否是s的子字符串，但是这种想法不符合示例2</p><p>子树的概念必须是从s的一个节点开始下面所有的节点都和t相等，也就是从s的这个节点开始和t完全一致</p><p>这样就可以借助判断两个二叉树是否相等的思想来解答了</p><ol><li><p>依次判断s的节点，看从该节点开始是否和t相等</p></li><li><p>如果相等则返回true，不相等则继续递归s</p></li><li><p>直至返回true，或者s==None返回false。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubtree</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">None</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span>(self.isSametree(s,t)):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span>(self.isSubtree(s.left,t) <span class="keyword">or</span> self.isSubtree(s.right,t))</span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSametree</span><span class="params">(self,s,t)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> s <span class="keyword">and</span> <span class="keyword">not</span> t):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span>(<span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> t):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">elif</span>(s.val!=t.val):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isSametree(s.left,t.left) <span class="keyword">and</span> self.isSametree(s.right,t.right)</span><br></pre></td></tr></table></figure><p>但是参考资料有一个字符串的解法，还没搞懂思路，周末回来再看一下~</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="http://www.cnblogs.com/grandyang/p/6828687.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/6828687.html</a></li><li><a href=""></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 递归 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue基础二</title>
      <link href="/2018/11/09/vue%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
      <url>/2018/11/09/vue%E5%9F%BA%E7%A1%80%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>Vue基础（二） 计算属性和侦听器、Class与Style绑定</p><a id="more"></a><h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>对于简单运算，可以使用模板内的表达式，但是对于复杂逻辑，应该使用计算属性</p><p>简单例子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "&#123;&#123; message &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里reversedMessage是一个计算属性。提供的函数被用作属性vm.reversedMessage的getter函数，每次使用reversedMessage函数时都会调用这个getter函数并得到返回值。</p><p>### </p><h3 id="计算属性缓存vs方法"><a href="#计算属性缓存vs方法" class="headerlink" title="计算属性缓存vs方法"></a>计算属性缓存vs方法</h3><p>其实可以在表达式中来调用方法得到同样的效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Reversed message:"&#123;&#123;reversedMessage()&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    reversedMessage:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这个例子而言，两者的结果完全相同</p><p>不同的是，计算属性是基于他们的依赖来进行缓存，也就是说如果message没有发生改变，多次访问reversedMessage会立即返回之前计算的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个计算属性并不会随时间更新</span></span><br><span class="line">computed:&#123;</span><br><span class="line">    now:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Date</span>.now()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比之下，每次触发重新渲染时，调用的方法总会再次执行函数。</p><p>### </p><h3 id="计算属性vs侦听属性"><a href="#计算属性vs侦听属性" class="headerlink" title="计算属性vs侦听属性"></a>计算属性vs侦听属性</h3><p>vue提供了一个侦听属性来观察并且响应vue实例上的数据变化。</p><p>但当有一些数据需要随着其他数据的变化而变化时，用计算属性会比用侦听属性要好</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>watch:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    lastName: <span class="string">'Bar'</span>,</span><br><span class="line">    fullName: <span class="string">'Foo Bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = val + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = <span class="keyword">this</span>.firstName + <span class="string">' '</span> + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>computed：</p><p>计算属性依赖于原数据，所以当原数据改变时，计算属性的绑定也会更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    lastName: <span class="string">'Bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p>计算属性在大多数场合下都适用，但是当数据变化时执行异步或开销较大的操作时，还是需要用到更通用的侦听器</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"watch-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"question"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span><br><span class="line">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#watch-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    question: <span class="string">''</span>,</span><br><span class="line">    answer: <span class="string">'I cannot give you an answer until you ask a question!'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span><br><span class="line">    question: <span class="function"><span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.answer = <span class="string">'Waiting for you to stop typing...'</span></span><br><span class="line">      <span class="keyword">this</span>.debouncedGetAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span><br><span class="line">    <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span><br><span class="line">    <span class="comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span><br><span class="line">    <span class="comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span></span><br><span class="line">    <span class="comment">// 请参考：https://lodash.com/docs#debounce</span></span><br><span class="line">    <span class="keyword">this</span>.debouncedGetAnswer = _.debounce(<span class="keyword">this</span>.getAnswer, <span class="number">500</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getAnswer: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.question.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.answer = <span class="string">'Questions usually contain a question mark. ;-)'</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.answer = <span class="string">'Thinking...'</span></span><br><span class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span></span><br><span class="line">      axios.get(<span class="string">'https://yesno.wtf/api'</span>)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">          vm.answer = _.capitalize(response.data.answer)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">          vm.answer = <span class="string">'Error! Could not reach the API. '</span> + error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Class与Style绑定"><a href="#Class与Style绑定" class="headerlink" title="Class与Style绑定"></a>Class与Style绑定</h2><p>class和内联样式都是属性，所以可以用v-bind来处理，只需要通过表达式计算出字符串结果即可。</p><p>但是字符串拼接麻烦而且容易出错，所以vue.js做了增强。表达式的结果除了是字符串以外，还可以是对象或者数组</p><h3 id="绑定HTML-CLASS"><a href="#绑定HTML-CLASS" class="headerlink" title="绑定HTML CLASS"></a>绑定HTML CLASS</h3><h4 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h4><p>可以给v-bind:class传递一个对象，动态切换class</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123;active:isActive&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表示active这个属性的存在由isActice的真假决定</p><p>v-bind:class指令可以与普通的class属性共存</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  hasError: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果会被渲染为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static,active"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当isActive或者hasError变化时，class列表也会相应地更新。</p><p>绑定的数据对象不必放在模板里，可以直接在模板中放入对象名称，然后定义在数据中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"classObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'text-danger'</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用计算属性模式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"classObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="keyword">this</span>.isActive &amp;&amp; !<span class="keyword">this</span>.error,</span><br><span class="line">      <span class="string">'text-danger'</span>: <span class="keyword">this</span>.error &amp;&amp; <span class="keyword">this</span>.error.type === <span class="string">'fatal'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h4><p>也可以把一个数组传给v-bind:class指令</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[activeClass, errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  activeClass: <span class="string">'active'</span>,</span><br><span class="line">  errorClass: <span class="string">'text-danger'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被渲染为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'active,text-danger'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以在数组语法中使用对象语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[&#123; active: isActive &#125;, errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="用在组件上-看完组件回来补充"><a href="#用在组件上-看完组件回来补充" class="headerlink" title="用在组件上(看完组件回来补充)"></a>用在组件上(看完组件回来补充)</h4><h3 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h3><h4 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a>对象语法</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"styleObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: <span class="string">'red'</span>,</span><br><span class="line">    fontSize: <span class="string">'13px'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h4><p>数组语法可以将多个样式对象应用到同一个元素上:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"[baseStyles, overridingStyles]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://cn.vuejs.org/v2/guide/computed.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/computed.html</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode102按层次输出二叉树的节点</title>
      <link href="/2018/11/08/leetcode102%E6%8C%89%E5%B1%82%E6%AC%A1%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>/2018/11/08/leetcode102%E6%8C%89%E5%B1%82%E6%AC%A1%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>按层次数出二叉树的节点</p><a id="more"></a><h1 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h1><p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p><p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fx0syv8ql8j31cm0g6wfe.jpg" alt="img"></p><p>思路：二叉树的遍历问题，BFS和DFS都可以解决，直观感受好像是BFS更加符合要求，但是题目要求按层次输出，不是简单的直接输出层次遍历的结果，反而是DFS更加容易保留层次，然后根据层次进行判断并写入数组，时间复杂度都是o(n)</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>按照DFS进行二叉树的遍历，多传入一个参数用于保存当前节点的层次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    result=[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        self.result=[]</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">None</span>):</span><br><span class="line">            self.DFS(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(self,node,depth)</span>:</span></span><br><span class="line">         <span class="keyword">if</span>(node!=<span class="keyword">None</span>):</span><br><span class="line">            print(node.val,depth)</span><br><span class="line">            <span class="keyword">if</span>(len(self.result)&lt;depth+<span class="number">1</span>):  <span class="comment"># 如果result没有当前节点层次的数组就新建并且添加当前值</span></span><br><span class="line">                self.result.append([node.val])</span><br><span class="line">            <span class="keyword">else</span>:                          <span class="comment">#如果有就直接添加当前值</span></span><br><span class="line">                self.result[depth].append(node.val)</span><br><span class="line">            self.DFS(node.left,depth+<span class="number">1</span>)</span><br><span class="line">            self.DFS(node.right,depth+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>BFS需要保存两个队列，一个是传统用于BFS遍历的队列，当这个队列为空时遍历结束。</p><p>传统BFS更新时是每出队一个节点，就把该节点的左右孩子加入到队列中</p><p>这个题目更新时思路是：</p><ol><li>每次出队的是一个层次的所有节点，然后把这一个层次的所有节点的左右孩子（下个层次的所有节点）加入到队列中。</li><li>用一个新的队列nextqueue来保存下个层次的所有节点，也用这个新的队列去更新queue</li><li>queue中始终保存的是当前层次的所有节点</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        queue = []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">None</span>):</span><br><span class="line">            queue.append(root)</span><br><span class="line">        <span class="keyword">while</span>(queue):          <span class="comment">#当总队列为空时结束</span></span><br><span class="line">            nextqueue = []</span><br><span class="line">            thislevelval = []</span><br><span class="line">         <span class="comment">#遍历当前层次的所有节点，把当前层次的节点的值写入数组，把下一层次的所有节点加入到nextqueue中</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue: </span><br><span class="line">                thislevelval.append(node.val)</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">None</span>):</span><br><span class="line">                    nextqueue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">None</span>):</span><br><span class="line">                    nextqueue.append(node.right)</span><br><span class="line">            <span class="comment"># 用下一层次的节点替换当queue并继续遍历</span></span><br><span class="line">            queue = nextqueue</span><br><span class="line">            <span class="comment"># 当前层次值数组加入到结果数组中</span></span><br><span class="line">            result.append(thislevelval)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> BFS </category>
          
          <category> DFS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue基础一</title>
      <link href="/2018/11/08/vue%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
      <url>/2018/11/08/vue%E5%9F%BA%E7%A1%80%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>vue基础(一) 实例，语法</p><a id="more"></a><h2 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h2><h3 id="创建一个实例"><a href="#创建一个实例" class="headerlink" title="创建一个实例"></a>创建一个实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">//选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>每个vue应用都是从一个vue实例开始</p><p>创建一个 Vue 实例时，传入一个**选项对象，使用这些选项来创建想要的行为。</p><p>一个 Vue 应用由一个通过 <code>new Vue</code> 创建的<strong>根 Vue 实例</strong>，以及可选的嵌套的、可复用的组件树组成。举个例子，一个 todo 应用的组件树可以是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">根实例</span><br><span class="line">└─ TodoList</span><br><span class="line">   ├─ TodoItem</span><br><span class="line">   │  ├─ DeleteTodoButton</span><br><span class="line">   │  └─ EditTodoButton</span><br><span class="line">   └─ TodoListFooter</span><br><span class="line">      ├─ ClearTodosButton</span><br><span class="line">      └─ TodoListStatistics</span><br></pre></td></tr></table></figure><h3 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h3><p>当一个 Vue 实例被创建时，它向 Vue 的<strong>响应式系统</strong>中加入了其 <code>data</code> 对象中能找到的所有的属性。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p><p>MVVM中的双向数据绑定</p><p>注意：</p><ol><li><p>只有当实例被创建时 <code>data</code> 中存在的属性才是<strong>响应式</strong>的，后面添加的新属性的改动并不能引起视图的更新</p></li><li><p>使用 <code>Object.freeze()</code>，这会阻止修改现有的属性，也意味着响应系统无法再追踪变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">'bar'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: obj</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>data是vue实例的一个数据属性，除此之外,vue实例还暴露了一些有用的实力属性和方法，他们都有前缀$，以便与用户定义的属性区分开。</p><p>查看API:<a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">vue实例&amp;属性</a></p><h3 id="实例生命周期钩子"><a href="#实例生命周期钩子" class="headerlink" title="实例生命周期钩子"></a>实例生命周期钩子</h3><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="img"></p><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。</p><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><p>文本插值的绑定形势是用双大括号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br></pre></td></tr></table></figure><p>双大括号便签会被替代为所绑定的数据对象上msg的值，如果绑定对象上的msg属性值发生了变化，插值处的内容也会更新</p><h4 id="原始html"><a href="#原始html" class="headerlink" title="原始html"></a>原始html</h4><p>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 <code>v-html</code> 指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">"rawHtml"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fx0ukbvqs5j30fc03e0sy.jpg" alt="img"></p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>双大括号语法不能用在html特性上，需要用到v-bind指令:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"dynamicId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在布尔特性的情况下，它们的存在即暗示为 <code>true</code>，<code>v-bind</code> 工作起来略有不同，在这个例子中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:disabled</span>=<span class="string">"isButtonDisabled"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果 <code>isButtonDisabled</code> 的值是 <code>null</code>、<code>undefined</code> 或 <code>false</code>，则 <code>disabled</code> 特性甚至不会被包含在渲染出来的 <code>&lt;button&gt;</code> 元素中。</p><h4 id="使用JS表达式"><a href="#使用JS表达式" class="headerlink" title="使用JS表达式"></a>使用JS表达式</h4><p>对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。</p><p>每个绑定都只能包含<strong>单个表达式</strong>，流程控制（if）不会生效，需要使用三元表达式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"'list-' + id"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>指令 (Directives) 是带有 <code>v-</code> 前缀的特殊特性。指令特性的值是<strong>单个 JavaScript 表达式</strong>。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-<span class="keyword">if</span>=<span class="string">"seen"</span>&gt;Now you see me&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure><p>这里，<code>v-if</code> 指令将根据表达式 <code>seen</code> 的值的真假来插入/移除 <code>&lt;p&gt;</code> 元素。</p><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>一个指令可以接收一个”参数”，在指令名称之后以冒号表示。</p><p>v-bind指令可以用于响应式地更新HTML特性:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>href是参数，告知v-bind指令把该元素的href特性与表达式的url的值绑定</p><p>v-on指令，用于监听DOM事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>click是参数，是监听的事件名（点击事件）,给点击事件绑定回调函数doSomething</p><h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><p>修饰符 (Modifiers) 是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，<code>.prevent</code> 修饰符告诉 <code>v-on</code> 指令对于触发的事件调用 <code>event.preventDefault()</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h4><p>v-bind的缩写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-on的缩写:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a><a href="https://cn.vuejs.org/v2/guide/instance.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/instance.html</a></li><li></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode543找出二叉树中最长的路径</title>
      <link href="/2018/11/07/leetcode543%E6%89%BE%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2018/11/07/leetcode543%E6%89%BE%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>找出二叉树中最长的路径</p><a id="more"></a><p>是之前做过一个题的升级版，上次刷还没搭好博客笔记也不见了就重新整理一下</p><p>###104题，找出二叉树的深度</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwzu7mf1mjj30me0au74v.jpg" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">None</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + max(self.maxDepth(root.left),self.maxDepth(root.right))</span><br></pre></td></tr></table></figure><p>思路：还是递归的想法，分别递归左子树和右子树然后返回两者的最大值</p><h3 id="543-Diameter-of-Binary-Tree"><a href="#543-Diameter-of-Binary-Tree" class="headerlink" title="543. Diameter of Binary Tree"></a>543. Diameter of Binary Tree</h3><p>找出二叉树中的最长路径，稍微复杂一点，不是单边的最大值，而是两者相加的最大值 </p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwzuahe17zj31cc0daq4f.jpg" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    max = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        self.findMax(root)</span><br><span class="line">        <span class="keyword">return</span> self.max</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMax</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">None</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = self.findMax(node.left)</span><br><span class="line">            r = self.findMax(node.right)</span><br><span class="line">            <span class="keyword">if</span>(l+r&gt;self.max):</span><br><span class="line">                self.max = l+r</span><br><span class="line">            <span class="keyword">return</span> max(l,r)+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>思路：</p><p>因为需要保存一个最大值用来返回，所以一个函数不能解决，需要写一个寻找最大值的递归函数findMax()</p><p>每递归一个节点，先判断他的左和右的和是否大于max，如果是则更新max，然后返回左右的最大值。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a><a href="https://kingsfish.github.io/2017/07/13/Leetcode-543-Diameter-of-Binary-Tree/" target="_blank" rel="noopener">https://kingsfish.github.io/2017/07/13/Leetcode-543-Diameter-of-Binary-Tree/</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 递归 </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>a_simple_and_accurate_method_to_fool_deep_neural_networks</title>
      <link href="/2018/11/07/a-simple-and-accurate-method-to-fool-deep-neural-networks/"/>
      <url>/2018/11/07/a-simple-and-accurate-method-to-fool-deep-neural-networks/</url>
      
        <content type="html"><![CDATA[<p>一种攻击深度神经网络的方法</p><a id="more"></a><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p><strong>main idea:</strong>propose the DeepFool algorithm to efficiently compute perturbations that fool deep networks, and thus reliably quantify the robustness of these classifiers. </p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Define an adversarial perturbation as the minimal perturbation r that is sufficient to change the estimated label $k(x)$:</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwzrenyb1aj30bz01ejrh.jpg" alt="img"></p><p>We call ∆(x; k) the robustness of k at point x. The robustness of classifier k is then defined as:</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwzrfmm6igj306t01oglm.jpg" alt="img"></p><p>The study of adversarial perturbations helps us understand what features are used by a classifier.</p><h2 id="DeepFool"><a href="#DeepFool" class="headerlink" title="DeepFool"></a>DeepFool</h2><p>the algorithm perturbs the image by a small vector that is computed to take the resulting image to the boundary of the polyhydron that is obtained by linearizing the boundaries of the region within which the image resides. The perturbations added to the image in each iteration are accumulated to compute the final perturbation once the perturbed image changes its label according to the original decision boundaries of the network.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p> DeepFool is based on an iterative linearization of the classifier to generate minimal perturbations that are sufficient to change classification labels.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li>DeepFool: a simple and accurate method to fool deep neural networks</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode226反转二叉树</title>
      <link href="/2018/11/06/leetcode226%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/11/06/leetcode226%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>Invert Binary Tree</p><a id="more"></a><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwypqvxn6pj31cw0lkjsk.jpg" alt="img"></p><p>思路：</p><p>跟昨天的题一样都是很简单的递归思路，有进步的地方就是这次没有去看别人的代码啦hhhh</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">None</span>):</span><br><span class="line">            root.left,root.right = root.right,root.left</span><br><span class="line">            self.invertTree(root.left)</span><br><span class="line">            self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>代码是很简洁的三行，如果节点不为空先交换，然后再依次递归左子树和右子树</p><p>但是在写的过程中对于递归返回值理解不对，以为返回了这个函数就结束了，不知道该在哪里返回root，摸索中AC了。</p><p>递归的返回值应该是依次往上返回，最后一个返回空之后会回到上一个调用他的函数体中，然后返回这个节点，依次往上返回，最后回到最初调用的函数中，然后返回根节点root。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwypz9t4g6j30yq0f0teq.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 递归 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue基础(三)  条件渲染、列表渲染</title>
      <link href="/2018/11/05/vue%E5%9F%BA%E7%A1%80%E4%B8%89/"/>
      <url>/2018/11/05/vue%E5%9F%BA%E7%A1%80%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>vue基础(三)  条件渲染、列表渲染</p><a id="more"></a><p>[TOC]</p><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><h3 id="v-if-指令"><a href="#v-if-指令" class="headerlink" title="v-if 指令"></a>v-if 指令</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>No<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#app"</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        ok:<span class="literal">true</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>会根据vue模板中ok的真假来决定是否渲染</p><p>如果想控制多个元素，可以把一个template元素当做不可见的包裹元素，并在上面使用v-if</p><p>最终这个template元素不会被渲染</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">'ok'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-else-v-else-if"><a href="#v-else-v-else-if" class="headerlink" title="v-else v-else-if"></a>v-else v-else-if</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"Math.random() &gt; 0.5"</span>&gt;</span></span><br><span class="line">  Now you see me</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Now you don't</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"type === 'A'"</span>&gt;</span></span><br><span class="line">  A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'B'"</span>&gt;</span></span><br><span class="line">  B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'C'"</span>&gt;</span></span><br><span class="line">  C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-else必须紧跟v-if</p><p>v-else-if必须紧跟v-if或者v-if-else</p><h3 id="key管理可复用的元素"><a href="#key管理可复用的元素" class="headerlink" title="key管理可复用的元素"></a>key管理可复用的元素</h3><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中的两个input，第二个不会被替换，而是复用上面的input</p><p>这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 <code>key</code> 属性即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span> <span class="attr">key</span>=<span class="string">"username-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span> <span class="attr">key</span>=<span class="string">"email-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-show指令"><a href="#v-show指令" class="headerlink" title="v-show指令"></a>v-show指令</h3><p>v-show只是简单地切换元素的css属性display，元素会被渲染并始终留在dom中</p><p>v-if只有在值为真时才会渲染</p><p>因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><h3 id="v-for指令把一个数组对应成一组元素"><a href="#v-for指令把一个数组对应成一组元素" class="headerlink" title="v-for指令把一个数组对应成一组元素"></a>v-for指令把一个数组对应成一组元素</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">        &#123;&#123;item.message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#example-1'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        item[</span><br><span class="line">        &#123;<span class="attr">message</span>:<span class="string">'Foo'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">message</span>:<span class="string">'Bar'</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果:</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fx7wzq55dmj308f01ywec.jpg" alt="image-20181114213159185"></p><h4 id="v-for的两点性质"><a href="#v-for的两点性质" class="headerlink" title="v-for的两点性质"></a>v-for的两点性质</h4><ol><li>v-for块中对父作用域属性有完全访问权限</li><li>v-for支持一个可选的参数作为当前项的索引</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item,index in items"</span>&gt;</span></span><br><span class="line">        &#123;&#123;parentMessage&#125;&#125; - &#123;&#123;index&#125;&#125; - &#123;&#123;item.message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#example-2'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        parentMessage:<span class="string">'Parent'</span>,</span><br><span class="line">        item:[</span><br><span class="line">            &#123;<span class="attr">message</span>:<span class="string">'Foo'</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">message</span>:<span class="string">'Bar'</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fx7x4w7c66j306p026gli.jpg" alt="image-20181114213655409"></p><h3 id="v-for迭代对象"><a href="#v-for迭代对象" class="headerlink" title="v-for迭代对象"></a>v-for迭代对象</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-3"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">'(value,key,index) in object'</span>&gt;</span></span><br><span class="line">        &#123;&#123;index&#125;&#125;. &#123;&#123;key&#125;&#125; : &#123;&#123;value&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example3 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#example-3"</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        object:&#123;</span><br><span class="line">            firstName:<span class="string">'John'</span>,</span><br><span class="line">            lastName:<span class="string">'Doe'</span>,</span><br><span class="line">            age:<span class="number">30</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>result:</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fx7x98l3dtj305g02it8o.jpg" alt="image-20181114214107166"></p><h3 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h3><h4 id="变异方法"><a href="#变异方法" class="headerlink" title="变异方法"></a>变异方法</h4><p>Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：</p><ul><li><code>push()</code></li><li><code>pop()</code></li><li><code>shift()</code></li><li><code>unshift()</code></li><li><code>splice()</code></li><li><code>sort()</code></li><li><code>reverse()</code></li></ul><h4 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h4><p>可以用新数组去替换旧数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filter方法会返回一个符合条件的新数组</span></span><br><span class="line">example1.items = example1.items.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.message.match(<span class="regexp">/Foo/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p><strong>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：</strong></p><ol><li>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ol><p>如果要实现<code>vm.items[indexOfItem] = newValue</code>的效果并且触发状态更新，可以使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.items,indexOfItem,newValue)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.items.splice(indexOfItem,1,newValue)</span><br></pre></td></tr></table></figure><p>实现<code>vm.items.length = newLength</code>并触发更新:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure><p><strong>由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// `vm.a` 现在是响应式的</span></span><br><span class="line"></span><br><span class="line">vm.b = <span class="number">2</span></span><br><span class="line"><span class="comment">// `vm.b` 不是响应式的</span></span><br></pre></td></tr></table></figure><p>对于已经创建的实例，vue不能添加根级别的响应性属性，但是可以使用<code>Vue.set(object, key, value)</code> 方法向嵌套对象添加响应式属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    userProfile: &#123;</span><br><span class="line">      name: <span class="string">'Anika'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.set(vm.userProfile,<span class="string">'age'</span>,<span class="number">27</span>)</span><br></pre></td></tr></table></figure><p>如果需要<strong>为已有属性赋予多个属性</strong>，使用Object.assign()，应该用两个对象的属性去创建一个新的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm.userProfile = <span class="built_in">Object</span>.assign(&#123;&#125;,vm.userProfile,&#123;</span><br><span class="line">    age:<span class="number">27</span>,</span><br><span class="line">    favoriteColor:<span class="string">'Vue Green'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="显示过滤-排序结果"><a href="#显示过滤-排序结果" class="headerlink" title="显示过滤/排序结果"></a>显示过滤/排序结果</h3><p>显示数组的某些结果但是不想改变原数组，有两种方法</p><p>计算属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in evenNumbers"</span>&gt;</span></span><br><span class="line">    &#123;&#123;n&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#id'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        numbers:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">        evenNumbers:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.numbers.fliter(<span class="function"><span class="keyword">function</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> number%<span class="number">2</span> === <span class="number">0</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>method方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in even(numbers)"</span>&gt;</span></span><br><span class="line">    &#123;&#123;n&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#id'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        numbers:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    method:<span class="function"><span class="keyword">function</span>(<span class="params">numbers</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> number%<span class="number">2</span>===<span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="利用v-for-template一次渲染多个元素"><a href="#利用v-for-template一次渲染多个元素" class="headerlink" title="利用v-for template一次渲染多个元素"></a>利用v-for template一次渲染多个元素</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">'item in items'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;item.message&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'divider'</span> <span class="attr">role</span>=<span class="string">'presentation'</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-for-v-if同用"><a href="#v-for-v-if同用" class="headerlink" title="v-for v-if同用"></a>v-for v-if同用</h3><p>如果他们位于同一个节点中，v-for比v-if有更高的优先级，也就是说v-if会在每一个循环中运行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-if</span>=<span class="string">"item.isTrue"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 会渲染所有item.isTrue为真的元素 --&gt;</span></span><br></pre></td></tr></table></figure><p>如果只是想有条件的跳过循环，需要将v-if放在外层元素上面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">"todos.length"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No todos left!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件的v-for-（看完组件后更新）"><a href="#组件的v-for-（看完组件后更新）" class="headerlink" title="组件的v-for  （看完组件后更新）"></a>组件的v-for  （看完组件后更新）</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://cn.vuejs.org/v2/guide/conditional.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/conditional.html</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode617合并二叉树</title>
      <link href="/2018/11/05/leetcode617%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/11/05/leetcode617%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>617 合并二叉树</p><a id="more"></a><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p><p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fx4emkjlqdj31b00f0dgq.jpg" alt="image-20181105204933002"></p><p>解法就是用到了递归的思想，感觉还是搞不懂递归怎么用，这周多做几个递归的题目这周末整理一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span><span class="params">(self, t1, t2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="keyword">None</span>):</span><br><span class="line">            <span class="keyword">return</span> t2</span><br><span class="line">        <span class="keyword">if</span>(t2==<span class="keyword">None</span>):</span><br><span class="line">            <span class="keyword">return</span> t1</span><br><span class="line">        mergeT = TreeNode(t1.val+t2.val)</span><br><span class="line">        mergeT.left = self.mergeTrees(t1.left,t2.left)</span><br><span class="line">        mergeT.right = self.mergeTrees(t1.right,t2.right)</span><br><span class="line">        <span class="keyword">return</span> mergeT</span><br></pre></td></tr></table></figure><p>代码很简单，根据t1和t2的根节点创建新的二叉树的根节点</p><p>然后去分别合并左子树和右子树，最后返回</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.youtube.com/watch?v=EmVsf2sMNiU" target="_blank" rel="noopener">https://www.youtube.com/watch?v=EmVsf2sMNiU</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 递归 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode438找出同字母异序词</title>
      <link href="/2018/11/02/leetcode438%E6%89%BE%E5%87%BA%E5%90%8C%E5%AD%97%E6%AF%8D%E5%BC%82%E5%BA%8F%E8%AF%8D/"/>
      <url>/2018/11/02/leetcode438%E6%89%BE%E5%87%BA%E5%90%8C%E5%AD%97%E6%AF%8D%E5%BC%82%E5%BA%8F%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>找出一个字符串中另一个字符串的同字母异序词</p><a id="more"></a><p>Given a string <strong>s</strong> and a <strong>non-empty</strong> string <strong>p</strong>, find all the start indices of <strong>p</strong>‘s anagrams in <strong>s</strong>.</p><p>Strings consists of lowercase English letters only and the length of both strings <strong>s</strong> and <strong>p</strong> will not be larger than 20,100.</p><p>The order of output does not matter.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.</span><br><span class="line">The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力-o-n-2"><a href="#暴力-o-n-2" class="headerlink" title="暴力 ($(o(n^2))$)"></a>暴力 ($(o(n^2))$)</h4><p>能想到的就是最简单的思路，字符串转list，然后切片，排序，比较</p><p>但是超时了，先把代码贴上</p><p>但是也不知道是不是自己哪里写的不对&gt;&lt;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        s=list(s)</span><br><span class="line">        p=list(p)</span><br><span class="line">        p.sort()</span><br><span class="line">        result=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            print(i)</span><br><span class="line">            <span class="keyword">if</span>(s[i] <span class="keyword">in</span> p <span class="keyword">and</span> i+len(p)&lt;=len(s)):</span><br><span class="line">                c = s[i:i+len(p)]</span><br><span class="line">                c.sort()</span><br><span class="line">                <span class="keyword">if</span>(c == p):</span><br><span class="line">                    result.append(i)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><img src="/var/folders/6p/_f33fscs7j316s490d30bm6c0000gn/T/abnerworks.Typora/image-20181102215251167.png" alt="image-20181102215251167"></p><h4 id="他人的思路-o-n"><a href="#他人的思路-o-n" class="headerlink" title="他人的思路 (o(n))"></a>他人的思路 (o(n))</h4><p>把p压缩成一个hash表，然后遍历s，也保存一个hash表</p><p>当s表的值的总和小于lp时继续添加，等于时判断两个hash表是否相等</p><p>要注意，遍历s时的i始终比cs快了一步，也就是i始终指向cs保存的元素的下一个元素。</p><p>例 输入 “abab” “ab”</p><p>i=0 c={}</p><p>i=1 c={a:1}       (i指向b)</p><p>i=2 c={a:1,b:1} (i指向a)</p><p>所以要在循环结束后判断结束后的cs是否和cp相等，如果相等的话还要添加一个值。</p><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        ls, lp = len(s), len(p)       </span><br><span class="line">        cp = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lp):</span><br><span class="line">            <span class="keyword">if</span>(cp.has_key(p[i])):</span><br><span class="line">                cp[p[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cp[p[i]] = <span class="number">1</span></span><br><span class="line">        cs = dict();  </span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(ls):</span><br><span class="line">            l = sum(cs.values())</span><br><span class="line">            <span class="keyword">if</span>(l&lt;lp):</span><br><span class="line">                <span class="keyword">if</span>(cs.has_key(s[i])):</span><br><span class="line">                    cs[s[i]] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cs[s[i]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span>(cp == cs):</span><br><span class="line">                    ans.append(i-lp)</span><br><span class="line">                cs[s[i-lp]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span>(cs[s[i-lp]] == <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">del</span> cs[s[i-lp]]</span><br><span class="line">                <span class="keyword">if</span>(cs.has_key(s[i])):</span><br><span class="line">                    cs[s[i]] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cs[s[i]] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(cs==cp):      //i比hash表保存的值走的快了一步，最后一组没有进行比较</span><br><span class="line">            ans.append(ls-lp)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.youtube.com/watch?v=86fQQ7rVGxA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=86fQQ7rVGxA</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> sliding_window </category>
          
          <category> hash </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode283移动零</title>
      <link href="/2018/11/01/leetcode283%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
      <url>/2018/11/01/leetcode283%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<p>把数组中所有的零都移动到末尾，不改变其他元素的顺序，不用新的空间，尽可能的减少操作步骤</p><a id="more"></a><p>Given an array <code>nums</code>, write a function to move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>Note</strong>:</p><ol><li>You must do this <strong>in-place</strong> without making a copy of the array.</li><li>Minimize the total number of operations.</li></ol><p>思路：</p><p>交换</p><p>保存两个指针，一个指针j指向前面，另一个指针i向后遍历</p><p>当遍历到不为0的数时同前面指针所指的数据交换，然后j++</p><p>例子：</p><p>数据</p><p>1,3,0,2,0</p><p>step1: i,j都指向1,1不为0，j++     [1,3,0,2,0]</p><p>setp2:i,j都指向3，3不为0，j++   [1,3,0,2,0]</p><p>step3:i,j都指向0，j不变                [1,3,0,2,0]</p><p>step4:i指向2，j指向第一个0，交换，并且j++  [1,3,2,0,0]</p><p>step5:i指向0，不变  得到最后结果[1,3,2,0,0]</p><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        j=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>):</span><br><span class="line">                temp = nums[j]</span><br><span class="line">                nums[j] = nums[i]</span><br><span class="line">                nums[i] = temp</span><br><span class="line">                j=j+<span class="number">1</span></span><br><span class="line">            print(nums)</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mvvm</title>
      <link href="/2018/10/31/mvvm/"/>
      <url>/2018/10/31/mvvm/</url>
      
        <content type="html"><![CDATA[<p>软件体系结构MVVM</p><a id="more"></a><p>#背景</p><h3 id="mvc-model-view-controller"><a href="#mvc-model-view-controller" class="headerlink" title="mvc(model,view,controller)"></a>mvc(model,view,controller)</h3><h4 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h4><ul><li><p>视图：管理作为位图展示到屏幕上的图形和文字输出；</p></li><li><p>控制器：翻译用户的输入并依照用户的输入操作模型和视图；</p></li><li><p>模型：管理应用的行为和数据，响应数据请求（经常来自视图）和更新状态的指令（经常来自控制器）；</p><p><img src="https://raw.githubusercontent.com/Draveness/analyze/master/contents/architecture/images/mvx/Standard-MVC.jpg" alt="Standard-MV"></p><p>所有的通信都是单向的</p><p>View传送指令到Controller，Controller完成业务逻辑后要求Moder改变状态，Model将新的数据发送给View，用户得到反馈</p></li></ul><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><p>在 MVC 中，模型层可以单独工作，而视图层和控制器层都依赖与模型层中的数据。</p><p><img src="https://raw.githubusercontent.com/Draveness/analyze/master/contents/architecture/images/mvx/Essential-Dependencies-in-MVC.jpg" alt="Essential-Dependencies-in-MVC"></p><h4 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h4><p>分离展示层</p><p>GUI 应用程序由于其需要展示内容的特点，分为两个部分：一部分是用于展示内容的展示层（Presentation Layer），另一部分包含领域和数据逻辑的领域层（Domain Layer）。</p><p>MVC 最重要的目的并不是规定各个模块应该如何交互和联系，而是将原有的混乱的应用程序划分出合理的层级，把一团混乱的代码，按照展示层和领域层分成两个部分；</p><p>展示层对应MVC中的View(视图)和controller(控制器)，领域层对应模型层</p><h4 id="主导位置"><a href="#主导位置" class="headerlink" title="主导位置"></a>主导位置</h4><p>控制层。在MVC中，控制层占据主导地位，他决定用户的输入时如何被处理的。</p><p>模型层。模型都是被动的，只存储整个应用中的数据，信息的获取和更新都是由控制器来驱动</p><h4 id="实际应用的模型"><a href="#实际应用的模型" class="headerlink" title="实际应用的模型"></a>实际应用的模型</h4><p><img src="https://raw.githubusercontent.com/Draveness/analyze/master/contents/architecture/images/mvx/MVC-MVC.jpg" alt="MVC-MV"></p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>MVP是MVC的一个变种。</p><p><strong>两者之间最大的区别就是 MVP 中使用 Presenter 对视图和模型进行了解耦，它们彼此都对对方一无所知，沟通都通过 Presenter 进行。 </strong></p><p>在 MVP 中，Presenter 可以理解为松散的控制器，其中包含了视图的 UI 业务逻辑，所有从视图发出的事件，都会通过代理给 Presenter 进行处理；同时，Presenter 也通过视图暴露的接口与其进行通信。</p><p>所有的通信都是双向的，View和Moder之间不发生联系，都通过Presenter来传递</p><h4 id="被动视图"><a href="#被动视图" class="headerlink" title="被动视图"></a>被动视图</h4><p>在该变种的架构模式中，视图层是被动的，它本身不会改变自己的任何的状态，所有的状态都是通过 Presenter 来间接改变的。</p><p>被动的视图层就像前端中的 HTML 和 CSS 代码，只负责展示视图的结构和内容，本身不具有任何的逻辑</p><h5 id="依赖关系-1"><a href="#依赖关系-1" class="headerlink" title="依赖关系"></a>依赖关系</h5><p>视图层对于模型层没有任何的依赖</p><p><img src="https://raw.githubusercontent.com/Draveness/analyze/master/contents/architecture/images/mvx/Essential-Dependencies-in-Passive-View.jpg" alt="Essential-Dependencies-in-Passive-Vie"></p><h5 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h5><p><img src="https://raw.githubusercontent.com/Draveness/analyze/master/contents/architecture/images/mvx/Passive-View-with-Tags.jpg" alt="Passive-View-with-Tags"></p><ol><li>当视图接收到来自用户的事件时，会将事件转交给 Presenter 进行处理；</li><li>被动的视图向外界暴露接口，当需要更新视图时 Presenter 通过视图暴露的接口更新视图的内容；</li><li>Presenter 负责对模型进行操作和更新，在需要时取出其中存储的信息；</li><li>当模型层改变时，可以将改变的信息发送给<strong>观察者</strong> Presenter</li></ol><h5 id="监督控制器"><a href="#监督控制器" class="headerlink" title="监督控制器"></a>监督控制器</h5><p><img src="https://raw.githubusercontent.com/Draveness/analyze/master/contents/architecture/images/mvx/Supervising-Controller.jpg" alt="Supervising-Controller"></p><p>与被动视图中状态同步都需要<strong>显式</strong>的操作不同，监督控制器（Supervising Controller）就将部分需要显式同步的操作变成了隐式的</p><p>视图层接管了一部分的视图逻辑，同步简单的视图和模型的状态。</p><p>监督控制器只负责响应用户的输入以及一部分更加复杂的视图，模型状态同步工作</p><p>但是对于视图、模型的同步工作，监督控制器会尽可能地将所有简单的属性<strong>以数据绑定的形式声明在视图层中</strong>，类似于 Vue 中双向绑定的简化版本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-bind:href=<span class="string">"url"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>对于用户输入的处理，监督控制器的做法与标准 MVP 中的 Presenter 完全相同</p><h5 id="通信方式-1"><a href="#通信方式-1" class="headerlink" title="通信方式"></a>通信方式</h5><p>监督控制器中的视图和模型层之间增加了两者之间的耦合</p><p>监管器与视图和模型之间的关系没有发生改变，增加了模型和视图之间的依赖，通过数据绑定来实现。</p><h5 id="主导地位"><a href="#主导地位" class="headerlink" title="主导地位"></a>主导地位</h5><p>在MVP架构模式中，视图层在整个架构中都是占据主导地位的。</p><p><img src="https://raw.githubusercontent.com/Draveness/analyze/master/contents/architecture/images/mvx/Main-View-in-MVP.jpg" alt="Main-View-in-MVP"></p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>MVVM将presenter改名为ViewModel,基本上与MVP一致</p><p>唯一的区别是采用双向绑定，View的变动自动反应在ViewModel中，反之亦然。</p><h4 id="前端开发的问题"><a href="#前端开发的问题" class="headerlink" title="前端开发的问题"></a>前端开发的问题</h4><p>1、开发者在代码中大量调用相同的 DOM API, 处理繁琐 ，操作冗余，使得代码难以维护。</p><p>2、大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</p><p>3、当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 View 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</p><p>早期jquery 的出现就是为了前端能更简洁的操作DOM 而设计的，但它只解决了第一个问题，另外两个问题始终伴随着前端一直存在。 </p><h4 id="MVVM基本概念"><a href="#MVVM基本概念" class="headerlink" title="MVVM基本概念"></a>MVVM基本概念</h4><p>MVVM 由 Model,View,ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。 </p><p>ViewModel通过双向绑定把View层和Model层连接起来，使得View和Model之间的同步工作是完全自动的。开发者只需要关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由MVVM来统一管理。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020110.png" alt="img"></p><h5 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h5><p>MVVM中的核心问题就是ViewModel和和View的双向数据绑定</p><p>Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。</p><p>ViewModel 所封装出来的数据模型包括视图的状态和行为两部分</p><p>而 Model 层的数据模型是只包含状态的</p><p>在ViewModel层，开发者对来自后端的数据进行二次封装。View展示的数据是来自ViewModel而不是Model。完全解耦了View和Model。</p><p><strong>Vue.js 的双向数据绑定</strong></p><p>Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p><p><img src="/var/folders/6p/_f33fscs7j316s490d30bm6c0000gn/T/abnerworks.Typora/image-20181101212219101.png" alt="image-20181101212219101"></p><p><strong>Observer</strong> 数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现。</p><p><strong>Compile</strong> 指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。</p><p><strong>Watcher</strong> 订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。</p><p><strong>Dep</strong> 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。</p><h5 id="双向数据绑定的原理"><a href="#双向数据绑定的原理" class="headerlink" title="双向数据绑定的原理"></a>双向数据绑定的原理</h5><p>使用到的方法：对象的访问器属性（get,set)，事件监听（观察者模式）</p><p>极简的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> id=<span class="string">"a"</span>&gt;</span><br><span class="line">&lt;span id=<span class="string">"b"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">'hello'</span>,&#123;</span><br><span class="line">    set:<span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;                       <span class="comment">//事件绑定的回调函数</span></span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'a'</span>).value = newVal;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'b'</span>).innerHTML = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'keyup'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;   <span class="comment">//事件监听器</span></span><br><span class="line">    obj.hello = e.target.value;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>文本框输入文字变化，span会同步显示相同的文字内容</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://draveness.me/mvx" target="_blank" rel="noopener">https://draveness.me/mvx</a></li><li></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1031Adversarial_Attacks</title>
      <link href="/2018/10/31/1031Adversarial-Attacks/"/>
      <url>/2018/10/31/1031Adversarial-Attacks/</url>
      
        <content type="html"><![CDATA[<p>计算机视觉领域的深度神经网络攻击综述</p><a id="more"></a><h1 id="Threat-of-Adversarial-Attacks-on-Deep-Learning-in-Computer-Vision-A-Survey"><a href="#Threat-of-Adversarial-Attacks-on-Deep-Learning-in-Computer-Vision-A-Survey" class="headerlink" title="Threat of Adversarial Attacks on Deep Learning in Computer Vision: A Survey"></a>Threat of Adversarial Attacks on Deep Learning in Computer Vision: A Survey</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>Deep neural networks are vulnerable to adversarial attacks in the form of subtle perturbations to inputs that lead a model to predict incorrect outputs.</p><p>This article presents the first comprehensive survey on adversarial attacks on deep learning in Computer Vision. We review the works that design adversarial attacks, analyze the existence of such attacks and propose defenses against them. </p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ol><li>Review the adversarial attacks for the task of image classification and beyond.</li><li>Approaches that deal with adversarial attacks in the real-world conditions. </li></ol><h2 id="Adversarial-attacks"><a href="#Adversarial-attacks" class="headerlink" title="Adversarial attacks"></a>Adversarial attacks</h2><h3 id="Attacks-for-classification"><a href="#Attacks-for-classification" class="headerlink" title="Attacks for classification"></a>Attacks for classification</h3><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwzsolh59pj30w20autfb.jpg" alt="img"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="Akhtar N, Mian A. Threat of adversarial attacks on deep learning in computer vision: A survey[J]. arXiv preprint arXiv:1801.00553, 2018.">1</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode169寻找出现次数最多的数</title>
      <link href="/2018/10/31/leetcode169MajorityElement/"/>
      <url>/2018/10/31/leetcode169MajorityElement/</url>
      
        <content type="html"><![CDATA[<p>在一个长度为n的数组中，寻找出现次数大于n/2的数<br><a id="more"></a></p><h2 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element"></a>169. Majority Element</h2><p>Given an array of size <em>n</em>, find the majority element. The majority element is the element that appears <strong>more than</strong>n/2times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array.</p><p>最直接的思路，用一个字典保存所有数出现的次数，当出现大于n/2的直接返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        d = dict()</span><br><span class="line">        l = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            <span class="keyword">if</span>(d.has_key(nums[i])):</span><br><span class="line">                d[nums[i]] = d[nums[i]]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[nums[i]] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span>(d[nums[i]]&gt;=l/<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br></pre></td></tr></table></figure><p>看到别人的思路，把数组排序，中间的值一定是出现次数大于等于2的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[len(nums)/<span class="number">2</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode160寻找链表交叉点</title>
      <link href="/2018/10/30/leetcode160%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E4%BA%A4%E5%8F%89%E7%82%B9/"/>
      <url>/2018/10/30/leetcode160%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E4%BA%A4%E5%8F%89%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>160寻找链表交叉点<br><a id="more"></a></p><h2 id="题目：-Intersection-of-Two-Linked-Lists"><a href="#题目：-Intersection-of-Two-Linked-Lists" class="headerlink" title="题目： Intersection of Two Linked Lists"></a>题目： Intersection of Two Linked Lists</h2><p>寻找两个链表相交的节点</p><p>提示：</p><ul><li><p>If the two linked lists have no intersection at all, return <code>null</code>.</p></li><li><p>The linked lists must retain their original structure after the function returns.</p></li><li><p>You may assume there are no cycles anywhere in the entire linked structure.</p></li><li><p>Your code should preferably run in O(n) time and use only O(1) memory.</p></li></ul><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwqitpkz5ij30o7053glu.jpg" alt="示例图"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果两个链表有交点，那么从交点开始算起他们的长度一定是相等的。</p><p>先得到两个链表的长度，然后把长的那个链表的前半部分截去（如果有交点一定不可能发生在长的这一段）</p><p>然后再一起遍历，如果有相同的节点则相交，否则没有</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        a = headA</span><br><span class="line">        b = headB</span><br><span class="line">        alen=<span class="number">0</span></span><br><span class="line">        blen=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="keyword">None</span>):</span><br><span class="line">            alen=alen+<span class="number">1</span></span><br><span class="line">            a=a.next</span><br><span class="line">        <span class="keyword">while</span>(b!=<span class="keyword">None</span>):</span><br><span class="line">            blen=blen+<span class="number">1</span></span><br><span class="line">            b=b.next</span><br><span class="line">        print(alen,blen)</span><br><span class="line">        a = headA</span><br><span class="line">        b = headB</span><br><span class="line">        <span class="keyword">if</span>(alen&gt;blen):        </span><br><span class="line">            i=<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;alen-blen):</span><br><span class="line">                a = a.next</span><br><span class="line">                i=i+<span class="number">1</span></span><br><span class="line">            print(i)</span><br><span class="line">        <span class="keyword">elif</span>(blen&gt;alen):     </span><br><span class="line">            j=<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;blen-alen):</span><br><span class="line">                b = b.next</span><br><span class="line">                j=j+<span class="number">1</span></span><br><span class="line">            print(j)</span><br><span class="line">        <span class="keyword">while</span> a != b:</span><br><span class="line">            a, b = a.next, b.next</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>flask前后端数据传递</title>
      <link href="/2018/10/29/flask%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
      <url>/2018/10/29/flask%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<p>flask前后端数据传递的问题<br><a id="more"></a></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h4 id="POST-GET"><a href="#POST-GET" class="headerlink" title="POST GET"></a>POST GET</h4><p><img src="http://upload-images.jianshu.io/upload_images/14649226-de7a037a74158ee3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="AJAX前端传送和接收"><a href="#AJAX前端传送和接收" class="headerlink" title="AJAX前端传送和接收"></a>AJAX前端传送和接收</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">                url: &quot;/new&quot;,   //对应flask中的路由</span><br><span class="line">                type: &quot;POST&quot;, //请求方法</span><br><span class="line">                data: &apos;hello&apos;,   //传送的数据</span><br><span class="line">                dataType: &quot;json&quot;, //传送的数据类型</span><br><span class="line">                success: function (data) &#123;  //成功得到返回数据后回调的函数</span><br><span class="line">                    console.log(data)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><h4 id="Flask后端接收处理和返回"><a href="#Flask后端接收处理和返回" class="headerlink" title="Flask后端接收处理和返回"></a>Flask后端接收处理和返回</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/new&apos;,methods=[&apos;POST&apos;])   //第一个参数是路由，第二个是请求方法</span><br><span class="line">def new():</span><br><span class="line">    recv_data = request.get_data()  //得到前端传送的数据</span><br><span class="line">    print(recv_data)</span><br><span class="line">    data = somefunction()   //对数据做某些处理</span><br><span class="line">    return data                   //返回数据</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flask </category>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python数据转换</title>
      <link href="/2018/10/29/python%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/"/>
      <url>/2018/10/29/python%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>简单介绍了python中的数据转换问题<br><a id="more"></a></p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><h4 id="int-函数"><a href="#int-函数" class="headerlink" title="int 函数"></a>int 函数</h4><ol><li>把符合数学格式的数字型字符串转换成整数</li><li>把浮点数转换成整数，但是只是简单的取整，而非四舍五入。<h4 id="float函数"><a href="#float函数" class="headerlink" title="float函数"></a>float函数</h4>将整数和字符串转换为浮点数<h4 id="str-函数"><a href="#str-函数" class="headerlink" title="str 函数"></a>str 函数</h4>将数字转换为字符<h4 id="list-和-tuple"><a href="#list-和-tuple" class="headerlink" title="list 和 tuple"></a>list 和 tuple</h4>tuple转list  list(tup)<br>list转tuple  tuple(list)<h4 id="String转list"><a href="#String转list" class="headerlink" title="String转list"></a>String转list</h4><h5 id="简单转换-list函数"><a href="#简单转换-list函数" class="headerlink" title="简单转换 list函数"></a>简单转换 list函数</h5>list(str)<br>将字符串中的每一个字母作为列表中的一个元素，空格也算一个元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hi = &quot;hi world&quot;</span><br><span class="line">list(hi)</span><br><span class="line">[&apos;h&apos;,&apos;i&apos;,&apos; &apos;,&apos;w&apos;,&apos;o&apos;,&apos;r,&apos;,&apos;l&apos;,&apos;d&apos;]</span><br></pre></td></tr></table></figure></li></ol><h5 id="指定分隔符"><a href="#指定分隔符" class="headerlink" title="指定分隔符"></a>指定分隔符</h5><p>split<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;hello,world&quot;</span><br><span class="line">slist = s.split(&quot;,&quot;)</span><br><span class="line">//[&apos;hello&apos;,&apos;world&apos;]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js数据转换</title>
      <link href="/2018/10/29/js%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/"/>
      <url>/2018/10/29/js%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>最近第一次写前后端数据的互传，遇到了很多数据类型的转换，每次都记不住然后再查，先总结一下JS的转换问题，Python的转换问题后面补上<br><a id="more"></a></p><h4 id="查看数据类型-typeof"><a href="#查看数据类型-typeof" class="headerlink" title="查看数据类型 typeof()"></a>查看数据类型 typeof()</h4><p>JS中一共有5种简单的数据类型：Undifined,Null,Boolean,Number,String<br>其他引用类型：<br>Object(Array,Date,RegExp,Function)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof //在js中用于检查数据类型</span><br><span class="line">var message = &apos;hello world&apos;;</span><br><span class="line">console.log(typeof(message));</span><br></pre></td></tr></table></figure></p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><table><thead><tr><th>转数字</th><th>转数组</th><th>其他类型转字符串</th></tr></thead><tbody><tr><td>parseInt(str)      转整数</td><td>str.split(“,”)</td><td>toString()</td></tr><tr><td>parseFloat(str)  转浮点数</td><td></td></tr></tbody></table><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组转字符串  arr.join(“ “)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.join(&quot;-&quot;)  //引号内是分隔符</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML笔记</title>
      <link href="/2018/10/29/HTML/"/>
      <url>/2018/10/29/HTML/</url>
      
        <content type="html"><![CDATA[<p>很少的一些html中的笔记<br><a id="more"></a></p><h2 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h2><h2 id="lt-p"><a href="#lt-p" class="headerlink" title="\&lt;p/>"></a>\&lt;p/></h2><p>p标签内的文字自动换行设置:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">word-break</span><span class="selector-pseudo">:normal</span>;</span><br><span class="line"><span class="selector-tag">white-space</span><span class="selector-pseudo">:pre-warp</span>;</span><br><span class="line"><span class="selector-tag">word-wrapL</span><span class="selector-pseudo">:break-word</span>;</span><br></pre></td></tr></table></figure><!-- more --><ol><li><p>word-break属性：</p><p> 在恰当的断字点进行换行。有三个值：normal(使用浏览器默认的换行规则)、break-all(允许单词内换行)、keep-all(只能在半角空格或连字符处换行)</p></li><li><p>white-space属性：</p><p>white-space属性设置如何处理元素内的空白。</p><p>这个属性声明建立布局中如何处理元素中的空白字符，有六个值：normal(默认。空白会被忽略)、pre(空白会被浏览器保留。其行为方式类似HTML代码中的<pre>标签)、</pre></p><p>nowrap（文本不会换行，文本会在同一行上继续，直到遇到<br>标签为止）、pre-wrap（保留空白符序列，但是正常的换行）、pre-line（合并空白符序列，但是保留空白      符）、inherit（规定应该从父元素继承white-space属性的值）;</p></li><li><p>word-wrap属性：</p><p>允许长单词换行到下一行；有两个值：normal（只允许在断字点换行）、break-word(在长单词或者URL地址内部进行换行)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS笔记</title>
      <link href="/2018/10/29/JS%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/10/29/JS%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>全部都是看红宝书时候记得笔记，十分杂乱<br><a id="more"></a></p><h2 id="第六章-面向对象的程序设计"><a href="#第六章-面向对象的程序设计" class="headerlink" title="第六章 面向对象的程序设计"></a>第六章 面向对象的程序设计</h2><h4 id="6-1-对象"><a href="#6-1-对象" class="headerlink" title="6.1 对象"></a>6.1 对象</h4><h5 id="6-1-1-理解对象"><a href="#6-1-1-理解对象" class="headerlink" title="6.1.1 理解对象"></a>6.1.1 理解对象</h5><p>无序属性的集合，其属性可以包含基本值，对象或者函数</p><ol><li>两种创建方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*第一种 创建Object实例*/</span><br><span class="line">var person = new Object();</span><br><span class="line">person.name = &quot;Tom&quot;;</span><br><span class="line">person.age = 29;</span><br><span class="line"></span><br><span class="line">person.sayName = function()&#123;</span><br><span class="line">    alert(person.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* 第二种 对象字面量*/</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">    name:&quot;Tom&quot;,</span><br><span class="line">    age:29,</span><br><span class="line">    </span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>对象的属性类型</li></ol><ul><li><p>数据属性</p><p>数据属性可以读取或者写入值，有四个可以描述属性行为的特性：</p><p>[[configurable]]<br>[[Enumerable]]<br>[[Writable]]<br>[[Value]]</p></li><li><p>访问器属性</p><p>不包含数据值，包含一对getter和setter函数</p><p>读取属性调用getter函数，写入属性调用setter函数</p><p>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">    _year:2004,</span><br><span class="line">    edition:1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(book,&quot;year&quot;,&#123;</span><br><span class="line">    get:function()&#123;</span><br><span class="line">        return this._year;</span><br><span class="line">    &#125;</span><br><span class="line">    set:function(newValue)&#123;</span><br><span class="line">        if(newValue&gt;2004)&#123;</span><br><span class="line">            this._year = newValue;</span><br><span class="line">            this.edition += newValue - 2004;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.year = 2005;</span><br><span class="line">alert(book.edition); //2</span><br></pre></td></tr></table></figure><h5 id="6-1-2-创建对象"><a href="#6-1-2-创建对象" class="headerlink" title="6.1.2 创建对象"></a>6.1.2 创建对象</h5><ol><li><p>工厂模式</p><p>用函数来封装以特定接口创建对象的细节</p><p>优点：抽象了具体过程<br><br>缺点：无法识别对象的类型</p></li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age,job)&#123;</span><br><span class="line">    var o = new Object;</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(o.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>构造函数模式</p><p> 创建自定义的构造函数，从而定义自定义对象类型的属性和方法 <br><br> 优点：可以识别对象的类型<br><br> 缺点:每个方法都要在每个实例上重新创建一遍</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(Tom,29)</span><br><span class="line"></span><br><span class="line">alert(person instanceof Person) //true</span><br></pre></td></tr></table></figure></li></ol><p>   解释构造函数：</p><p>   同其他函数的唯一区别：调用方式不同<br><br>   任何函数通过new操作符来调用都可以作为构造函数</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var person = new Person(&quot;Tom&quot;,29)</span><br><span class="line">person.sayName(); //Tom</span><br><span class="line"></span><br><span class="line">// 全局作用域中调用函数,this对象总指向global对象（在浏览器中就是window对象）</span><br><span class="line">Person(&quot;Ford&quot;,29)</span><br><span class="line">window.sayName();//Ford</span><br><span class="line"></span><br><span class="line">// 在另一个对象的作用域中调用 o和前面的person的属性是相同的</span><br><span class="line"></span><br><span class="line">var o = new Object();</span><br><span class="line">Person.call(o,&quot;Jack&quot;,29);</span><br><span class="line">o.sayName(); //Jack</span><br><span class="line"></span><br><span class="line">// o和person虽然有相同的属性，但是对象类型不同</span><br><span class="line">alert(o instanceof Person); //false</span><br><span class="line">alert(person instanceof Person); //true</span><br><span class="line"></span><br><span class="line">//想要尝试修改o的构造函数，这是错误的。因为构造函数是由原型指定的，如果试图修改o的原型也就是Object的原型，会导致所有的对象发生错误，因此js不允许做这样的修改。</span><br></pre></td></tr></table></figure><p><strong>2. 原型模型</strong></p><p>   每一个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，这个对象包含可以由特性类型的所有实例共享的属性和方法。</p><p>   prototype指向通过构造函数创建的对象实例的原型对象。</p><p>   优点：所有对象实例都可以共享它所包含的属性和方法<br></p><p>   缺点：</p><ol><li>忽略了构造函数传参，所有实例共享相同的默认值</li><li>对于引用值属性，修改一个实例所有实例都将被修改</li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    person.prototype.name = &quot;Tom&quot;;</span><br><span class="line">    person.prototype.age = 29;</span><br><span class="line">    person.prototype.sayName=function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line">person.sayName();//Tom</span><br><span class="line">var person2 = new Person();</span><br><span class="line"></span><br><span class="line">alert(person1.sayName == person2.sayName) //true</span><br></pre></td></tr></table></figure><p><strong>理解原型对象</strong></p><p>创建新函数就会根据一组特定的规则为该函数创建一个prototype属性，指向函数的原型对象。</p><p>函数的原型对象中有一个constructor属性，指向创建的自定义函数。</p><p>构造函数的实例中也有一个prototype属性，指向函数的原型对象。</p><p>关系如图所示:</p><p><img src="http://o7cqr8cfk.bkt.clouddn.com/public/16-11-10/6663492.jpg" alt="image"></p><p>注意：可以通过对象实例来访问保存在原型中的值，但是不能通过对象实例重写原型中的值。</p><p>如果在实例中添加一个跟原型对象中同名的属性值，那么该属性值会屏蔽掉原型中的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person1.name = &quot;Jack&quot;;</span><br><span class="line">person1.sayName();//Jack 屏蔽掉了原型中的值</span><br><span class="line">person2.sayName();//Tom 原型中的值</span><br></pre></td></tr></table></figure><p><strong>原型的动态性</strong></p><p>对原型所做的任何修改都可以在实例上体现出来<br><br>因为实例和原型的连接是一个指针,实例可以通过该指针在原型中找到新的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName=function()&#123;</span><br><span class="line">    alert(&quot;Tom&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.sayName();//Tom</span><br></pre></td></tr></table></figure><p>但是如果重写整个prototype对象，则相当于切断了实例与原型对象的联系，因为实例仍然指向最初的原型对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    Person.prototype.name=&quot;tom&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    sayHello : function()&#123;</span><br><span class="line">        console.log(&quot;Hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//person只能访问到旧原型中的属性，重写的原型无法访问</span><br><span class="line">console.log(person.name); //tom</span><br><span class="line">person.sayHello();        //error</span><br></pre></td></tr></table></figure><p><strong>3. 组合使用构造函数模式和原型模式</strong></p><p>构造函数模式用于定义不共享的实例属性，原型模式用于定义方法和共享的属性。</p><p>优点： 每个实例都会有自己的一份实力属性的副本，同时又共享者对方法的引用，节省了内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.friends = [&quot;Shelby&quot;,&quot;Court&quot;] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor:Person,</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&quot;Tom&quot;,29);</span><br><span class="line">var person2 = new Person(&quot;Jack&quot;,29);</span><br><span class="line"></span><br><span class="line">//对一个实例的引用属性的修改不会影响其他实例</span><br><span class="line">person1.friends.push(&quot;Mary&quot;);</span><br><span class="line">console.log(person1.friends); //[&quot;Shelby&quot;,&quot;Court&quot;,&quot;Mary&quot;]</span><br><span class="line">console.log(person2.friends);//[&quot;Shelby&quot;,&quot;Court&quot;]</span><br><span class="line"></span><br><span class="line">//共享方法</span><br><span class="line">console.log(person1.sayName==person2.sayName) //true</span><br></pre></td></tr></table></figure><h4 id="6-2-继承"><a href="#6-2-继承" class="headerlink" title="6.2 继承"></a>6.2 继承</h4><p>ECMAScript只支持实现继承，依靠原型链来实现</p><h5 id="6-2-1-原型链继承"><a href="#6-2-1-原型链继承" class="headerlink" title="6.2.1 原型链继承"></a>6.2.1 原型链继承</h5><p>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p><p>实现的本质：用一个新类型的实例来重写并且代替原型对象。</p><p>缺点：</p><ol><li>如果作为子类型原型对象的超类型实例中有引用类型，那么修改某一个对象的引用类型时所有对象的引用类型都将被修改。</li><li>创建子类型的实例时，不能像超类型的构造函数传参。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">    this.color = [&quot;red&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue=function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function subType()&#123;</span><br><span class="line">    this.subProperty = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line">subType.prototype.getSubValue = function()&#123;</span><br><span class="line">    return this.subProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new subType();</span><br><span class="line">var instance2 = new subType();</span><br><span class="line">console.log(instance1.getSuperValue); //true</span><br><span class="line"></span><br><span class="line">//缺点：修改1的color,2的color也会改变</span><br><span class="line">instance1.color.push(&quot;black&quot;);</span><br><span class="line">console.log(instance1.color);//[&quot;red&quot;,&quot;black&quot;]</span><br><span class="line">console.log(instance2.color);//[&quot;red&quot;,&quot;black&quot;]</span><br></pre></td></tr></table></figure><p>注意：使用原型链继承时不能用对象字面量来创建原型方法，这样会重写原型链，切断与超类的联系。</p><h5 id="6-2-2-借用构造函数"><a href="#6-2-2-借用构造函数" class="headerlink" title="6.2.2 借用构造函数"></a>6.2.2 借用构造函数</h5><p>基本思想:在子类型构造函数的内部调用超类型构造函数。</p><p>优点：解决了原型中包含引用类型值带来的问题<br><br>缺点: 无法实现函数复用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.color = [&quot;red&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subProperty = false;</span><br><span class="line">    //可以传参</span><br><span class="line">    SuperType.call(this,&quot;Tom&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">var instance2 = new SubType();</span><br><span class="line"></span><br><span class="line">instance1.color.push(&quot;black&quot;);</span><br><span class="line">console.log(instance1.color); //[&quot;red&quot;,&quot;black&quot;]</span><br><span class="line">console.log(instance2.color); //[&quot;red&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//只继承了构造函数中的属性和方法，没有继承原型中的方法</span><br><span class="line">console.log(instance1.getSuperValue()) //error</span><br><span class="line"></span><br><span class="line">console.log(instance1 instanceof SuperType)//false</span><br></pre></td></tr></table></figure><h5 id="6-2-3组合继承"><a href="#6-2-3组合继承" class="headerlink" title="6.2.3组合继承"></a>6.2.3组合继承</h5><p>基本思路：原型链实现对原型属性和方法的继承<br>构造函数实现对实力属性的继承。</p><p>优点:实现了函数复用，又保证每个实例都有自己的属性</p><p>缺点:创建子类型时，会调用两次超类型的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.color=[&quot;red&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype=&#123;</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">    SuperType.call(this,name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType();</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType(&quot;Tom&quot;,&quot;29&quot;);</span><br><span class="line">var instance2 = new SubType(&quot;Jack&quot;,&quot;21&quot;);</span><br><span class="line"></span><br><span class="line">//修改引用类型属性不会影响其他实例</span><br><span class="line">instance1.color.push(&quot;black&quot;); </span><br><span class="line">console.log(instance1.color,instance2.color);//[&quot;red&quot;,&quot;black&quot;],[&quot;red&quot;]</span><br><span class="line"></span><br><span class="line">// 继承了超类型的原型方法,并且实现了复用</span><br><span class="line">console.log(instance1.sayName()); //Tom</span><br><span class="line">console.log(instance1.sayName==instance2.sayName); //True</span><br></pre></td></tr></table></figure><h5 id="6-2-4-原型式继承"><a href="#6-2-4-原型式继承" class="headerlink" title="6.2.4 原型式继承"></a>6.2.4 原型式继承</h5><p>想法：不必创建自定义类型，借助原型可以基于已有的对象创建新对象。</p><p>给出如下函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function object(o)&#123;</span><br><span class="line">    function F()&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br><span class="line">//本质是 object()对传入的对象执行了一次浅复制</span><br><span class="line"></span><br><span class="line">var person()&#123;</span><br><span class="line">    name:&quot;Tom&quot;,</span><br><span class="line">    friends:[&quot;Jack&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var anotherPerson = object(person);</span><br></pre></td></tr></table></figure></p><p>在ECMAsript 5新增了Object.create()方法来规范原型式继承。<br>接受两个参数（第二个可选):第一个参数是作为新对象原型的对象，第二个是为新对象额外定义属性的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name:&quot;Tom&quot;,</span><br><span class="line">    frineds:[&quot;Jack&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var anotherPerson = Object.create(person,&#123;name&#123;</span><br><span class="line">    value:&quot;Jack&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用场景：只想让一个对象与另一个对象保持类似的情况，没必要创建构造函数。</p><h5 id="6-3-5-寄生式继承"><a href="#6-3-5-寄生式继承" class="headerlink" title="6.3.5 寄生式继承"></a>6.3.5 寄生式继承</h5><p>思想:创建一个仅用于封装继承过程的函数，该函数内部以某种方式来增强对象，然后再返回对象。</p><p>缺点：</p><p>代码示范:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original)&#123;</span><br><span class="line">    var clone = Object.create(original);</span><br><span class="line">    clone.sayHi = function()&#123;</span><br><span class="line">        alert(&quot;HI&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//不一定是Object.create 任何可以返回同original相同的新对象的函数都可以</span><br></pre></td></tr></table></figure><h5 id="6-3-6-寄生组合式继承-最理想"><a href="#6-3-6-寄生组合式继承-最理想" class="headerlink" title="6.3.6 寄生组合式继承(最理想)"></a>6.3.6 寄生组合式继承(最理想)</h5><p>解决了组合式继承调用两次超类型构造函数的问题</p><p>基本模式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(SubType,SuperType)&#123;</span><br><span class="line">    var prototype = Object.create(SuperType.prototype);</span><br><span class="line">    prototype.constructor = SubType;</span><br><span class="line">    SubType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//修改前面组合继承的例子</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;Red&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype = &#123;</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">    SuperType.call(this,name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType,SuperType);</span><br><span class="line"></span><br><span class="line">var subtype =new SubType(&quot;Tom&quot;,21)</span><br><span class="line"></span><br><span class="line">//成功继承超类型原型对象中的方法</span><br><span class="line">console.log(subtype.sayName());//Tom</span><br></pre></td></tr></table></figure><h2 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h2><h2 id="第八章-迭代器和生成器-ES6"><a href="#第八章-迭代器和生成器-ES6" class="headerlink" title="第八章  迭代器和生成器 ES6"></a>第八章  迭代器和生成器 ES6</h2><h3 id="8-1-迭代器-amp-amp-生成器"><a href="#8-1-迭代器-amp-amp-生成器" class="headerlink" title="8.1 迭代器&amp;&amp;生成器"></a>8.1 迭代器&amp;&amp;生成器</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>是一种特殊对象，具有一些专门为迭代过程设计的专有接口。</p><ul><li>next() 每次调用返回一个结果对象{value,done} value表示下一个将要返回的值，done在没有更多数据返回时为true。</li><li>一个内部指针 用来指向当前集合中值的位置</li></ul><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器是一种返回迭代器的函数，通过function关键字后的星号（*）来表示，会用到新的关键字yield。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = createIterator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>在上述示例中，createIterator()前面的星号表明他是一个生成器，yield可以用来指定调用迭代器的next方法时返回值及返回顺序。</p><p>每当执行完一条yield语句后函数就会自动停止执行，直到再次调用迭代器的next()方法才会继续执行。</p><p>yield只能在生成器内部使用，在其他地方使用会导致程序抛出错误，生成器内部的函数也不行。</p><p><strong>其他创建方式</strong></p><ul><li>函数表达式  let createIterator = function *(items){}</li><li>生成器对象 let o ={ *createIterator(item){}}   let iterator = o.createIterator([1,2,3]);</li></ul><h3 id="8-2-可迭代对象和for-of循环"><a href="#8-2-可迭代对象和for-of循环" class="headerlink" title="8.2 可迭代对象和for-of循环"></a>8.2 可迭代对象和for-of循环</h3><p>可迭代对象具有symbol.iterator属性，是一种与迭代器密切相关的对象。</p><p>symbol.iterator通过指定的函数可以返回一个作用于附属对象的迭代器。</p><p>for-of循环每执行一次都会调用可迭代对象的next()方法，并将迭代器返回的结果对象的value属性存储在一个变量中，循环将持续执行这一过程直到返回对象的done属性的值为true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> values)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//依次输出1，2，3</span></span><br></pre></td></tr></table></figure><p>如果只需迭代数组或者集合中的值，用for-of循环代替for循环是个不错的选择。</p><h4 id="访问默认迭代器"><a href="#访问默认迭代器" class="headerlink" title="访问默认迭代器"></a>访问默认迭代器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> iterator = values[<span class="built_in">Symbol</span>.iterator]();</span><br></pre></td></tr></table></figure><p>由于具有symbol.iterator属性的对象都有默认的迭代器，因此可以用他来检测对象是否为可迭代对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">object</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] == <span class="string">"function"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建可迭代对象"><a href="#创建可迭代对象" class="headerlink" title="创建可迭代对象"></a>创建可迭代对象</h4><p>默认情况下，开发者定义的对象都是不可迭代对象，但可以通过给Symbol.iterator属性添加一个生成器，则可以将其变为可迭代对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = &#123;</span><br><span class="line">    items:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.items)&#123;</span><br><span class="line">    <span class="keyword">yield</span> item;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> collection)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1,2,3</span></span><br></pre></td></tr></table></figure><h3 id="8-3-内建迭代器"><a href="#8-3-内建迭代器" class="headerlink" title="8.3 内建迭代器"></a>8.3 内建迭代器</h3><h4 id="集合对象迭代器"><a href="#集合对象迭代器" class="headerlink" title="集合对象迭代器"></a>集合对象迭代器</h4><p>ES6中有三种类型的集合对象：数组，Map集合，Set集合</p><p>这三种对象都内建了三种迭代器：</p><ul><li>entries() 返回一个迭代器，其值为多个键值对。</li><li>values() 返回一个迭代器，其值为集合的值。</li><li>keys() 返回一个迭代器，其值为集合中的所有键名</li></ul><h5 id="entries-迭代器"><a href="#entries-迭代器" class="headerlink" title="entries()迭代器"></a>entries()迭代器</h5><p>每次调用next方法，entries()迭代器都会返回一个数组，数组中的两个元素分别表示每个元素的键和值。</p><ul><li>数组：第一个元素是数字类型的索引，第二哥元素是数组值</li><li>set集合：第一个和第二个元素都是值</li><li>map集合，第一个元素为键名，第二个元素为键值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>,<span class="number">5678</span>,<span class="number">9012</span>]);</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">"title"</span>,<span class="string">"ES6"</span>);</span><br><span class="line">data.set(<span class="string">"format"</span>,<span class="string">"ebook"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> color.entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entrt);  <span class="comment">//[0,"red"] [1,"green"] [2,"blue"]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> tracking.entried())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entrt); <span class="comment">//[1234,1234] [5678,5678] [9012,9012]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> data.entried())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry);  <span class="comment">//["title","ES6"] ["format","ebook"]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="values-迭代器"><a href="#values-迭代器" class="headerlink" title="values()迭代器"></a>values()迭代器</h5><p>调用value()迭代器会返回集合中所存的所有值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>,<span class="number">5678</span>,<span class="number">9012</span>]);</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">"title"</span>,<span class="string">"ES6"</span>);</span><br><span class="line">data.set(<span class="string">"format"</span>,<span class="string">"ebook"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> color.values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);  <span class="comment">//"red" "green" "blue"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> tracking.values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">//1234 5678 9012</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> data.values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);  <span class="comment">//"ES6" "ebook"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="keys迭代器"><a href="#keys迭代器" class="headerlink" title="keys迭代器"></a>keys迭代器</h5><p>keys迭代器会返回集合中存在的每一个键</p><ul><li>数组：返回数字类型的键，数组本身的其他属性不会被返回</li><li>set集合：键与值相同，返回和values相同的迭代器</li><li>map集合：返回每个独立的键</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>,<span class="number">5678</span>,<span class="number">9012</span>]);</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">"title"</span>,<span class="string">"ES6"</span>);</span><br><span class="line">data.set(<span class="string">"format"</span>,<span class="string">"ebook"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">of</span> colors.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);   <span class="comment">//0 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">of</span> tracking.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);   <span class="comment">//1234,5678,9012</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">of</span> data.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);   <span class="comment">//"title" "format"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不同集合类型的默认迭代器"><a href="#不同集合类型的默认迭代器" class="headerlink" title="不同集合类型的默认迭代器"></a>不同集合类型的默认迭代器</h5><p>每个集合类型都有一个默认的迭代器，在for-of循环中，如果没有显示指定则使用默认的迭代器。</p><p>数组和set组合的默认迭代器是values()方法，Map集合的默认迭代器是entries()方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>,<span class="number">5678</span>,<span class="number">9012</span>]);</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">"title"</span>,<span class="string">"ES6"</span>);</span><br><span class="line">data.set(<span class="string">"format"</span>,<span class="string">"ebook"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> color)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);  <span class="comment">//"red" "green" "blue"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> tracking)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);  <span class="comment">//1234 5678 9012</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> data)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry);  <span class="comment">//["title","ES6]  ["format","ebook"]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解构语法使map访问更简单</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [value,key] <span class="keyword">of</span> data)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value+<span class="string">","</span>+key)  <span class="comment">//"title,ES6"  "format,ebook"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串迭代器"><a href="#字符串迭代器" class="headerlink" title="字符串迭代器"></a>字符串迭代器</h4><p>解决双字节字符问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"A 𠮷 B"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> message)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//(空)</span></span><br><span class="line"><span class="comment">//𠮷</span></span><br><span class="line"><span class="comment">//(空)</span></span><br><span class="line"><span class="comment">//B</span></span><br></pre></td></tr></table></figure><h4 id="NodeList迭代器"><a href="#NodeList迭代器" class="headerlink" title="NodeList迭代器"></a>NodeList迭代器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> div <span class="keyword">of</span> divs)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(div.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="展开运算符与非数组可迭代对象"><a href="#展开运算符与非数组可迭代对象" class="headerlink" title="展开运算符与非数组可迭代对象"></a>展开运算符与非数组可迭代对象</h4><p>展开运算符可以操作所有可迭代对象，并根据默认迭代器来选取要引用的值，从迭代器读取所有值，然后按照返回顺序将他们依次插入到数组中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]),</span><br><span class="line">    array = [...Set];</span><br><span class="line"><span class="built_in">console</span>.log(array);    <span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">"name"</span>,<span class="string">"Nicholas"</span>],[<span class="string">"ages"</span>,<span class="number">25</span>]]),</span><br><span class="line">    array = [...map];</span><br><span class="line"><span class="built_in">console</span>.log(array);   <span class="comment">//[["name","Nicholas"],["ages",25]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在数组字面量中可以多次使用展开运算符，将可迭代对象中的多个元素依次插入新数组中，替换原来展开运算符所在的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> smallNumber = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    bigNumber = [<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>],</span><br><span class="line">    allNumber = [<span class="number">0</span>,...smallNumber,...bigNumber];</span><br><span class="line"><span class="built_in">console</span>.log(allNumber.length); <span class="comment">//7</span></span><br><span class="line"><span class="built_in">console</span>.log(allNumber); <span class="comment">//[0,1,2,3,100,101,102]</span></span><br></pre></td></tr></table></figure><p>将可迭代对象转换为数组，最简单的方法就是使用展开运算符。可以将字符串中的每一个字符存入新数组中，可以刻将nodeList对象中的每一个节点存入新数组中。</p><h3 id="8-4-高级迭代器功能"><a href="#8-4-高级迭代器功能" class="headerlink" title="8.4 高级迭代器功能"></a>8.4 高级迭代器功能</h3><h4 id="给迭代器传递参数"><a href="#给迭代器传递参数" class="headerlink" title="给迭代器传递参数"></a>给迭代器传递参数</h4><p>如果给迭代器的next()方法传递参数，则这个参数的值就会替代生成器内部上一条yield语句的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span>;   <span class="comment">//4+2</span></span><br><span class="line">    <span class="keyword">yield</span> second+<span class="number">3</span>;   <span class="comment">//5+3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">//&#123;value:1,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>)); <span class="comment">//&#123;value:6,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">5</span>)); <span class="comment">//&#123;value:8,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">//&#123;value:undefined,done:true&#125;</span></span><br></pre></td></tr></table></figure><h4 id="生成器返回语句"><a href="#生成器返回语句" class="headerlink" title="生成器返回语句"></a>生成器返回语句</h4><p>生成器也是函数，因此可以通过return语句提前退出函数执行。</p><p>在生成器中，return表示所有操作已经完成，属性done被设置为true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">//&#123;value:1,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">//&#123;value:42,done:true&#125;</span></span><br></pre></td></tr></table></figure><p>展开运算符与for-of循环语句会直接忽略通过return语句指定的任何返回值，因为只要done一变成true就立即停止读取其他的值。</p><h4 id="委托生成器"><a href="#委托生成器" class="headerlink" title="委托生成器"></a>委托生成器</h4><p>将两个迭代器合二为一，创建一个生成器，再给yield语句添加星号，就可以将生成数据的过程委托给其他迭代器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumberItetator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createColorIterator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"red"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"green"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> *createNumberIterator();</span><br><span class="line">    <span class="keyword">yield</span> *createColorIterator();</span><br><span class="line">    <span class="keyword">yield</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = createCombinedIterator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:1,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:2,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:"red",done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:"green",done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:true,done:false&#125;</span></span><br></pre></td></tr></table></figure><p>每一次调用next方法就会委托相应的迭代器生成相应的值，直到迭代器无法返回更多的值，此时执行最后一条yield语句并返回true。</p><h3 id="8-5-异步任务执行"><a href="#8-5-异步任务执行" class="headerlink" title="8.5 异步任务执行"></a>8.5 异步任务执行</h3><h4 id="8-5-1-简单任务执行器"><a href="#8-5-1-简单任务执行器" class="headerlink" title="8.5.1 简单任务执行器"></a>8.5.1 简单任务执行器</h4><p>yield语句会暂停当前函数的执行过程并等待下一次调用next()方法。因此可以创建一个函数，在函数中调用生成器生成相应的迭代器，从而可以不用回调函数实现异步调用next()。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> task = taskDef();</span><br><span class="line">    <span class="keyword">let</span> result = task.next();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环调用next()的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//如果任务未完成则继续执行</span></span><br><span class="line">        <span class="keyword">if</span>(!result.done)&#123;</span><br><span class="line">            result = task.next();</span><br><span class="line">            step();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><h4 id="8-5-2-像任务执行器传递数据"><a href="#8-5-2-像任务执行器传递数据" class="headerlink" title="8.5.2 像任务执行器传递数据"></a>8.5.2 像任务执行器传递数据</h4><p>传递数据最简单的方法是，把yield返回的值传入下一次next()方法的调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上述代码中修改传入的生成器函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span>); <span class="comment">//1</span></span><br><span class="line">    value = <span class="keyword">yield</span> value+<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">//4</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="8-5-3-异步任务执行器"><a href="#8-5-3-异步任务执行器" class="headerlink" title="8.5.3 异步任务执行器"></a>8.5.3 异步任务执行器</h4><p>等待异步过程时，任务执行器需要知晓回调函数是什么以及如何使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//返回一个异步函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                callback(<span class="literal">null</span>, <span class="string">"Hello"</span>);</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> task = taskDef();</span><br><span class="line">        <span class="keyword">let</span> result = task.next();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">                <span class="comment">//如果result.value是一个函数，则传入一个回调函数作为参数来调用</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span>  result.value === <span class="string">"function"</span>) &#123;</span><br><span class="line">                    result.value(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                            result = task.throw(err);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        result = task.next(data);</span><br><span class="line">                        step();</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="comment">//如果不是函数则直接把值传入next方法</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = task.next(result.value);</span><br><span class="line">                    step();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">        value = <span class="keyword">yield</span> fetchData();</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"world"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出  一秒钟后连续输出hello world</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以和循环配合，循环输出</span></span><br><span class="line"></span><br><span class="line">    run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">yield</span> fetchData(<span class="string">"hello"</span>+i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="第十章-DOM"><a href="#第十章-DOM" class="headerlink" title="第十章 DOM"></a>第十章 DOM</h2><p>DOM(文档对象模型)是针对HTML和XML文档的一个API（应用程序编程接口）</p><h3 id="10-1-节点层次"><a href="#10-1-节点层次" class="headerlink" title="10.1 节点层次"></a>10.1 节点层次</h3><p>DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构</p><h4 id="10-1-1-Node类型"><a href="#10-1-1-Node类型" class="headerlink" title="10.1.1 Node类型"></a>10.1.1 Node类型</h4><p>每个节点都有一个nodeType属性，用于表明节点的类型</p><h5 id="nodeName和nodeValue属性"><a href="#nodeName和nodeValue属性" class="headerlink" title="nodeName和nodeValue属性"></a><strong>nodeName和nodeValue属性</strong></h5><p>这两个属性的值完全取决于节点的类型</p><h5 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a><strong>节点关系</strong></h5><p>节点间的各种关系可以用传统的家族关系来描述：在html中，可以将body看成是html的子元素，html是body的父元素；body是head的同胞元素。</p><ul><li><p>每个节点都有一个<strong>childNodes</strong>属性，其中保存着一个NodeList对象（NodeList是一个类数组对象，并不是Array的实例，独特之处在于他是基于DOM结构动态执行查询的结果，能够自动反应DOM结构的变化）</p><pre><code>访问方式： </code></pre></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstChild = someNode.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> secondChild = someNode.childNodes.item(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> count = someNode.childNodes.length;<span class="comment">//表示的是访问这一刻NodeList包含的节点数量</span></span><br></pre></td></tr></table></figure><p>可以通过<strong>Aarray.prototype.slice()</strong>方法将NodeList转化为数组（IE8以下不支持)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">covertToArray</span>(<span class="params">nodes</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> array = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">       array = <span class="built_in">Array</span>.prototype.slice.call(nodes);</span><br><span class="line">   &#125;<span class="keyword">catch</span>(ex)&#123;</span><br><span class="line">       array = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;nodes.length;i++)&#123;</span><br><span class="line">           array.push(nodes[i]);</span><br><span class="line">       &#125;       </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>每个节点都有一个<strong>parent</strong>属性，指向文档树中的父节点</p><p>包含在childerNodes列表中的每个节点之间都是同袍节点，可以用<strong>previousSibling</strong>和<strong>nextSlibing</strong>来访问邻近的节点。</p><p>父节点的<strong>firstChild</strong>和<strong>lastChild</strong>属性分别指向childNodes列表中的第一个和最后一个子节点</p></li><li><p><strong>hasChildNodes()</strong></p><p>这个方法在包含一个或多个子节点的情况下返回true</p></li><li><p><strong>ownerDocument</strong>属性指向表示整个文档的文档节点，可以不用层层回溯直接访问文档节点</p></li></ul><h5 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h5><ul><li><p><strong>appendChild()</strong> 向childNodes列表的末尾添加一个节点，返回值是新增的节点</p><p>参数：要添加的节点</p><p>返回：添加的新节点</p><p><em>注意：任何DOM节点不能同时出现在文档的多个位置</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> returnedNode = someNode.appendChild(newNode);</span><br><span class="line">alert(returnedNode == newNode); <span class="comment">//true</span></span><br><span class="line">alert(someNode.lastChild == newNode); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果appendChild()传入了父节点的第一个节点，那么这个节点就会成为父节点的最后一个节点</span></span><br><span class="line"><span class="keyword">var</span> resurnedNode = someNode.appendChild(someNode.firstChild);</span><br><span class="line">alert(returnedNode == someNode.firstChild); <span class="comment">//false</span></span><br><span class="line">alert(returnedNode == someNode.lastChild);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>insertBefore()</strong>  把节点放入childNodes列表中某个特定的位置上</p><p>参数:要插入的节点，参照节点</p><p>返回：要插入的节点</p><p>插入节点后，要插入的节点会成为参照节点的previousSibling</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入后成为第一个节点</span></span><br><span class="line">returnedNode = someNode.insertBefore(node,someNode.firstNode);</span><br><span class="line">alert(returnedNode == someNode.firstNode) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>replaceChild</strong> 替换节点</p><p>参数：要插入的节点，被替换的节点</p><p>返回：被替换的节点</p><p>要替换的节点被从文档树中移除，被要插入的节点替换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换第一个节点</span></span><br><span class="line">returnedNode = someNode.replaceChild(newNode,someNode.firstChild);</span><br></pre></td></tr></table></figure></li><li><p><strong>removeChild</strong> 移除节点</p><p>参数：要移除的节点</p><p>返回：被移除的节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除最后一个节点</span></span><br><span class="line">returnedNode = someNode.removeChild(someNode.lastChild)</span><br></pre></td></tr></table></figure></li></ul><h5 id="一些其他方法"><a href="#一些其他方法" class="headerlink" title="一些其他方法"></a>一些其他方法</h5><ul><li><p><strong>cloneNode</strong> 创建调用这个方法的节点的一个完全相同的副本</p><p>参数：一个布尔值参数 </p><pre><code>true:执行深复制，复制节点及其整个子节点树false:执行浅复制，只复制节点本身</code></pre><p>返回：复制好的副本</p><p><em>注意：这个方法不会复制添加到DOM节点的js属性，如时间处理程序等</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--假设已经将ul元素的引用保存在了变量myList中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> deepList = myList.cloneNode(<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">    alert(deepList.childNodes.length); <span class="comment">//3</span></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> shallowList = myList.cloneNode(<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">    alert(shallowList.childNodes.length); <span class="comment">//0</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>normalize() 处理文档树中的文本节点（后面补充）</p></li></ul><h4 id="10-1-2-Document类型"><a href="#10-1-2-Document类型" class="headerlink" title="10.1.2 Document类型"></a>10.1.2 Document类型</h4><p>JS通过Document类型表示文档。</p><p>document对象是HTMLDocument的一个实例，表示整个HTML界面。</p><p>document对象是window对象的一个属性，可以作为全局对象来访问</p><p><strong>Document节点具有以下特征：</strong></p><ul><li>nodeType的值为9</li><li>nodeName的值为”#document“</li><li>nodeValue的值为null</li><li>parentNode的值为null</li><li>owenerDocument的值为null</li></ul><h5 id="document的子节点"><a href="#document的子节点" class="headerlink" title="document的子节点"></a>document的子节点</h5><ul><li><p><strong>documentElement</strong> 属性   始终指向html页面中的html元素</p><p>document的documentElement属性，firstChild属性，以及childNodes[0]都指向html</p></li><li><p><strong>body</strong> 属性   指向body元素</p></li><li><p><strong>doctype</strong> 属性   指向&lt;!DOCTYPE&gt;标签</p></li></ul><h5 id="document的属性"><a href="#document的属性" class="headerlink" title="document的属性"></a>document的属性</h5><ul><li><p><strong>title</strong>属性：包含着<title>元素中的文本  可以获得当前页面的标题，也可以修改</title></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> originalTitle = <span class="built_in">document</span>.title;</span><br><span class="line"><span class="built_in">document</span>.title = <span class="string">"New page title"</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>URL</strong> <strong>domain</strong> <strong>referrer</strong></p><p>URL:保存页面完整的URL</p><p>domain:只包含页面的域名</p><p>referrer:链接到当前页面的页面的URL（没有来源页面的情况下，可能包含空字符串）</p></li></ul><h5 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h5><ul><li><p><strong>document.getElementById()</strong></p><p>参数：要取得的元素的ID</p><p>返回：返回要取得的元素，如果没有该元素则返回NULL</p></li><li><p><strong>document.getElementsByTagName()</strong> </p><p>参数：要取得元素的标签名</p><p>返回：HTML文档中返回一个HTMLCollection对象，对象中的元素数量可以通过length属性取得</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> images = ducoment.getElementsByTagName(<span class="string">"img"</span>);</span><br><span class="line">alert(images.length);</span><br><span class="line">alert(images[<span class="number">0</span>].src);</span><br><span class="line">alert(images.item(<span class="number">0</span>).src);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTMLCollection对象方法:namedItem() 可以通过name特性取得集合中的项</span></span><br><span class="line"><span class="comment">//假设页面中包含如下img元素</span></span><br><span class="line">&lt;img src=<span class="string">"myImage.gif"</span> name=<span class="string">"myImage"</span>&gt;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> myImage = images.namedItem(<span class="string">"myImage"</span>);</span><br><span class="line"><span class="keyword">var</span> myImage = images[myImage] <span class="comment">//也支持按名称访问</span></span><br></pre></td></tr></table></figure></li><li><p><strong>getElementsByName()</strong>  </p><p>参数：name值</p><p>返回：带有给定name特性的所有元素</p></li></ul><h5 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h5><p> document对象还有一些特殊的集合，这些特殊的集合都是HTMLCollection对象，为访问文档常用的部分提供了快捷方式</p><ul><li>document.anchors  包含文档中所有带name特性的<a>元素</a></li><li>document.forms      包含文档中所有的form元素</li><li>document.images    包含文档中所有的Image元素</li><li>document.links         包含文档中所有带href的a元素</li></ul><h5 id="一致性检测"><a href="#一致性检测" class="headerlink" title="一致性检测"></a>一致性检测</h5><h5 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h5><h4 id="10-1-3-Element类型"><a href="#10-1-3-Element类型" class="headerlink" title="10.1.3 Element类型"></a>10.1.3 Element类型</h4><p>Element类型用于表现XML或HTML元素，提供了对元素标签名，子节点以及特性的访问。</p><p>具有以下特性：</p><ul><li>nodeType的值为1</li><li>nodeName的值为元素的标签名</li><li>nodeValue的值为null</li><li>parentNode可能是Document或Element</li><li>其子节点可能是Element,Text,Comment,ProcessingInstruction,CDATASection或EntityReference</li></ul><p>nodeName和tagName都会返回元素的标签名</p><h5 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h5><p>所有的HTML元素都由HTMLElement类型的子类型来表示。该类型直接继承Element并添加了一下属性。</p><p>添加的这些属性分别对应于每个HTML元素中都存在的标准特性：</p><ul><li>id 元素在文档中的唯一标识符</li><li>title 有关元素的附加信息</li><li>lang 元素内容的语言代码</li><li>dir 语言的方向（ltr rtl)</li><li>className 对应元素的class属性</li></ul><h5 id="取得特性"><a href="#取得特性" class="headerlink" title="取得特性"></a>取得特性</h5><p>操作特性的三个主要方法:<strong>getAttribute()、setAttribute()、removeAttribute()</strong></p><p>这三个方法可以针对任何特性使用，包括自定义特性。</p><p>取得特性是：<strong>getAttribute()</strong>  </p><ul><li>参数：特性名称（id,class,title,lang或自定义特性）</li><li>返回：特性值</li></ul><p>有两类特殊的特性，属性的值与通过getAttribute返回的值不相同：style,onclick</p><h5 id="设置特性-amp-amp-删除特性"><a href="#设置特性-amp-amp-删除特性" class="headerlink" title="设置特性&amp;&amp;删除特性"></a>设置特性&amp;&amp;删除特性</h5><p><strong>setAttribute()</strong></p><ul><li>参数：要设置的特性名，特性值</li><li>如果特性已经存在会用特性值替换已有的值，如果不存在就创建特性并设定相应的值</li></ul><p>所有的特性都是属性，也可以直接给属性赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div.id = <span class="string">"someOtherId"</span></span><br><span class="line">div.align = <span class="string">"left"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是通过赋值添加新的自定义属性,属性不会成为元素的特性</span></span><br><span class="line">div.mycolor = <span class="string">"red"</span></span><br><span class="line">alert(div.getAttribute(<span class="string">"mycolor"</span>))  <span class="comment">//null</span></span><br></pre></td></tr></table></figure><p><strong>removeAttribute()</strong></p><p>不仅会清除特性的值，也会从元素中完全删除特性。</p><h5 id="arrtibute属性"><a href="#arrtibute属性" class="headerlink" title="arrtibute属性"></a>arrtibute属性</h5><p>Element类型是使用attribute属性的唯一一个DOM节点类型。</p><p>attribute属性中包含一个NameNodeMap,与NodeList类似，也是一个动态的集合。<strong>元素中的每一个特性都由一个Arrt节点表示，每个节点的nodeName就是特性的名称，而节点的nodeValue就是特性的值。</strong>每个节点都保存在NameNodeMap对象中。该对象拥有下列方法：</p><ul><li>getNamedItem(name):返回nodeName属性等于name的节点</li><li>removeNamedItem(name):从列表中移除nodeName属性等于name的节点</li><li>setNamedItem(node):像列表中添加节点，以节点的nodeName属性为索引</li><li>item(pos)：返回位于数字pos位置的节点</li></ul><p>取得元素的id特性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = element.attributes.getNamedItem(<span class="string">"id"</span>).nodeValue;</span><br><span class="line"><span class="keyword">var</span> id =element.attributes[<span class="string">"id"</span>].nodeValue;</span><br></pre></td></tr></table></figure><p>给id特性设置新值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.attributes[<span class="string">"id"</span>].nodeValue = <span class="string">"someOtherId"</span>;</span><br></pre></td></tr></table></figure><p>删除特性</p><p>调用removeNamedItem()和在元素上调用removeAttribute()的效果相同，直接删除具有给定名称的特性。</p><p>但是removeNamedItem()会返回表示被删除特性的Attr节点。</p><p>一般来说，操作element特性时更多的使用getAttribute(),removeAttribute(),setAttribute()这三个方法</p><p>但是遍历元素特性时，attributes属性就会比较有用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>,ien = element.attributes.length;i&lt;len;i++)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h5><p>方法：document.createElement()</p><p>参数：要创建元素的标签名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个div元素</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line"><span class="comment">//可以操作新创建的元素，为他添加更多的子节点</span></span><br><span class="line">div.id = <span class="string">"myNewDiv"</span>;</span><br><span class="line">div.className = <span class="string">"box"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在新元素上设置特性只是赋予相应的信息，还未添加到文档树中，要显示在浏览器中，必须要添加到文档树中</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line"><span class="comment">//或者使用insertBefore,replaceChild</span></span><br></pre></td></tr></table></figure><h5 id="元素的子节点"><a href="#元素的子节点" class="headerlink" title="元素的子节点"></a>元素的子节点</h5><p>元素可以有任意数目的子节点和后代节点，因为元素可以是其他元素的子节点。</p><p>元素的childNodes属性包含了它的所有子节点，这些子节点有可能是元素，文本节点，注释或者处理指令。</p><p>不同的浏览器看待节点方面存在着显著的不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"myList"</span>&gt;</span><br><span class="line">    &lt;li&gt;Item <span class="number">1</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Item 2&lt;/</span>li&gt;</span><br><span class="line">&lt;li&gt;Item <span class="number">3</span>&lt;<span class="regexp">/li&gt;  </span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure><p>上述代码在IE中，<ul>元素会有3个子节点，分别是3个<li>元素。</li></ul></p><p>在其他浏览器中，<ul>元素有7个子节点，分别是3个<li>元素，以及<ul>和<li>之间的2个空白符,</li><li></li><li>之间的2个空白符。</li></ul></li></ul></p><p>所以如果需要在元素类型的子节点上进行某些操作，要先检查一下nodeType属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len = element.childrenNodes.length;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(element.childrenNodes[i].nodeType == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//需要执行的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过特定的标签名来取得子节点或者后代节点，使用<strong>getElementsByTagName()</strong></p><p>除了搜索节点是当前元素外，其他都跟通过document调用相同。因此也会只返回符合条件的当前元素的后代。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得ul元素包含的所有li元素</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"myList"</span>);</span><br><span class="line"><span class="keyword">var</span> li = ul.getElementsByTagName(<span class="string">"li"</span>);</span><br></pre></td></tr></table></figure><h4 id="10-1-4-Text类型"><a href="#10-1-4-Text类型" class="headerlink" title="10.1.4  Text类型"></a>10.1.4  Text类型</h4><p>包含可以按照字面解释的纯文本内容，可以包含转义后的HTML字符，但是不能包含HTML代码</p><p><strong>text节点具有以下特征：</strong></p><ul><li>nodeType的值为3</li><li>nodeName的值为”#text“</li><li>nodeValue的值为节点所包含的文本</li><li>parentNode是一个Element</li><li>不支持没有子节点</li></ul><p>nodeValue和data属性都可以访问文本节点中的文本</p><p><strong>节点操作方法</strong></p><ul><li>appendValue(text):将text添加到节点末尾</li><li>deleteDate(offset,count) ：从offset指定的位置开始删除count个字符</li><li>insertData(offset,text)：在offset指定的位置插入text</li><li>replaceData(offset,count,text)：用text替换从offset指定的位置开始到offset+count为止处的文本</li><li>splitText(offset)：从offset指定的位置将当前文本分成两个文本节点</li><li>substringData(offset,count)：提取从offset指定的位置开始到offset+count为止处的字符串</li></ul><p>文本节点还有一个length属性，保存着节点中字符的数目</p><p>nodeValue.length和data.length中也保存着相同的值。</p><h5 id="创建文本节点"><a href="#创建文本节点" class="headerlink" title="创建文本节点"></a>创建文本节点</h5><p>方法：document.createTextNode()</p><p>参数：要插入节点中的文本（按照HTML或XML的格式进行编码）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"&lt;strong&gt;Hello&lt;/strong&gt; world"</span>);</span><br></pre></td></tr></table></figure><p>要将新节点添加到文档树中已经存在的节点中才能使新节点在浏览器中展示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">element.className = <span class="string">"message"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world"</span>);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br></pre></td></tr></table></figure><h5 id="规范化文本节点"><a href="#规范化文本节点" class="headerlink" title="规范化文本节点"></a>规范化文本节点</h5><p>DOM文档中存在相邻的同胞文本节点很容易导致混乱，因此产生了一个能够将相邻文本节点合并的方法。</p><p>这个方法是：<strong>normalize()</strong> ，由Node类型定义，因此所有节点类型都存在该方法</p><p>如果在含有一个或多个文本节点的父元素上调用这个方法，则会将所有的文本节点合并成一个节点，节点的nodeValue等于将合并前每个文本节点的nodeValue值拼接起来的值。</p><p><em>浏览器在解析文档时永远不会创建相邻的文本节点，只有在执行DOM操作时会出现</em></p><h5 id="分割文本节点"><a href="#分割文本节点" class="headerlink" title="分割文本节点"></a>分割文本节点</h5><p>Text类型提供了一个作用跟normalize()相反的方法：<strong>splitText()</strong></p><p>这个方法会将一个文本节点分成两个文本节点</p><p>原来的节点包含从开始到指定位置之前的内容，新文本节点包含剩下的文本，返回新文本节点。新文本节点个原节点的parentNode相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">element.className = <span class="string">"message"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello World"</span>);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newNode = element.firstChild.splitText(<span class="number">5</span>);</span><br><span class="line">alert(element.firstChild.nodeValue); <span class="comment">//Hello</span></span><br><span class="line">alert(newNode.nodeValue); <span class="comment">//World</span></span><br><span class="line">alert(element.childrenNodes.length);<span class="comment">//2</span></span><br></pre></td></tr></table></figure><h4 id="10-1-5-Attr类型"><a href="#10-1-5-Attr类型" class="headerlink" title="10.1.5  Attr类型"></a>10.1.5  Attr类型</h4><p>区分特性（attribute）和属性（property）：</p><p>元素的特性在DOM中以attr来表示，从技术角度讲，特性就是存在于元素的attributes属性中的节点。</p><p>特性用来描述属性</p><p>Attr对象有3个属性：name,value,specified</p><p>name：特性名称（与nodeName的值相同）</p><p>value:   特性的值   (与nodeValue的值相同)</p><p>specified：一个布尔值，用以区别特性是在代码中指定的还是默认的。</p><h3 id="10-2-DOM操作技术"><a href="#10-2-DOM操作技术" class="headerlink" title="10.2 DOM操作技术"></a>10.2 DOM操作技术</h3><h4 id="10-2-1-动态脚本"><a href="#10-2-1-动态脚本" class="headerlink" title="10.2.1 动态脚本"></a>10.2.1 动态脚本</h4><p>动态脚本指的是：在页面加载时不存在，但将来的某一时刻通过修改DOM动态添加的脚本</p><h4 id="10-2-2-动态样式"><a href="#10-2-2-动态样式" class="headerlink" title="10.2.2 动态样式"></a>10.2.2 动态样式</h4><h4 id="10-2-3-操作表格"><a href="#10-2-3-操作表格" class="headerlink" title="10.2.3 操作表格"></a>10.2.3 操作表格</h4><h4 id="10-2-4-使用nodeList"><a href="#10-2-4-使用nodeList" class="headerlink" title="10.2.4 使用nodeList"></a>10.2.4 使用nodeList</h4><h2 id="第十一章-DOM扩展"><a href="#第十一章-DOM扩展" class="headerlink" title="第十一章  DOM扩展"></a>第十一章  DOM扩展</h2><p>两个主要的扩展是：Selectors API 和 HTML5</p><h3 id="11-1-选择符API"><a href="#11-1-选择符API" class="headerlink" title="11.1 选择符API"></a>11.1 选择符API</h3><p>Selectors API是由W3C发起指定的标准，致力于让浏览器原生支持CSS查询。这样一来，解析和树查询操作可以在浏览器内部通过编译后的代码来完成，极大地改善了性能。(jquery就是通过css选择符查询DOM获得文档的应用)</p><p>两个核心方法：querySelector()和querySelectorAll()。在兼容的浏览器中，可以通过Document及Element类型的实例来调用。</p><h4 id="11-1-1-querySelector"><a href="#11-1-1-querySelector" class="headerlink" title="11.1.1 querySelector()"></a>11.1.1 querySelector()</h4><p>方法：document(element).querySelector()</p><p>参数：css选择符</p><p>返回：与该模式匹配的第一个元素，没有找到则返回null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">"body"</span>);<span class="comment">//取得body元素</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.querySelector(<span class="string">"#myDiv);//取得ID为myDiv的元素</span></span><br><span class="line"><span class="string">var select = document.querySelector("</span>.selected<span class="string">")//取得class为selected的第一个元素</span></span><br><span class="line"><span class="string">var img = myDiv.querySelector("</span>img.button<span class="string">") //取得myDiv子代中第一个class为button的img元素</span></span><br></pre></td></tr></table></figure><h4 id="11-1-2-querySelectorAll"><a href="#11-1-2-querySelectorAll" class="headerlink" title="11.1.2 querySelectorAll()"></a>11.1.2 querySelectorAll()</h4><p>方法：document(element).querySelectorAll()</p><p>参数：css选择符</p><p>返回：返回一个nodeList对象，包含匹配的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ems = <span class="built_in">document</span>.querySelector(<span class="string">"myDiv"</span>).querySelectorAll(<span class="string">"em"</span>) <span class="comment">//取得myDiv中的所有em元素</span></span><br><span class="line"><span class="keyword">var</span> selecteds = <span class="built_in">document</span>.querySelectorALL(<span class="string">".selected"</span>) <span class="comment">//取得所有class为selected的元素</span></span><br><span class="line"><span class="keyword">var</span> strongs = <span class="built_in">document</span>.querySelectorAll(<span class="string">"p strong"</span>) <span class="comment">//取得所有p元素的strong元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取得返回nodeList中的每一个元素</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>,len = strongs.length;i&lt;len;i++)&#123;</span><br><span class="line">    strong = strongs[i] <span class="comment">//或者strong.item(i)</span></span><br><span class="line">    <span class="comment">//执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-1-3-matchedSelector"><a href="#11-1-3-matchedSelector" class="headerlink" title="11.1.3 matchedSelector()"></a>11.1.3 matchedSelector()</h4><p>为Element类型新增的方法</p><p>方法：element.matchedSelector()</p><p>参数：css选择符</p><p>返回：ture,flase; 如果调用元素与选择符匹配则返回ture，否则返回fasle</p><h3 id="11-2-元素遍历（不包含空白文本节点）"><a href="#11-2-元素遍历（不包含空白文本节点）" class="headerlink" title="11.2 元素遍历（不包含空白文本节点）"></a>11.2 元素遍历（不包含空白文本节点）</h3><p>对于元素空格，IE9及之前不会返回文本节点，其他浏览器都会。为了弥补这一差异，E定义了一组新的属性。</p><p>添加了以下五个属性：</p><ul><li>childElementCount:返回子元素（不包括文本节点和注释）的个数</li><li>firstElementChild:指向第一个元素</li><li>lastElementChild:指向最后一个元素</li><li>previousElementSibling:指向前一个同胞元素</li><li>nextElementSibling:指向后一个同胞元素</li></ul><p>这些属性返回的元素都不包含空白文本节点</p><p>遍历所有子元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i,len,child = element.firstElementChild;</span><br><span class="line"><span class="keyword">while</span>(child!=element.lastElementChild)&#123;</span><br><span class="line">    <span class="comment">//某些操作</span></span><br><span class="line">    child = child.nextElementSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-3-HTML5"><a href="#11-3-HTML5" class="headerlink" title="11.3 HTML5"></a>11.3 HTML5</h4><h4 id="11-3-1-与类相关的扩充"><a href="#11-3-1-与类相关的扩充" class="headerlink" title="11.3.1  与类相关的扩充"></a>11.3.1  与类相关的扩充</h4><p>新增了很多致力于简化CSS类的用法</p><h5 id="getElementsByClassName-方法"><a href="#getElementsByClassName-方法" class="headerlink" title="getElementsByClassName() 方法"></a>getElementsByClassName() 方法</h5><p>方法：getElementsByClassName()</p><p>参数：一个包含一或多个类名的字符串</p><p>返回：带有指定类的所有元素的NodeList</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得所有类中包含“username"和”current"的元素</span></span><br><span class="line"><span class="keyword">var</span> allCurrentUsernames = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"username current"</span>);</span><br><span class="line"><span class="comment">//取得ID为"myDiv"的元素中带有类名"selectd"的所有元素</span></span><br><span class="line"><span class="keyword">var</span> selectd = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).getElementsByClassName(<span class="string">"selected"</span>);</span><br></pre></td></tr></table></figure><h5 id="classList-属性"><a href="#classList-属性" class="headerlink" title="classList 属性"></a>classList 属性</h5><p>操作类名时，通过className属性添加，删除和替换类名。但是因为className是一个字符串，所以即使只是修改字符串一部分也必须都设置整个字符串的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个div元素一共有三个类名，要从中删除一个类名需要把三个类名拆开，然后删除再拼接</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"bd user disabled"</span>&gt;....&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>HTML5为所有元素添加classList属性以便操作类名。有包含多少元素的length属性，取得每个元素可以使用item()方法，也可以使用方括号[]。</p><p>新类型定义的方法如下：</p><ul><li>add(value):将给定的字符串添加到列表中</li><li>contains(value):表示列表中是否存在给定的值，如果存在则返回true，否则返回false</li><li>remove(value)：从列表中删除给定的字符</li><li>toggle(value)：如果列表中存在给定的值，删除它；如果列表中没有给定的值，添加它</li></ul><p>比如从上面的div元素中删除user类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.classList.remove(<span class="string">"user"</span>);</span><br></pre></td></tr></table></figure><h4 id="11-3-2-焦点管理"><a href="#11-3-2-焦点管理" class="headerlink" title="11.3.2 焦点管理"></a>11.3.2 焦点管理</h4><p>新增document.activeElement属性，这个属性始终会引用DOM中当前获得了焦点的元素（页面加载，用户输入，代码调用focus）。</p><p>默认情况下，文档刚加载完这个属性保存的是document.body元素，加载期间，这个属性的值为null。</p><p>新增方法：document.hasFocus()，用于确定文档是否获得了焦点。</p><h4 id="11-3-3-HEMLDocument的变化"><a href="#11-3-3-HEMLDocument的变化" class="headerlink" title="11.3.3 HEMLDocument的变化"></a>11.3.3 HEMLDocument的变化</h4><h5 id="readyState属性"><a href="#readyState属性" class="headerlink" title="readyState属性"></a>readyState属性</h5><p>两个可能的值：</p><ul><li>loading:正在加载文档</li><li>complete:已经加载完文档</li></ul><p>应用：实现一个指定文档已经加载完的指示器。</p><p>在这个属性之前，必须借助onload时间处理程序设置一个标签来表明文档已经加载完毕。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.readyState == <span class="string">"complete"</span>)&#123;</span><br><span class="line">    <span class="comment">//执行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-3-4-自定义数据属性"><a href="#11-3-4-自定义数据属性" class="headerlink" title="11.3.4 自定义数据属性"></a>11.3.4 自定义数据属性</h4><p>HTML5规定可以为元素添加非标准的属性，但是要添加前缀data-。目的是为元素提供与渲染无关的信息，或者提供语义信息。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">data-appID</span>=<span class="string">"12345"</span> <span class="attr">data-mynane</span>=<span class="string">"Jack"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过元素的dataset属性来访问自定义数据属性。dataset属性的值是DOMStringMap的一个实例，是一个名值对的映射。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"><span class="keyword">var</span> appId = div.dataset.appID;</span><br><span class="line"><span class="keyword">var</span> myname = div.dataset.myname;</span><br><span class="line">alert(<span class="string">"hello,"</span>+appid+myname);<span class="comment">//hello,12345Jack</span></span><br><span class="line"></span><br><span class="line">也可以修改值</span><br><span class="line">div.dataset.appID=<span class="number">123</span>;</span><br></pre></td></tr></table></figure><h3 id="11-4-一些专有扩展"><a href="#11-4-一些专有扩展" class="headerlink" title="11.4 一些专有扩展"></a>11.4 一些专有扩展</h3><h2 id="第十二章-DOM2和DOM3"><a href="#第十二章-DOM2和DOM3" class="headerlink" title="第十二章 DOM2和DOM3"></a>第十二章 DOM2和DOM3</h2><h3 id="12-1-DOM变化"><a href="#12-1-DOM变化" class="headerlink" title="12.1 DOM变化"></a>12.1 DOM变化</h3><h3 id="12-2-DOM操作样式"><a href="#12-2-DOM操作样式" class="headerlink" title="12.2 DOM操作样式"></a>12.2 DOM操作样式</h3><p>DOM级样式提供了一套API来操作样式。</p><h4 id="12-2-1-访问元素的样式"><a href="#12-2-1-访问元素的样式" class="headerlink" title="12.2.1 访问元素的样式"></a>12.2.1 访问元素的样式</h4><p>任何支持style特性的HTML元素在javascript中都有一个对应的style属性。在style特性中指定的任何CSS属性都将表现为这个style对象的相应属性。</p><p>style对象不包含与外部样式表或嵌入样式表经层叠而来的样式。</p><p>js访问时，对于使用短划线的css属性，必须将其转换为驼峰大小写形势</p><table><thead><tr><th>CSS属性</th><th>JavaScript属性</th></tr></thead><tbody><tr><td>background-imgae</td><td>style.backgroundImage</td></tr><tr><td>color</td><td>style.color</td></tr><tr><td>display</td><td>style.display</td></tr><tr><td>font-family</td><td>style.fontFamily</td></tr></tbody></table><p>多数情况下都可以通过转换属性名的格式来实现转换，但是css属性float不能，因为float是javascript的保留字，不能用作属性名。DOM2规范规定相应属性名为cssFloat，大部分浏览器都支持，但是IE支持的是styleFloat。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置样式</span></span><br><span class="line">myDiv.style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line">myDiv.style.border=<span class="string">"1px solid red"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取样式</span></span><br><span class="line">alert(myDiv.style.background) <span class="comment">//red;</span></span><br></pre></td></tr></table></figure><h5 id="DOM样式属性和方法"><a href="#DOM样式属性和方法" class="headerlink" title="DOM样式属性和方法"></a>DOM样式属性和方法</h5><p>为style对象定义了一些方法和属性：</p><ul><li>cssText:访问到style特性中的css代码</li><li>length:应用给元素的css属性的数量</li><li>parentRule:表示css信息的CSSRule对象</li><li>getPropertyCSSValue(propertyName):返回包含给定属性值的CSSValue对象（CSSValue对象包含两个属性：cssText,cssValueType。cssText属性的值和getPropertyValue()返回的值相同；cssValueType属性的值是一个数据常量，表示值的类型：0表示继承的值，1表示基本的值，2表示值列表，3表示自定义的值）</li><li>getPropertyPriority(propertyName):如果给定的属性使用了!important设置，返回”important”，否则返回空字符串</li><li>getPropertyValue(propertyName):返回给定属性的字符串值</li><li>item(index):返回给定位置的css属性的名称</li><li>removeProperty(propertyName):从样式中删除给定属性</li><li>setProperty(propertyName,value,priority):将给定属性设置为相应的值，并加上优先权标志(important或空字符串）</li></ul><h5 id="计算的样式"><a href="#计算的样式" class="headerlink" title="计算的样式"></a>计算的样式</h5><p>document.defaultView提供了getComputedStyle()方法</p><p>方法：getComputedStyle()</p><p>参数：要计算样式的元素，一个伪元素字符串（不选为null）</p><p>返回：一个CSSStyleDeclaration对象（与style属性的类型相同），包含当前元素的所有计算的样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span> = <span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.myDiv</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv1"</span> <span class="attr">class</span>=<span class="string">"myDiv"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv2"</span> <span class="attr">class</span>=<span class="string">"myDiv"</span> <span class="attr">style</span>=<span class="string">"background-color:red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> myDiv1 = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv1"</span>); </span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(myDiv1.style.width) <span class="comment">//"" undifined 无法访问到嵌入样式表的样式</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> computedStyle = <span class="built_in">document</span>.defaultView.getComputedStyle(myDiv1,<span class="literal">null</span>);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(computedStyle.width); <span class="comment">//100px</span></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> myDiv2 = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv2"</span>); </span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(myDiv1.style.backgroundColor); <span class="comment">//red</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(myDiv1.style.width); <span class="comment">//undefined</span></span></span><br><span class="line"><span class="undefined">   </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="12-2-2-操作样式表"><a href="#12-2-2-操作样式表" class="headerlink" title="12.2.2 操作样式表"></a>12.2.2 操作样式表</h4><h4 id="12-2-3-元素大小"><a href="#12-2-3-元素大小" class="headerlink" title="12.2.3 元素大小"></a>12.2.3 元素大小</h4><h3 id="12-3-遍历"><a href="#12-3-遍历" class="headerlink" title="12.3 遍历"></a>12.3 遍历</h3><p>NodeIterator和TreeWalker</p><p>深度优先的遍历</p><h3 id="12-4-范围"><a href="#12-4-范围" class="headerlink" title="12.4 范围"></a>12.4 范围</h3><p>##第十三章 事件</p><p>JavaScript与HTML之间的交互式通过事件来实现的。</p><h3 id="13-1-事件流"><a href="#13-1-事件流" class="headerlink" title="13.1 事件流"></a>13.1 事件流</h3><p>事件流描述的是从页面中接收事件的顺序。</p><h4 id="13-1-1-事件冒泡"><a href="#13-1-1-事件冒泡" class="headerlink" title="13.1.1 事件冒泡"></a>13.1.1 事件冒泡</h4><p>IE的事件流叫做事件冒泡，事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接受，然后逐级向上传播到较为不具体的节点（文档）</p><h4 id="13-1-2-事件捕获"><a href="#13-1-2-事件捕获" class="headerlink" title="13.1.2 事件捕获"></a>13.1.2 事件捕获</h4><p>不太具体的节点应该更早接收到事件，最具体的节点应该最后接收到事件</p><h4 id="13-1-3-DOM事件流"><a href="#13-1-3-DOM事件流" class="headerlink" title="13.1.3 DOM事件流"></a>13.1.3 DOM事件流</h4><p>DOM2级事件规定的事件流包括三个阶段：事件捕获阶段，处于目标阶段和事件冒泡阶段</p><ul><li>事件捕获阶段：从Document查找到最具体元素之前的阶段</li><li>处于目标阶段：最具体元素</li><li>事件冒泡阶段：从最具体元素冒泡到Document</li></ul><h3 id="13-2-事件处理程序"><a href="#13-2-事件处理程序" class="headerlink" title="13.2 事件处理程序"></a>13.2 事件处理程序</h3><p>响应某个事件的函数叫做事件处理程序（或事件监听器）</p><p>事件处理程序的名字以“on”开头，如：click事件的时间处理程序就是onclick，load事件的时间处理程序就是onload。为事件指定处理程序的方式有很多</p><h4 id="12-2-1-HTML事件处理程序"><a href="#12-2-1-HTML事件处理程序" class="headerlink" title="12.2.1 HTML事件处理程序"></a>12.2.1 HTML事件处理程序</h4><p>这个操作是通过指定onclick特性并将一些JavaScript代码作为它的值来定义的。因此不能使用未转义的HTML语法字符。</p><p>HTML时间处理程序可以包含要执行的具体动作，也可以调用在页面其他地方定义的脚本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//具体动作</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"button"</span> <span class="attr">value</span> = <span class="string">"click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert('clicked')"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">//其他地方定义的脚本</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">showMessage</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">"Hello world!"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click Me"</span> <span class="attr">onclick</span>=<span class="string">"showMessage()"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="12-2-2-DOM0级事件处理程序"><a href="#12-2-2-DOM0级事件处理程序" class="headerlink" title="12.2.2 DOM0级事件处理程序"></a>12.2.2 DOM0级事件处理程序</h4><p>传统方式：将一个函数赋值给一个事件处理程序属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Clicked"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用DOM0级方法指定的时间处理程序被认为是元素的方法，因此这时的时间处理程序是在元素的作用域中运行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id);   <span class="comment">//"myBtn"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。</p><p>也可以删除事件处理程序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick=<span class="literal">null</span></span><br></pre></td></tr></table></figure><h4 id="13-2-3-DOM2级事件处理程序"><a href="#13-2-3-DOM2级事件处理程序" class="headerlink" title="13.2.3 DOM2级事件处理程序"></a>13.2.3 DOM2级事件处理程序</h4><p>处理指定事件处理程序：<strong>addEventListener()</strong></p><p>删除指定事件处理程序：<strong>removeEventListener()</strong></p><p>都接受3个参数：要处理的事件名，作为事件处理程序的函数，一个布尔值（true捕获阶段调用，false冒泡阶段调用）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   <span class="comment">//可以添加多个事件处理程序</span></span><br><span class="line">    alert(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>通过addEventListener添加的事件处理程序只能通过removeEventListener()来移除，移除时传入的参数与添加时相同，但像上面代码中的匿名函数无法被删除。</p><p>大多数情况下都是将事件处理程序添加到事件流的冒泡阶段</p><h4 id="13-2-4-IE事件处理程序"><a href="#13-2-4-IE事件处理程序" class="headerlink" title="13.2.4 IE事件处理程序"></a>13.2.4 IE事件处理程序</h4><p>两个类似的方法：attachEvent(),detachEvent()</p><p>主要区别在于这两个方法的事件处理程序会在全局作用域中运行，this等于window</p><h3 id="13-3-事件对象"><a href="#13-3-事件对象" class="headerlink" title="13.3 事件对象"></a>13.3 事件对象</h3><p>在触发DOM上的某个对象时，会产生一个事件对象event，这个对象包含着所有与事件有关的信息，包括事件的元素，事件的类型以及其他与特性时间相关的信息。</p><h4 id="13-3-1-DOM中的事件对象"><a href="#13-3-1-DOM中的事件对象" class="headerlink" title="13.3.1 DOM中的事件对象"></a>13.3.1 DOM中的事件对象</h4><p>兼容DOM的浏览器会将一个event对象传入到事件处理程序中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    alert(event.type); <span class="comment">//"click"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    alert(event.type);  <span class="comment">//"click"</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h5 id="target-currentTarget"><a href="#target-currentTarget" class="headerlink" title="target currentTarget"></a>target currentTarget</h5><p>在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标。如果直接将事件处理程序指定了目标元素，则三个值相同。如果把事件处理程序指定了目标元素的父节点中，则this,currentTarget指的是父节点，而target指的是目标元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&quot;myBtn&quot;);</span><br><span class="line">btn.onclick = function(event)&#123;</span><br><span class="line">    alert(this == event.currentTarget); //true</span><br><span class="line">    alert(this == event.target);        //true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.body.onclick = function(event)&#123;</span><br><span class="line">    alert(event.currentTarget == document.body);//true</span><br><span class="line">    alert(event.currentTarget == this); //true</span><br><span class="line">    alert(event.target == myBtn);  //true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h5><p>通过一个函数处理多个事件可以用type</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(event.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">            alert(<span class="string">"Clicked"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"mouseover"</span>:</span><br><span class="line">            event.target.style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"mouseout"</span>:</span><br><span class="line">            event.target.style.backgroundColor = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">break</span>;           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">btn.onclick = handler;</span><br><span class="line">btn.onmouseover = handler;</span><br><span class="line">btn.onmouseout = handler;</span><br></pre></td></tr></table></figure><h4 id="13-4-事件类型"><a href="#13-4-事件类型" class="headerlink" title="13.4 事件类型"></a>13.4 事件类型</h4><h4 id="13-5-内存性能-amp-amp-模拟事件"><a href="#13-5-内存性能-amp-amp-模拟事件" class="headerlink" title="13.5 内存性能&amp;&amp;模拟事件"></a>13.5 内存性能&amp;&amp;模拟事件</h4><h4 id="13-5-1-事件委托"><a href="#13-5-1-事件委托" class="headerlink" title="13.5.1  事件委托"></a>13.5.1  事件委托</h4><p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的事情。不需要给每个可单击的元素分别添加事件处理程序。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"palette"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:crimson"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:bisque"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:blueviolet"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:coral"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:chartreuse"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:darkolivegreen"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:cyan"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:#194738"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> uList = <span class="built_in">document</span>.querySelector(<span class="string">"ul"</span>);</span></span><br><span class="line"><span class="javascript">uList.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        thisLi = event.target;  <span class="comment">//获得用户实际点击的li</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(thisLi);</span></span><br><span class="line"><span class="javascript">         <span class="comment">//执行某些操作</span></span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="第十四章-表单脚本"><a href="#第十四章-表单脚本" class="headerlink" title="第十四章 表单脚本"></a>第十四章 表单脚本</h2><p>JavaScript最初的一个应用就是分担服务器处理表单的责任，打破处处依赖服务器的局面</p><h3 id="14-1-表单的基础知识"><a href="#14-1-表单的基础知识" class="headerlink" title="14.1 表单的基础知识"></a>14.1 表单的基础知识</h3><p>在HTML中，表单元素<form>，在javascript中，表单对应的则是HTMLFormElement类型。</form></p><p>一些除默认属性外的独特的属性和方法：</p><ul><li>acceptCharset:服务器能够处理的字符集，等价于HTML中的accept-charset特性</li><li>action 接受请求的URL，等价于HTML中的action特性</li><li>elements:表单中所有控件的集合</li><li>enctype:请求编码的类型</li><li>length:表单中控件的数量</li><li>method：要发送的HTTP请求类型（get,post)</li><li>name:表单的名称</li><li>reset():将所有表单域重置为默认值</li><li>submin():提交表单</li><li>target():用于发送请求和接受响应的窗口名称</li></ul><p>取得form元素引用的方式：</p><ul><li><p>将他看成和其他元素一样，添加id特性，然后使用getElementById()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"form1"</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过document.forms可以取得页面中所有表单，在这个集合中可以通过数组索引或name值来取得特定的表单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstForm = <span class="built_in">document</span>.forms[<span class="number">0</span>];   <span class="comment">//取得页面中第一个表单</span></span><br><span class="line"><span class="keyword">var</span> myForm = <span class="built_in">document</span>.forms[<span class="string">"form2"</span>];  <span class="comment">//取得页面中名称为"form2"的表单</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="14-1-1-提交表单"><a href="#14-1-1-提交表单" class="headerlink" title="14.1.1 提交表单"></a>14.1.1 提交表单</h4><h5 id="提交方法"><a href="#提交方法" class="headerlink" title="提交方法"></a>提交方法</h5><ol><li>使用<input>或<button>都可以定义提交按钮，只要将type特性设置为”submit”即可，而图像按钮则是通过将</button><input>的type特性设置为image来定义的 </li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"submit"</span> value=<span class="string">"Submit Form"</span></span><br><span class="line">&lt;button type=<span class="string">"submit"</span> value=<span class="string">"Submit Form"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;input type=<span class="string">"image"</span> src=<span class="string">"graphic.gif"</span>&gt;</span><br></pre></td></tr></table></figure><pre><code>只要表单中存在上面列出的任何一种按钮，那么在相应表单空间拥有焦点的情况下，按回车键就可以提交该表  单。 以这种方式提交表单，浏览器会在将请求发送给服务期之前触发submit事件。这样就有机会验证表单数据，并以此决定是否允许表单提交。</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</span><br><span class="line">EventUtil.addHandler(form,<span class="string">"submit"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//阻止默认事件</span></span><br><span class="line">    EventUtil.preventDefault(event);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>也可以在js中以编程方式调用submit方法来提交</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</span><br><span class="line">form.submit();</span><br></pre></td></tr></table></figure><p>以这种方式调用submit的方式提交表单不会触发submit事件，因此要先验证表单数据。</p></li></ol><h5 id="解决出现的问题"><a href="#解决出现的问题" class="headerlink" title="解决出现的问题"></a>解决出现的问题</h5><p>可能出现的最大问题就是重复提交表单：如果服务器长时间没反应用户可能会反复单击提交按钮会造成错误</p><p>解决方法：</p><ul><li>在第一次提交表单后就禁用提交按钮</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(form,<span class="string">"submit"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> btn = target.element[<span class="string">"submit-btn"</span>];</span><br><span class="line">    btn.disabled = ture;   </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能使用onclick来实现这个功能，因为无法确定submit和禁用事件的执行顺序。因此最好通过监听submit事件来实现。</span></span><br></pre></td></tr></table></figure><ul><li>利用onsubmit事件处理程序取消后续的表单提交操作</li></ul><h4 id="14-1-2-重置表单"><a href="#14-1-2-重置表单" class="headerlink" title="14.1.2 重置表单"></a>14.1.2 重置表单</h4><p>在用户单击重置按钮时，表单会被重置。使用type特性值为“reset”的input或button都可以创建重置按钮。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"reset"</span> value=<span class="string">"Reset Form"</span>&gt;</span><br><span class="line">&lt;button type=<span class="string">"reset"</span>&gt;Reset Form&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>重置表单时，所有表单字段都会恢复到页面刚加载完毕的初始值。</p><p>用户单击重置按钮重置表单时，会触发reset事件，利用这个机会，可以在必要时取消重置操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var form = document.getElementById(&quot;myForm&quot;);</span><br><span class="line">EventUtil.addHandler(form,&quot;reset&quot;,function(event)&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    </span><br><span class="line">    //阻止默认事件</span><br><span class="line">    EventUtil.preventDefault(event);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>与提交表单一样，重置也可以使用js,form.reset()即可</p><p>不一样的是，使用js调用也会像单击重置按钮一样触发reset事件。</p><h4 id="14-1-3-表单字段"><a href="#14-1-3-表单字段" class="headerlink" title="14.1.3 表单字段"></a>14.1.3 表单字段</h4><p>每个表单都有elements属性，该属性是表单中所有表单字段的集合。elements集合是一个有序列表，其中包含着表单中的所有字段，例如input textarea button filedset。表单字段在集合中的顺序，与他们出现在标记中的顺序相同，可以按照位置和name特性来访问他们。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> field1 = form.elements[<span class="number">0</span>]; <span class="comment">//取得表单中第一个字段</span></span><br><span class="line"><span class="keyword">var</span> field2 = form.elements[<span class="string">"textbox1"</span>] <span class="comment">//去的表单中名为”textbox1"的字段</span></span><br><span class="line"><span class="keyword">var</span> fieldCout = form.elements.length;  <span class="comment">//取得表单中包含的字段数量</span></span><br></pre></td></tr></table></figure><p>如果有多个表单控件都在使用一个name(如单选按钮)，那么就会返回一个以该name命名的一个NodeList。</p><h5 id="共用的表单字段属性"><a href="#共用的表单字段属性" class="headerlink" title="共用的表单字段属性"></a>共用的表单字段属性</h5><p>除了fieldset元素之外，所有表单字段都拥有相同的一组属性。表单字段共有的属性如下：</p><ul><li>disabled:布尔值，表示当前字段是否被禁用</li><li>form:指向当前字段所属表单的指针（只读）</li><li>name:当前字段的名称</li><li>readOnly:布尔值，表示当前字段是否只读</li><li>tabIndex:表示当前字段的切换序号</li><li>type:当前字段的类型（checkbox,radio)</li><li>value:当前字段将被提交给服务器的值，对于文件字段来说这个属性只读，包含文件在计算机中的路径。</li></ul><p>除了form属性，可以通过JS来修改其他任何属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</span><br><span class="line"><span class="keyword">var</span> field = form.elements[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">field.value=<span class="string">"Another value"</span>;</span><br><span class="line">alert(field.form === form)  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">field.disabled=ture;<span class="comment">//禁用当前字段</span></span><br></pre></td></tr></table></figure><h5 id="共有的表单字段方法"><a href="#共有的表单字段方法" class="headerlink" title="共有的表单字段方法"></a>共有的表单字段方法</h5><p>每个表单字段都有两个方法：focus()和blur()。</p><p><strong>focus：</strong>将浏览器的焦点设置到表单字段，即激活表单字段。</p><p>例如，可以在页面加载完毕后，将焦点转移到表单的第一个字段。（监听load事件，并在事件发生时在表单的第一个字段上调用focus方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>,<span class="string">"load"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="number">0</span>].focus();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果上述表单中第一个表单字段是input,并且type特性的值为hidden，则上述代码会导致错误。css的display和visibility属性也会导致错误</span></span><br></pre></td></tr></table></figure><p>HTML5新增autofocus属性。不用js也能自动移动焦点</p><p>input type=”text” autofocus</p><p><strong>blur:</strong> 从元素中移走焦点</p><p>调用blur()方法时，并不会把焦点转移到某个特定的元素上，仅仅是将焦点从调用这个方法的元素上面移走。</p><h5 id="共用的表单字段事件"><a href="#共用的表单字段事件" class="headerlink" title="共用的表单字段事件"></a>共用的表单字段事件</h5><p>除了支持鼠标，键盘，更改和HTML时间之外，所有的表单都支持下列三个事件：</p><ul><li>blur:当前字段失去焦点时触发</li><li>change:对于input和textarea元素，失去焦点且value值改变时触发；对于select元素，在选项值改变时触发</li><li>focus：当前字段获得焦点时触发</li></ul><h3 id="14-2-文本框脚本"><a href="#14-2-文本框脚本" class="headerlink" title="14.2 文本框脚本"></a>14.2 文本框脚本</h3><p>input 单行文本框</p><ul><li>表现文本框必须将input元素的type特性设置为text</li><li>size：指定文本框中能够显示的字符数</li><li>value:设置文本框的初始值</li><li>maxlength：指定文本框个可以接受的最大字符数</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">size</span>=<span class="string">"25"</span> <span class="attr">maxlength</span>=<span class="string">"50"</span> <span class="attr">value</span>=<span class="string">"initial value"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><textarea> 多行文本框</textarea></p><ul><li>rows：指定文本框的字符行数</li><li>cols：指定文本框的字符列数</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"25"</span> <span class="attr">cols</span>=<span class="string">"5"</span>&gt;</span>inital value<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>两种文本框都会将用户输入的内容保存在value属性中，可以通过这个属性来读取和设置文本框的值。</p><h4 id="14-2-1-选择文本"><a href="#14-2-1-选择文本" class="headerlink" title="14.2.1  选择文本"></a>14.2.1  选择文本</h4><p>上述两种文本框都支持select()方法，这个方法用于选择文本框中的所有文本。调用select()方法是，大多数浏览器会将焦点设置到文本框中。</p><p>在文本获得焦点是选择所有文本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(textbox,<span class="string">"focus"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">    </span><br><span class="line">    target.select();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="选择事件"><a href="#选择事件" class="headerlink" title="选择事件"></a>选择事件</h5><p>在选择了文本框的文本后，就会触发select事件。用户选择了文本或者调用select方法都会触发select事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(textbox,<span class="string">"select"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">    </span><br><span class="line">    alert(target.value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="取得选择的文本"><a href="#取得选择的文本" class="headerlink" title="取得选择的文本"></a>取得选择的文本</h5><p>HTML通过扩展方案以便顺利取得选择的文本。</p><p>添加两个属性：selectionStart  selectionEnd</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSelectedText</span>(<span class="params">textbox</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> textbox.value.substring(textbox.selectionStart,textbox.selectionEnd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="选择部分文本"><a href="#选择部分文本" class="headerlink" title="选择部分文本"></a>选择部分文本</h5><p>方法：setSelectionRange()</p><p>参数：要选择的第一个字符的索引和最后一个字符之后的字符的索引</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">textbox.value = <span class="string">"Hello world"</span>;</span><br><span class="line"></span><br><span class="line">textbox.setSelectionRange(<span class="number">0</span>,textbox.value.length);<span class="comment">//Hello world</span></span><br><span class="line">textbox.setSelectionRange(<span class="number">0</span>,<span class="number">3</span>) <span class="comment">//Hel</span></span><br></pre></td></tr></table></figure><p>要见到选择的文本必须在调用该方法之前或者之后立即将焦点设置到文本框</p><h4 id="14-2-2-过滤输入"><a href="#14-2-2-过滤输入" class="headerlink" title="14.2.2 过滤输入"></a>14.2.2 过滤输入</h4><h5 id="屏蔽字符"><a href="#屏蔽字符" class="headerlink" title="屏蔽字符"></a>屏蔽字符</h5><p>屏蔽所有按键操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(textbox,<span class="string">"keypress"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    EventUtil.preventDefault(event);   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>屏蔽特定的字符：检测keypress事件对应的字符编码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只允许用户输入数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正则表达式判断不是数字(\d)的字符要屏蔽同时这个字符编码大于9(不屏蔽非字符键)</span></span><br><span class="line"><span class="comment">//复制粘贴等组合需要用到ctrl键，需要确保用户没有按下ctrl键 !event.ctrlKey</span></span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(text,<span class="string">"keypress"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">    <span class="keyword">var</span> charCode = EventUtil.getCharCode(event);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!<span class="regexp">/\d/</span>.text(<span class="built_in">String</span>.fromCharCode(charcode))&amp;&amp;charCode&gt;<span class="number">9</span>&amp;&amp;!event.ctrlKey)&#123;  <span class="comment">//fromCharCode()将字符编码转换为字符串</span></span><br><span class="line">        EventUtil.preventDefault(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="操作剪贴板-424"><a href="#操作剪贴板-424" class="headerlink" title="操作剪贴板 424"></a>操作剪贴板 424</h5><h4 id="14-2-3-自动切换焦点-P426"><a href="#14-2-3-自动切换焦点-P426" class="headerlink" title="14.2.3 自动切换焦点 P426"></a>14.2.3 自动切换焦点 P426</h4><h4 id="14-2-4-HTML5约束验证API-P427"><a href="#14-2-4-HTML5约束验证API-P427" class="headerlink" title="14.2.4 HTML5约束验证API P427"></a>14.2.4 HTML5约束验证API P427</h4><h3 id="14-3-选择框脚本"><a href="#14-3-选择框脚本" class="headerlink" title="14.3 选择框脚本"></a>14.3 选择框脚本</h3><p>选择框脚本是通过<select>和<option>元素创建的。</option></select></p><p>HTMLSelectElement类型特有的属性和方法：</p><ul><li>add(newOption,relOption):向控件插入新<option>元素，位置在相关项(relOption)之前</option></li><li>multiple:布尔值，是否允许多项选择；允许：type:select-multiple; 不允许：type:select-one;</li><li>options:控件中所有<option>元素的HTMLCollection</option></li><li>remove(index):移除给定位置的选项</li><li>selectedIndex:基于0的选中项的索引，如果没有则为1.多选空间只保存选中项中第一项的索引</li><li>size:选择框中可见的行数</li></ul><p>type属性由multiple决定</p><p>value属性由当前选择项决定（1.没有选中项为空字符串 2.有选中项等于其value值 3.选中项没有value值等于文本值 4.有多个选中项根据2.3取第一个选中项的值）</p><p>每个<option>元素都有一个HTMLOptionElement对象。属性如下：</option></p><ul><li>index:当前选项在options集合中的索引</li><li>label:当前选项的标签</li><li>selected:布尔值，表示当前选项是否被选中</li><li>text:选项的文本</li><li>value:选项的值</li></ul><h4 id="14-3-1-选择选项"><a href="#14-3-1-选择选项" class="headerlink" title="14.3.1 选择选项"></a>14.3.1 选择选项</h4><p>对于只允许选择一项的选择框，访问选择项的最简单方式，就是使用选择框的selectedIndex属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selectedOption = selectbox.options[selectbox.selectedIndex];</span><br></pre></td></tr></table></figure><p>对于多选的选择框，可以循环遍历选项集合，测试每个选项的selected属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSelectedOptions</span>(<span class="params">selectbox</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">var</span> option = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=selectbox.options.length;i&lt;len;i++)&#123;</span><br><span class="line">        option = selectbox.options[i];</span><br><span class="line">        <span class="keyword">if</span>(option.selected == <span class="literal">true</span>)&#123;</span><br><span class="line">            result.push(option[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-3-2-添加选项"><a href="#14-3-2-添加选项" class="headerlink" title="14.3.2 添加选项"></a>14.3.2 添加选项</h4><ol><li><p>使用DOM方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newOption = <span class="built_in">document</span>.createElement(<span class="string">"option"</span>);</span><br><span class="line">newOption.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Option text"</span>));</span><br><span class="line">newOption.setAttribute(<span class="string">"value"</span>,<span class="string">"Option value"</span>);</span><br><span class="line"></span><br><span class="line">selectbox.appendChild(newOption);</span><br></pre></td></tr></table></figure></li><li><p>使用option构造函数，兼容DOM的浏览器会返回一个<option>元素。接受两个参数，文本和值，值可选。</option></p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newOption = <span class="keyword">new</span> Option(<span class="string">"Option text"</span>,<span class="string">"Option Value"</span>);</span><br><span class="line">selectbox.appendChild(newOption);  <span class="comment">//IE8之前有问题</span></span><br></pre></td></tr></table></figure></code></pre></li><li><p>使用选择框的add方法。接受两个参数：要添加的项和位于新项之后的选项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newOption = <span class="keyword">new</span> Option(<span class="string">"Option text"</span>,<span class="string">"Option Value"</span>);</span><br><span class="line">selectbox.add(newOption,<span class="literal">undefined</span>);  <span class="comment">//最佳方案  undefined会让新选项位于列表最后</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="14-3-3-移除选项"><a href="#14-3-3-移除选项" class="headerlink" title="14.3.3 移除选项"></a>14.3.3 移除选项</h4><p>三种方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">selectbox.removeChild(selectbox.options[<span class="number">0</span>]);</span><br><span class="line">selectbox.remove(<span class="number">0</span>);<span class="comment">//接受一个参数，被移除项的索引</span></span><br><span class="line">selecrbox.options[<span class="number">0</span>]=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="14-3-4-移动和重排序"><a href="#14-3-4-移动和重排序" class="headerlink" title="14.3.4 移动和重排序"></a>14.3.4 移动和重排序</h4><p>移动:appendChild()传入一个已有的元素，会先从该元素的父节点中移除它，再把它添加到指定的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selectbox1 = <span class="built_in">document</span>.getElementById(<span class="string">"selLocations1"</span>);</span><br><span class="line"><span class="keyword">var</span> selectbox2 = <span class="built_in">document</span>.getElementById(<span class="string">"selLocations2"</span>);</span><br><span class="line"></span><br><span class="line">selectbox2.appendChild(selectbox1.options[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>重排序：insertBefore()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optionToMove = selectbox.options[<span class="number">1</span>];</span><br><span class="line">selectbox.insertBefore(optionToMove,selectbox.options[optionToMove.index<span class="number">-1</span>]);<span class="comment">//前移一个</span></span><br><span class="line">selectbox.insertBefore(optionToMove,selectbox.options[optionToMove.index+<span class="number">2</span>]);<span class="comment">//后移一个</span></span><br></pre></td></tr></table></figure><h3 id="14-4-表单序列化-P436"><a href="#14-4-表单序列化-P436" class="headerlink" title="14.4 表单序列化 P436"></a>14.4 表单序列化 P436</h3><h3 id="14-5-富文本编辑"><a href="#14-5-富文本编辑" class="headerlink" title="14.5 富文本编辑"></a>14.5 富文本编辑</h3><p>本质：在页面中嵌入一个包含HTML页面的iframe。通过设置designMode属性，这个空白的HTML可以被编辑，编辑的对象则是该页面<body>元素的HTML代码。</body></p><p>design属性有两个可能的值：off on  当设置为on时，整个文档都会变得可以编辑。</p><p>design属性只有在页面加载完才能被设定，因此需要使用onload事件处理程序来设置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"richedit"</span> <span class="attr">style</span>=<span class="string">"height:100px;width:100px;"</span> <span class="attr">src</span>=<span class="string">"blank.htm"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span> = <span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    EventUtil.addHandler(<span class="built_in">window</span>,<span class="string">"load"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        frames[<span class="string">"richedit"</span>].document.designMode = <span class="string">"on"</span>;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="14-5-1-使用contenteditable属性"><a href="#14-5-1-使用contenteditable属性" class="headerlink" title="14.5.1 使用contenteditable属性"></a>14.5.1 使用contenteditable属性</h4><p>把contenteditable属性应用给页面中的任何元素，然后用户就可以立即编辑该元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"editable"</span> id=<span class="string">"richedit"</span> contenteditable&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//js方法</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"richedit"</span>);</span><br><span class="line">div.contenteditable = <span class="literal">true</span>; <span class="comment">//true表示打开，false表示关闭，inherit表示从父元素继承</span></span><br></pre></td></tr></table></figure><h4 id="14-5-2-操作富文本"><a href="#14-5-2-操作富文本" class="headerlink" title="14.5.2 操作富文本"></a>14.5.2 操作富文本</h4><p>主要方式：document.execCommand()</p><p>参数：要执行的命令名称，浏览器是否为当前命令提供用户界面的一个布尔值，执行命令必须的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frames[<span class="string">"richedit"</span>].document.execCommand(<span class="string">"bold"</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">frames[<span class="string">"richedit"</span>].document.execCommand(<span class="string">"createlink"</span>,<span class="literal">false</span>,<span class="string">"http//www.wrox.com"</span>);</span><br></pre></td></tr></table></figure><h4 id="14-5-3-富文本选区"><a href="#14-5-3-富文本选区" class="headerlink" title="14.5.3 富文本选区"></a>14.5.3 富文本选区</h4><p>使用frame的getSelection()方法，可以确定实际选择的文本。返回一个表示当前选择文本的selection对象。</p><p>提供了一些方法，支持对选取的操作 P442</p><h4 id="14-5-4-表单与富文本"><a href="#14-5-4-表单与富文本" class="headerlink" title="14.5.4 表单与富文本"></a>14.5.4 表单与富文本</h4><p>富文本中的HTML不会被自动提交给服务器，需要手动来提取并提交。</p><p>通常添加一个隐藏表单字段，在提交表单之前，从iframe中提取出HTML，并插入隐藏的字段中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(form,<span class="string">"submit"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">    </span><br><span class="line">    target.elements[<span class="string">"comments"</span>].value = frames[<span class="string">"richedit"</span>].document.body.innerHTML;<span class="comment">//frame元素</span></span><br><span class="line">    target.elements[<span class="string">"comments"</span>].value = <span class="built_in">document</span>.getElementById(<span class="string">"richedit"</span>).innerHTML <span class="comment">//contentditable元素</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
