<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>leetcode226反转二叉树</title>
      <link href="/2018/11/06/leetcode226%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/11/06/leetcode226%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>Invert Binary Tree</p><a id="more"></a><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwypqvxn6pj31cw0lkjsk.jpg" alt="img"></p><p>思路：</p><p>跟昨天的题一样都是很简单的递归思路，有进步的地方就是这次没有去看别人的代码啦hhhh</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">None</span>):</span><br><span class="line">            root.left,root.right = root.right,root.left</span><br><span class="line">            self.invertTree(root.left)</span><br><span class="line">            self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>代码是很简洁的三行，如果节点不为空先交换，然后再依次递归左子树和右子树</p><p>但是在写的过程中对于递归返回值理解不对，以为返回了这个函数就结束了，不知道该在哪里返回root，摸索中AC了。</p><p>递归的返回值应该是依次往上返回，最后一个返回空之后会回到上一个调用他的函数体中，然后返回这个节点，依次往上返回，最后回到最初调用的函数中，然后返回根节点root。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwypz9t4g6j30yq0f0teq.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 递归 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode617合并二叉树</title>
      <link href="/2018/11/05/leetcode617%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/11/05/leetcode617%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>617 合并二叉树</p><a id="more"></a><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p><p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p><p><img src="/var/folders/6p/_f33fscs7j316s490d30bm6c0000gn/T/abnerworks.Typora/image-20181105204933002.png" alt="image-20181105204933002"></p><p>解法就是用到了递归的思想，感觉还是搞不懂递归怎么用，这周多做几个递归的题目这周末整理一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span><span class="params">(self, t1, t2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="keyword">None</span>):</span><br><span class="line">            <span class="keyword">return</span> t2</span><br><span class="line">        <span class="keyword">if</span>(t2==<span class="keyword">None</span>):</span><br><span class="line">            <span class="keyword">return</span> t1</span><br><span class="line">        mergeT = TreeNode(t1.val+t2.val)</span><br><span class="line">        mergeT.left = self.mergeTrees(t1.left,t2.left)</span><br><span class="line">        mergeT.right = self.mergeTrees(t1.right,t2.right)</span><br><span class="line">        <span class="keyword">return</span> mergeT</span><br></pre></td></tr></table></figure><p>代码很简单，根据t1和t2的根节点创建新的二叉树的根节点</p><p>然后去分别合并左子树和右子树，最后返回</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.youtube.com/watch?v=EmVsf2sMNiU" target="_blank" rel="noopener">https://www.youtube.com/watch?v=EmVsf2sMNiU</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 递归 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode438找出同字母异序词</title>
      <link href="/2018/11/02/leetcode438%E6%89%BE%E5%87%BA%E5%90%8C%E5%AD%97%E6%AF%8D%E5%BC%82%E5%BA%8F%E8%AF%8D/"/>
      <url>/2018/11/02/leetcode438%E6%89%BE%E5%87%BA%E5%90%8C%E5%AD%97%E6%AF%8D%E5%BC%82%E5%BA%8F%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>找出一个字符串中另一个字符串的同字母异序词</p><a id="more"></a><p>Given a string <strong>s</strong> and a <strong>non-empty</strong> string <strong>p</strong>, find all the start indices of <strong>p</strong>‘s anagrams in <strong>s</strong>.</p><p>Strings consists of lowercase English letters only and the length of both strings <strong>s</strong> and <strong>p</strong> will not be larger than 20,100.</p><p>The order of output does not matter.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.</span><br><span class="line">The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力-o-n-2"><a href="#暴力-o-n-2" class="headerlink" title="暴力 ($(o(n^2))$)"></a>暴力 ($(o(n^2))$)</h4><p>能想到的就是最简单的思路，字符串转list，然后切片，排序，比较</p><p>但是超时了，先把代码贴上</p><p>但是也不知道是不是自己哪里写的不对&gt;&lt;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        s=list(s)</span><br><span class="line">        p=list(p)</span><br><span class="line">        p.sort()</span><br><span class="line">        result=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            print(i)</span><br><span class="line">            <span class="keyword">if</span>(s[i] <span class="keyword">in</span> p <span class="keyword">and</span> i+len(p)&lt;=len(s)):</span><br><span class="line">                c = s[i:i+len(p)]</span><br><span class="line">                c.sort()</span><br><span class="line">                <span class="keyword">if</span>(c == p):</span><br><span class="line">                    result.append(i)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><img src="/var/folders/6p/_f33fscs7j316s490d30bm6c0000gn/T/abnerworks.Typora/image-20181102215251167.png" alt="image-20181102215251167"></p><h4 id="他人的思路-o-n"><a href="#他人的思路-o-n" class="headerlink" title="他人的思路 (o(n))"></a>他人的思路 (o(n))</h4><p>把p压缩成一个hash表，然后遍历s，也保存一个hash表</p><p>当s表的值的总和小于lp时继续添加，等于时判断两个hash表是否相等</p><p>要注意，遍历s时的i始终比cs快了一步，也就是i始终指向cs保存的元素的下一个元素。</p><p>例 输入 “abab” “ab”</p><p>i=0 c={}</p><p>i=1 c={a:1}       (i指向b)</p><p>i=2 c={a:1,b:1} (i指向a)</p><p>所以要在循环结束后判断结束后的cs是否和cp相等，如果相等的话还要添加一个值。</p><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        ls, lp = len(s), len(p)       </span><br><span class="line">        cp = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lp):</span><br><span class="line">            <span class="keyword">if</span>(cp.has_key(p[i])):</span><br><span class="line">                cp[p[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cp[p[i]] = <span class="number">1</span></span><br><span class="line">        cs = dict();  </span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(ls):</span><br><span class="line">            l = sum(cs.values())</span><br><span class="line">            <span class="keyword">if</span>(l&lt;lp):</span><br><span class="line">                <span class="keyword">if</span>(cs.has_key(s[i])):</span><br><span class="line">                    cs[s[i]] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cs[s[i]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span>(cp == cs):</span><br><span class="line">                    ans.append(i-lp)</span><br><span class="line">                cs[s[i-lp]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span>(cs[s[i-lp]] == <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">del</span> cs[s[i-lp]]</span><br><span class="line">                <span class="keyword">if</span>(cs.has_key(s[i])):</span><br><span class="line">                    cs[s[i]] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cs[s[i]] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(cs==cp):      //i比hash表保存的值走的快了一步，最后一组没有进行比较</span><br><span class="line">            ans.append(ls-lp)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.youtube.com/watch?v=86fQQ7rVGxA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=86fQQ7rVGxA</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> sliding_window </category>
          
          <category> hash </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode283移动零</title>
      <link href="/2018/11/01/leetcode283%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
      <url>/2018/11/01/leetcode283%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<p>把数组中所有的零都移动到末尾，不改变其他元素的顺序，不用新的空间，尽可能的减少操作步骤</p><a id="more"></a><p>Given an array <code>nums</code>, write a function to move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>Note</strong>:</p><ol><li>You must do this <strong>in-place</strong> without making a copy of the array.</li><li>Minimize the total number of operations.</li></ol><p>思路：</p><p>交换</p><p>保存两个指针，一个指针j指向前面，另一个指针i向后遍历</p><p>当遍历到不为0的数时同前面指针所指的数据交换，然后j++</p><p>例子：</p><p>数据</p><p>1,3,0,2,0</p><p>step1: i,j都指向1,1不为0，j++     [1,3,0,2,0]</p><p>setp2:i,j都指向3，3不为0，j++   [1,3,0,2,0]</p><p>step3:i,j都指向0，j不变                [1,3,0,2,0]</p><p>step4:i指向2，j指向第一个0，交换，并且j++  [1,3,2,0,0]</p><p>step5:i指向0，不变  得到最后结果[1,3,2,0,0]</p><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        j=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>):</span><br><span class="line">                temp = nums[j]</span><br><span class="line">                nums[j] = nums[i]</span><br><span class="line">                nums[i] = temp</span><br><span class="line">                j=j+<span class="number">1</span></span><br><span class="line">            print(nums)</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mvvm</title>
      <link href="/2018/10/31/mvvm/"/>
      <url>/2018/10/31/mvvm/</url>
      
        <content type="html"><![CDATA[<p>软件体系结构MVVM</p><a id="more"></a><p>#背景</p><h3 id="mvc-model-view-controller"><a href="#mvc-model-view-controller" class="headerlink" title="mvc(model,view,controller)"></a>mvc(model,view,controller)</h3><h4 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h4><ul><li><p>视图：管理作为位图展示到屏幕上的图形和文字输出；</p></li><li><p>控制器：翻译用户的输入并依照用户的输入操作模型和视图；</p></li><li><p>模型：管理应用的行为和数据，响应数据请求（经常来自视图）和更新状态的指令（经常来自控制器）；</p><p><img src="https://raw.githubusercontent.com/Draveness/analyze/master/contents/architecture/images/mvx/Standard-MVC.jpg" alt="Standard-MV"></p><p>所有的通信都是单向的</p><p>View传送指令到Controller，Controller完成业务逻辑后要求Moder改变状态，Model将新的数据发送给View，用户得到反馈</p></li></ul><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><p>在 MVC 中，模型层可以单独工作，而视图层和控制器层都依赖与模型层中的数据。</p><p><img src="https://raw.githubusercontent.com/Draveness/analyze/master/contents/architecture/images/mvx/Essential-Dependencies-in-MVC.jpg" alt="Essential-Dependencies-in-MVC"></p><h4 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h4><p>分离展示层</p><p>GUI 应用程序由于其需要展示内容的特点，分为两个部分：一部分是用于展示内容的展示层（Presentation Layer），另一部分包含领域和数据逻辑的领域层（Domain Layer）。</p><p>MVC 最重要的目的并不是规定各个模块应该如何交互和联系，而是将原有的混乱的应用程序划分出合理的层级，把一团混乱的代码，按照展示层和领域层分成两个部分；</p><p>展示层对应MVC中的View(视图)和controller(控制器)，领域层对应模型层</p><h4 id="主导位置"><a href="#主导位置" class="headerlink" title="主导位置"></a>主导位置</h4><p>控制层。在MVC中，控制层占据主导地位，他决定用户的输入时如何被处理的。</p><p>模型层。模型都是被动的，只存储整个应用中的数据，信息的获取和更新都是由控制器来驱动</p><h4 id="实际应用的模型"><a href="#实际应用的模型" class="headerlink" title="实际应用的模型"></a>实际应用的模型</h4><p><img src="https://raw.githubusercontent.com/Draveness/analyze/master/contents/architecture/images/mvx/MVC-MVC.jpg" alt="MVC-MV"></p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>MVP是MVC的一个变种。</p><p><strong>两者之间最大的区别就是 MVP 中使用 Presenter 对视图和模型进行了解耦，它们彼此都对对方一无所知，沟通都通过 Presenter 进行。 </strong></p><p>在 MVP 中，Presenter 可以理解为松散的控制器，其中包含了视图的 UI 业务逻辑，所有从视图发出的事件，都会通过代理给 Presenter 进行处理；同时，Presenter 也通过视图暴露的接口与其进行通信。</p><p>所有的通信都是双向的，View和Moder之间不发生联系，都通过Presenter来传递</p><h4 id="被动视图"><a href="#被动视图" class="headerlink" title="被动视图"></a>被动视图</h4><p>在该变种的架构模式中，视图层是被动的，它本身不会改变自己的任何的状态，所有的状态都是通过 Presenter 来间接改变的。</p><p>被动的视图层就像前端中的 HTML 和 CSS 代码，只负责展示视图的结构和内容，本身不具有任何的逻辑</p><h5 id="依赖关系-1"><a href="#依赖关系-1" class="headerlink" title="依赖关系"></a>依赖关系</h5><p>视图层对于模型层没有任何的依赖</p><p><img src="https://raw.githubusercontent.com/Draveness/analyze/master/contents/architecture/images/mvx/Essential-Dependencies-in-Passive-View.jpg" alt="Essential-Dependencies-in-Passive-Vie"></p><h5 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h5><p><img src="https://raw.githubusercontent.com/Draveness/analyze/master/contents/architecture/images/mvx/Passive-View-with-Tags.jpg" alt="Passive-View-with-Tags"></p><ol><li>当视图接收到来自用户的事件时，会将事件转交给 Presenter 进行处理；</li><li>被动的视图向外界暴露接口，当需要更新视图时 Presenter 通过视图暴露的接口更新视图的内容；</li><li>Presenter 负责对模型进行操作和更新，在需要时取出其中存储的信息；</li><li>当模型层改变时，可以将改变的信息发送给<strong>观察者</strong> Presenter</li></ol><h5 id="监督控制器"><a href="#监督控制器" class="headerlink" title="监督控制器"></a>监督控制器</h5><p><img src="https://raw.githubusercontent.com/Draveness/analyze/master/contents/architecture/images/mvx/Supervising-Controller.jpg" alt="Supervising-Controller"></p><p>与被动视图中状态同步都需要<strong>显式</strong>的操作不同，监督控制器（Supervising Controller）就将部分需要显式同步的操作变成了隐式的</p><p>视图层接管了一部分的视图逻辑，同步简单的视图和模型的状态。</p><p>监督控制器只负责响应用户的输入以及一部分更加复杂的视图，模型状态同步工作</p><p>但是对于视图、模型的同步工作，监督控制器会尽可能地将所有简单的属性<strong>以数据绑定的形式声明在视图层中</strong>，类似于 Vue 中双向绑定的简化版本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-bind:href=<span class="string">"url"</span>&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>对于用户输入的处理，监督控制器的做法与标准 MVP 中的 Presenter 完全相同</p><h5 id="通信方式-1"><a href="#通信方式-1" class="headerlink" title="通信方式"></a>通信方式</h5><p>监督控制器中的视图和模型层之间增加了两者之间的耦合</p><p>监管器与视图和模型之间的关系没有发生改变，增加了模型和视图之间的依赖，通过数据绑定来实现。</p><h5 id="主导地位"><a href="#主导地位" class="headerlink" title="主导地位"></a>主导地位</h5><p>在MVP架构模式中，视图层在整个架构中都是占据主导地位的。</p><p><img src="https://raw.githubusercontent.com/Draveness/analyze/master/contents/architecture/images/mvx/Main-View-in-MVP.jpg" alt="Main-View-in-MVP"></p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>MVVM将presenter改名为ViewModel,基本上与MVP一致</p><p>唯一的区别是采用双向绑定，View的变动自动反应在ViewModel中，反之亦然。</p><h4 id="前端开发的问题"><a href="#前端开发的问题" class="headerlink" title="前端开发的问题"></a>前端开发的问题</h4><p>1、开发者在代码中大量调用相同的 DOM API, 处理繁琐 ，操作冗余，使得代码难以维护。</p><p>2、大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</p><p>3、当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 View 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</p><p>早期jquery 的出现就是为了前端能更简洁的操作DOM 而设计的，但它只解决了第一个问题，另外两个问题始终伴随着前端一直存在。 </p><h4 id="MVVM基本概念"><a href="#MVVM基本概念" class="headerlink" title="MVVM基本概念"></a>MVVM基本概念</h4><p>MVVM 由 Model,View,ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。 </p><p>ViewModel通过双向绑定把View层和Model层连接起来，使得View和Model之间的同步工作是完全自动的。开发者只需要关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由MVVM来统一管理。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020110.png" alt="img"></p><h5 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h5><p>MVVM中的核心问题就是ViewModel和和View的双向数据绑定</p><p>Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。</p><p>ViewModel 所封装出来的数据模型包括视图的状态和行为两部分</p><p>而 Model 层的数据模型是只包含状态的</p><p>在ViewModel层，开发者对来自后端的数据进行二次封装。View展示的数据是来自ViewModel而不是Model。完全解耦了View和Model。</p><p><strong>Vue.js 的双向数据绑定</strong></p><p>Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p><p><img src="/var/folders/6p/_f33fscs7j316s490d30bm6c0000gn/T/abnerworks.Typora/image-20181101212219101.png" alt="image-20181101212219101"></p><p><strong>Observer</strong> 数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现。</p><p><strong>Compile</strong> 指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。</p><p><strong>Watcher</strong> 订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。</p><p><strong>Dep</strong> 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。</p><h5 id="双向数据绑定的原理"><a href="#双向数据绑定的原理" class="headerlink" title="双向数据绑定的原理"></a>双向数据绑定的原理</h5><p>使用到的方法：对象的访问器属性（get,set)，事件监听（观察者模式）</p><p>极简的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> id=<span class="string">"a"</span>&gt;</span><br><span class="line">&lt;span id=<span class="string">"b"</span>&gt;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">'hello'</span>,&#123;</span><br><span class="line">    set:<span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;                       <span class="comment">//事件绑定的回调函数</span></span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'a'</span>).value = newVal;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'b'</span>).innerHTML = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'keyup'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;   <span class="comment">//事件监听器</span></span><br><span class="line">    obj.hello = e.target.value;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>文本框输入文字变化，span会同步显示相同的文字内容</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://draveness.me/mvx" target="_blank" rel="noopener">https://draveness.me/mvx</a></li><li></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1031Adversarial_Attacks</title>
      <link href="/2018/10/31/1031Adversarial-Attacks/"/>
      <url>/2018/10/31/1031Adversarial-Attacks/</url>
      
        <content type="html"><![CDATA[<h1 id="Threat-of-Adversarial-Attacks-on-Deep-Learning-in-Computer-Vision-A-Survey"><a href="#Threat-of-Adversarial-Attacks-on-Deep-Learning-in-Computer-Vision-A-Survey" class="headerlink" title="Threat of Adversarial Attacks on Deep Learning in Computer Vision: A Survey"></a>Threat of Adversarial Attacks on Deep Learning in Computer Vision: A Survey</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="Akhtar N, Mian A. Threat of adversarial attacks on deep learning in computer vision: A survey[J]. arXiv preprint arXiv:1801.00553, 2018.">1</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode169寻找出现次数最多的数</title>
      <link href="/2018/10/31/leetcode169MajorityElement/"/>
      <url>/2018/10/31/leetcode169MajorityElement/</url>
      
        <content type="html"><![CDATA[<p>在一个长度为n的数组中，寻找出现次数大于n/2的数<br><a id="more"></a></p><h2 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element"></a>169. Majority Element</h2><p>Given an array of size <em>n</em>, find the majority element. The majority element is the element that appears <strong>more than</strong>n/2times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array.</p><p>最直接的思路，用一个字典保存所有数出现的次数，当出现大于n/2的直接返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        d = dict()</span><br><span class="line">        l = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            <span class="keyword">if</span>(d.has_key(nums[i])):</span><br><span class="line">                d[nums[i]] = d[nums[i]]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[nums[i]] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span>(d[nums[i]]&gt;=l/<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br></pre></td></tr></table></figure><p>看到别人的思路，把数组排序，中间的值一定是出现次数大于等于2的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[len(nums)/<span class="number">2</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode160寻找链表交叉点</title>
      <link href="/2018/10/30/leetcode160%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E4%BA%A4%E5%8F%89%E7%82%B9/"/>
      <url>/2018/10/30/leetcode160%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E4%BA%A4%E5%8F%89%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>160寻找链表交叉点<br><a id="more"></a></p><h2 id="题目：-Intersection-of-Two-Linked-Lists"><a href="#题目：-Intersection-of-Two-Linked-Lists" class="headerlink" title="题目： Intersection of Two Linked Lists"></a>题目： Intersection of Two Linked Lists</h2><p>寻找两个链表相交的节点</p><p>提示：</p><ul><li><p>If the two linked lists have no intersection at all, return <code>null</code>.</p></li><li><p>The linked lists must retain their original structure after the function returns.</p></li><li><p>You may assume there are no cycles anywhere in the entire linked structure.</p></li><li><p>Your code should preferably run in O(n) time and use only O(1) memory.</p></li></ul><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwqitpkz5ij30o7053glu.jpg" alt="示例图"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果两个链表有交点，那么从交点开始算起他们的长度一定是相等的。</p><p>先得到两个链表的长度，然后把长的那个链表的前半部分截去（如果有交点一定不可能发生在长的这一段）</p><p>然后再一起遍历，如果有相同的节点则相交，否则没有</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        a = headA</span><br><span class="line">        b = headB</span><br><span class="line">        alen=<span class="number">0</span></span><br><span class="line">        blen=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="keyword">None</span>):</span><br><span class="line">            alen=alen+<span class="number">1</span></span><br><span class="line">            a=a.next</span><br><span class="line">        <span class="keyword">while</span>(b!=<span class="keyword">None</span>):</span><br><span class="line">            blen=blen+<span class="number">1</span></span><br><span class="line">            b=b.next</span><br><span class="line">        print(alen,blen)</span><br><span class="line">        a = headA</span><br><span class="line">        b = headB</span><br><span class="line">        <span class="keyword">if</span>(alen&gt;blen):        </span><br><span class="line">            i=<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;alen-blen):</span><br><span class="line">                a = a.next</span><br><span class="line">                i=i+<span class="number">1</span></span><br><span class="line">            print(i)</span><br><span class="line">        <span class="keyword">elif</span>(blen&gt;alen):     </span><br><span class="line">            j=<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;blen-alen):</span><br><span class="line">                b = b.next</span><br><span class="line">                j=j+<span class="number">1</span></span><br><span class="line">            print(j)</span><br><span class="line">        <span class="keyword">while</span> a != b:</span><br><span class="line">            a, b = a.next, b.next</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>flask前后端数据传递</title>
      <link href="/2018/10/29/flask%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
      <url>/2018/10/29/flask%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<p>flask前后端数据传递的问题<br><a id="more"></a></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h4 id="POST-GET"><a href="#POST-GET" class="headerlink" title="POST GET"></a>POST GET</h4><p><img src="http://upload-images.jianshu.io/upload_images/14649226-de7a037a74158ee3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="AJAX前端传送和接收"><a href="#AJAX前端传送和接收" class="headerlink" title="AJAX前端传送和接收"></a>AJAX前端传送和接收</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">                url: &quot;/new&quot;,   //对应flask中的路由</span><br><span class="line">                type: &quot;POST&quot;, //请求方法</span><br><span class="line">                data: &apos;hello&apos;,   //传送的数据</span><br><span class="line">                dataType: &quot;json&quot;, //传送的数据类型</span><br><span class="line">                success: function (data) &#123;  //成功得到返回数据后回调的函数</span><br><span class="line">                    console.log(data)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><h4 id="Flask后端接收处理和返回"><a href="#Flask后端接收处理和返回" class="headerlink" title="Flask后端接收处理和返回"></a>Flask后端接收处理和返回</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/new&apos;,methods=[&apos;POST&apos;])   //第一个参数是路由，第二个是请求方法</span><br><span class="line">def new():</span><br><span class="line">    recv_data = request.get_data()  //得到前端传送的数据</span><br><span class="line">    print(recv_data)</span><br><span class="line">    data = somefunction()   //对数据做某些处理</span><br><span class="line">    return data                   //返回数据</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flask </category>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python数据转换</title>
      <link href="/2018/10/29/python%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/"/>
      <url>/2018/10/29/python%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>简单介绍了python中的数据转换问题<br><a id="more"></a></p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><h4 id="int-函数"><a href="#int-函数" class="headerlink" title="int 函数"></a>int 函数</h4><ol><li>把符合数学格式的数字型字符串转换成整数</li><li>把浮点数转换成整数，但是只是简单的取整，而非四舍五入。<h4 id="float函数"><a href="#float函数" class="headerlink" title="float函数"></a>float函数</h4>将整数和字符串转换为浮点数<h4 id="str-函数"><a href="#str-函数" class="headerlink" title="str 函数"></a>str 函数</h4>将数字转换为字符<h4 id="list-和-tuple"><a href="#list-和-tuple" class="headerlink" title="list 和 tuple"></a>list 和 tuple</h4>tuple转list  list(tup)<br>list转tuple  tuple(list)<h4 id="String转list"><a href="#String转list" class="headerlink" title="String转list"></a>String转list</h4><h5 id="简单转换-list函数"><a href="#简单转换-list函数" class="headerlink" title="简单转换 list函数"></a>简单转换 list函数</h5>list(str)<br>将字符串中的每一个字母作为列表中的一个元素，空格也算一个元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hi = &quot;hi world&quot;</span><br><span class="line">list(hi)</span><br><span class="line">[&apos;h&apos;,&apos;i&apos;,&apos; &apos;,&apos;w&apos;,&apos;o&apos;,&apos;r,&apos;,&apos;l&apos;,&apos;d&apos;]</span><br></pre></td></tr></table></figure></li></ol><h5 id="指定分隔符"><a href="#指定分隔符" class="headerlink" title="指定分隔符"></a>指定分隔符</h5><p>split<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;hello,world&quot;</span><br><span class="line">slist = s.split(&quot;,&quot;)</span><br><span class="line">//[&apos;hello&apos;,&apos;world&apos;]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js数据转换</title>
      <link href="/2018/10/29/js%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/"/>
      <url>/2018/10/29/js%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>最近第一次写前后端数据的互传，遇到了很多数据类型的转换，每次都记不住然后再查，先总结一下JS的转换问题，Python的转换问题后面补上<br><a id="more"></a></p><h4 id="查看数据类型-typeof"><a href="#查看数据类型-typeof" class="headerlink" title="查看数据类型 typeof()"></a>查看数据类型 typeof()</h4><p>JS中一共有5种简单的数据类型：Undifined,Null,Boolean,Number,String<br>其他引用类型：<br>Object(Array,Date,RegExp,Function)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof //在js中用于检查数据类型</span><br><span class="line">var message = &apos;hello world&apos;;</span><br><span class="line">console.log(typeof(message));</span><br></pre></td></tr></table></figure></p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><table><thead><tr><th>转数字</th><th>转数组</th><th>其他类型转字符串</th></tr></thead><tbody><tr><td>parseInt(str)      转整数</td><td>str.split(“,”)</td><td>toString()</td></tr><tr><td>parseFloat(str)  转浮点数</td><td></td></tr></tbody></table><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组转字符串  arr.join(“ “)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.join(&quot;-&quot;)  //引号内是分隔符</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML笔记</title>
      <link href="/2018/10/29/HTML/"/>
      <url>/2018/10/29/HTML/</url>
      
        <content type="html"><![CDATA[<p>很少的一些html中的笔记<br><a id="more"></a></p><h2 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h2><h2 id="lt-p"><a href="#lt-p" class="headerlink" title="\&lt;p/>"></a>\&lt;p/></h2><p>p标签内的文字自动换行设置:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">word-break</span><span class="selector-pseudo">:normal</span>;</span><br><span class="line"><span class="selector-tag">white-space</span><span class="selector-pseudo">:pre-warp</span>;</span><br><span class="line"><span class="selector-tag">word-wrapL</span><span class="selector-pseudo">:break-word</span>;</span><br></pre></td></tr></table></figure><!-- more --><ol><li><p>word-break属性：</p><p> 在恰当的断字点进行换行。有三个值：normal(使用浏览器默认的换行规则)、break-all(允许单词内换行)、keep-all(只能在半角空格或连字符处换行)</p></li><li><p>white-space属性：</p><p>white-space属性设置如何处理元素内的空白。</p><p>这个属性声明建立布局中如何处理元素中的空白字符，有六个值：normal(默认。空白会被忽略)、pre(空白会被浏览器保留。其行为方式类似HTML代码中的<pre>标签)、</pre></p><p>nowrap（文本不会换行，文本会在同一行上继续，直到遇到<br>标签为止）、pre-wrap（保留空白符序列，但是正常的换行）、pre-line（合并空白符序列，但是保留空白      符）、inherit（规定应该从父元素继承white-space属性的值）;</p></li><li><p>word-wrap属性：</p><p>允许长单词换行到下一行；有两个值：normal（只允许在断字点换行）、break-word(在长单词或者URL地址内部进行换行)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS笔记</title>
      <link href="/2018/10/29/JS%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/10/29/JS%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>全部都是看红宝书时候记得笔记，十分杂乱<br><a id="more"></a></p><h2 id="第六章-面向对象的程序设计"><a href="#第六章-面向对象的程序设计" class="headerlink" title="第六章 面向对象的程序设计"></a>第六章 面向对象的程序设计</h2><h4 id="6-1-对象"><a href="#6-1-对象" class="headerlink" title="6.1 对象"></a>6.1 对象</h4><h5 id="6-1-1-理解对象"><a href="#6-1-1-理解对象" class="headerlink" title="6.1.1 理解对象"></a>6.1.1 理解对象</h5><p>无序属性的集合，其属性可以包含基本值，对象或者函数</p><ol><li>两种创建方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*第一种 创建Object实例*/</span><br><span class="line">var person = new Object();</span><br><span class="line">person.name = &quot;Tom&quot;;</span><br><span class="line">person.age = 29;</span><br><span class="line"></span><br><span class="line">person.sayName = function()&#123;</span><br><span class="line">    alert(person.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* 第二种 对象字面量*/</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">    name:&quot;Tom&quot;,</span><br><span class="line">    age:29,</span><br><span class="line">    </span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>对象的属性类型</li></ol><ul><li><p>数据属性</p><p>数据属性可以读取或者写入值，有四个可以描述属性行为的特性：</p><p>[[configurable]]<br>[[Enumerable]]<br>[[Writable]]<br>[[Value]]</p></li><li><p>访问器属性</p><p>不包含数据值，包含一对getter和setter函数</p><p>读取属性调用getter函数，写入属性调用setter函数</p><p>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">    _year:2004,</span><br><span class="line">    edition:1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(book,&quot;year&quot;,&#123;</span><br><span class="line">    get:function()&#123;</span><br><span class="line">        return this._year;</span><br><span class="line">    &#125;</span><br><span class="line">    set:function(newValue)&#123;</span><br><span class="line">        if(newValue&gt;2004)&#123;</span><br><span class="line">            this._year = newValue;</span><br><span class="line">            this.edition += newValue - 2004;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.year = 2005;</span><br><span class="line">alert(book.edition); //2</span><br></pre></td></tr></table></figure><h5 id="6-1-2-创建对象"><a href="#6-1-2-创建对象" class="headerlink" title="6.1.2 创建对象"></a>6.1.2 创建对象</h5><ol><li><p>工厂模式</p><p>用函数来封装以特定接口创建对象的细节</p><p>优点：抽象了具体过程<br><br>缺点：无法识别对象的类型</p></li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age,job)&#123;</span><br><span class="line">    var o = new Object;</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(o.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>构造函数模式</p><p> 创建自定义的构造函数，从而定义自定义对象类型的属性和方法 <br><br> 优点：可以识别对象的类型<br><br> 缺点:每个方法都要在每个实例上重新创建一遍</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(Tom,29)</span><br><span class="line"></span><br><span class="line">alert(person instanceof Person) //true</span><br></pre></td></tr></table></figure></li></ol><p>   解释构造函数：</p><p>   同其他函数的唯一区别：调用方式不同<br><br>   任何函数通过new操作符来调用都可以作为构造函数</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var person = new Person(&quot;Tom&quot;,29)</span><br><span class="line">person.sayName(); //Tom</span><br><span class="line"></span><br><span class="line">// 全局作用域中调用函数,this对象总指向global对象（在浏览器中就是window对象）</span><br><span class="line">Person(&quot;Ford&quot;,29)</span><br><span class="line">window.sayName();//Ford</span><br><span class="line"></span><br><span class="line">// 在另一个对象的作用域中调用 o和前面的person的属性是相同的</span><br><span class="line"></span><br><span class="line">var o = new Object();</span><br><span class="line">Person.call(o,&quot;Jack&quot;,29);</span><br><span class="line">o.sayName(); //Jack</span><br><span class="line"></span><br><span class="line">// o和person虽然有相同的属性，但是对象类型不同</span><br><span class="line">alert(o instanceof Person); //false</span><br><span class="line">alert(person instanceof Person); //true</span><br><span class="line"></span><br><span class="line">//想要尝试修改o的构造函数，这是错误的。因为构造函数是由原型指定的，如果试图修改o的原型也就是Object的原型，会导致所有的对象发生错误，因此js不允许做这样的修改。</span><br></pre></td></tr></table></figure><p><strong>2. 原型模型</strong></p><p>   每一个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，这个对象包含可以由特性类型的所有实例共享的属性和方法。</p><p>   prototype指向通过构造函数创建的对象实例的原型对象。</p><p>   优点：所有对象实例都可以共享它所包含的属性和方法<br></p><p>   缺点：</p><ol><li>忽略了构造函数传参，所有实例共享相同的默认值</li><li>对于引用值属性，修改一个实例所有实例都将被修改</li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    person.prototype.name = &quot;Tom&quot;;</span><br><span class="line">    person.prototype.age = 29;</span><br><span class="line">    person.prototype.sayName=function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line">person.sayName();//Tom</span><br><span class="line">var person2 = new Person();</span><br><span class="line"></span><br><span class="line">alert(person1.sayName == person2.sayName) //true</span><br></pre></td></tr></table></figure><p><strong>理解原型对象</strong></p><p>创建新函数就会根据一组特定的规则为该函数创建一个prototype属性，指向函数的原型对象。</p><p>函数的原型对象中有一个constructor属性，指向创建的自定义函数。</p><p>构造函数的实例中也有一个prototype属性，指向函数的原型对象。</p><p>关系如图所示:</p><p><img src="http://o7cqr8cfk.bkt.clouddn.com/public/16-11-10/6663492.jpg" alt="image"></p><p>注意：可以通过对象实例来访问保存在原型中的值，但是不能通过对象实例重写原型中的值。</p><p>如果在实例中添加一个跟原型对象中同名的属性值，那么该属性值会屏蔽掉原型中的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person1.name = &quot;Jack&quot;;</span><br><span class="line">person1.sayName();//Jack 屏蔽掉了原型中的值</span><br><span class="line">person2.sayName();//Tom 原型中的值</span><br></pre></td></tr></table></figure><p><strong>原型的动态性</strong></p><p>对原型所做的任何修改都可以在实例上体现出来<br><br>因为实例和原型的连接是一个指针,实例可以通过该指针在原型中找到新的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName=function()&#123;</span><br><span class="line">    alert(&quot;Tom&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.sayName();//Tom</span><br></pre></td></tr></table></figure><p>但是如果重写整个prototype对象，则相当于切断了实例与原型对象的联系，因为实例仍然指向最初的原型对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    Person.prototype.name=&quot;tom&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    sayHello : function()&#123;</span><br><span class="line">        console.log(&quot;Hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//person只能访问到旧原型中的属性，重写的原型无法访问</span><br><span class="line">console.log(person.name); //tom</span><br><span class="line">person.sayHello();        //error</span><br></pre></td></tr></table></figure><p><strong>3. 组合使用构造函数模式和原型模式</strong></p><p>构造函数模式用于定义不共享的实例属性，原型模式用于定义方法和共享的属性。</p><p>优点： 每个实例都会有自己的一份实力属性的副本，同时又共享者对方法的引用，节省了内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.friends = [&quot;Shelby&quot;,&quot;Court&quot;] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor:Person,</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&quot;Tom&quot;,29);</span><br><span class="line">var person2 = new Person(&quot;Jack&quot;,29);</span><br><span class="line"></span><br><span class="line">//对一个实例的引用属性的修改不会影响其他实例</span><br><span class="line">person1.friends.push(&quot;Mary&quot;);</span><br><span class="line">console.log(person1.friends); //[&quot;Shelby&quot;,&quot;Court&quot;,&quot;Mary&quot;]</span><br><span class="line">console.log(person2.friends);//[&quot;Shelby&quot;,&quot;Court&quot;]</span><br><span class="line"></span><br><span class="line">//共享方法</span><br><span class="line">console.log(person1.sayName==person2.sayName) //true</span><br></pre></td></tr></table></figure><h4 id="6-2-继承"><a href="#6-2-继承" class="headerlink" title="6.2 继承"></a>6.2 继承</h4><p>ECMAScript只支持实现继承，依靠原型链来实现</p><h5 id="6-2-1-原型链继承"><a href="#6-2-1-原型链继承" class="headerlink" title="6.2.1 原型链继承"></a>6.2.1 原型链继承</h5><p>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p><p>实现的本质：用一个新类型的实例来重写并且代替原型对象。</p><p>缺点：</p><ol><li>如果作为子类型原型对象的超类型实例中有引用类型，那么修改某一个对象的引用类型时所有对象的引用类型都将被修改。</li><li>创建子类型的实例时，不能像超类型的构造函数传参。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">    this.color = [&quot;red&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue=function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function subType()&#123;</span><br><span class="line">    this.subProperty = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line">subType.prototype.getSubValue = function()&#123;</span><br><span class="line">    return this.subProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new subType();</span><br><span class="line">var instance2 = new subType();</span><br><span class="line">console.log(instance1.getSuperValue); //true</span><br><span class="line"></span><br><span class="line">//缺点：修改1的color,2的color也会改变</span><br><span class="line">instance1.color.push(&quot;black&quot;);</span><br><span class="line">console.log(instance1.color);//[&quot;red&quot;,&quot;black&quot;]</span><br><span class="line">console.log(instance2.color);//[&quot;red&quot;,&quot;black&quot;]</span><br></pre></td></tr></table></figure><p>注意：使用原型链继承时不能用对象字面量来创建原型方法，这样会重写原型链，切断与超类的联系。</p><h5 id="6-2-2-借用构造函数"><a href="#6-2-2-借用构造函数" class="headerlink" title="6.2.2 借用构造函数"></a>6.2.2 借用构造函数</h5><p>基本思想:在子类型构造函数的内部调用超类型构造函数。</p><p>优点：解决了原型中包含引用类型值带来的问题<br><br>缺点: 无法实现函数复用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.color = [&quot;red&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subProperty = false;</span><br><span class="line">    //可以传参</span><br><span class="line">    SuperType.call(this,&quot;Tom&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">var instance2 = new SubType();</span><br><span class="line"></span><br><span class="line">instance1.color.push(&quot;black&quot;);</span><br><span class="line">console.log(instance1.color); //[&quot;red&quot;,&quot;black&quot;]</span><br><span class="line">console.log(instance2.color); //[&quot;red&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//只继承了构造函数中的属性和方法，没有继承原型中的方法</span><br><span class="line">console.log(instance1.getSuperValue()) //error</span><br><span class="line"></span><br><span class="line">console.log(instance1 instanceof SuperType)//false</span><br></pre></td></tr></table></figure><h5 id="6-2-3组合继承"><a href="#6-2-3组合继承" class="headerlink" title="6.2.3组合继承"></a>6.2.3组合继承</h5><p>基本思路：原型链实现对原型属性和方法的继承<br>构造函数实现对实力属性的继承。</p><p>优点:实现了函数复用，又保证每个实例都有自己的属性</p><p>缺点:创建子类型时，会调用两次超类型的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.color=[&quot;red&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype=&#123;</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">    SuperType.call(this,name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType();</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType(&quot;Tom&quot;,&quot;29&quot;);</span><br><span class="line">var instance2 = new SubType(&quot;Jack&quot;,&quot;21&quot;);</span><br><span class="line"></span><br><span class="line">//修改引用类型属性不会影响其他实例</span><br><span class="line">instance1.color.push(&quot;black&quot;); </span><br><span class="line">console.log(instance1.color,instance2.color);//[&quot;red&quot;,&quot;black&quot;],[&quot;red&quot;]</span><br><span class="line"></span><br><span class="line">// 继承了超类型的原型方法,并且实现了复用</span><br><span class="line">console.log(instance1.sayName()); //Tom</span><br><span class="line">console.log(instance1.sayName==instance2.sayName); //True</span><br></pre></td></tr></table></figure><h5 id="6-2-4-原型式继承"><a href="#6-2-4-原型式继承" class="headerlink" title="6.2.4 原型式继承"></a>6.2.4 原型式继承</h5><p>想法：不必创建自定义类型，借助原型可以基于已有的对象创建新对象。</p><p>给出如下函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function object(o)&#123;</span><br><span class="line">    function F()&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br><span class="line">//本质是 object()对传入的对象执行了一次浅复制</span><br><span class="line"></span><br><span class="line">var person()&#123;</span><br><span class="line">    name:&quot;Tom&quot;,</span><br><span class="line">    friends:[&quot;Jack&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var anotherPerson = object(person);</span><br></pre></td></tr></table></figure></p><p>在ECMAsript 5新增了Object.create()方法来规范原型式继承。<br>接受两个参数（第二个可选):第一个参数是作为新对象原型的对象，第二个是为新对象额外定义属性的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name:&quot;Tom&quot;,</span><br><span class="line">    frineds:[&quot;Jack&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var anotherPerson = Object.create(person,&#123;name&#123;</span><br><span class="line">    value:&quot;Jack&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用场景：只想让一个对象与另一个对象保持类似的情况，没必要创建构造函数。</p><h5 id="6-3-5-寄生式继承"><a href="#6-3-5-寄生式继承" class="headerlink" title="6.3.5 寄生式继承"></a>6.3.5 寄生式继承</h5><p>思想:创建一个仅用于封装继承过程的函数，该函数内部以某种方式来增强对象，然后再返回对象。</p><p>缺点：</p><p>代码示范:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original)&#123;</span><br><span class="line">    var clone = Object.create(original);</span><br><span class="line">    clone.sayHi = function()&#123;</span><br><span class="line">        alert(&quot;HI&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//不一定是Object.create 任何可以返回同original相同的新对象的函数都可以</span><br></pre></td></tr></table></figure><h5 id="6-3-6-寄生组合式继承-最理想"><a href="#6-3-6-寄生组合式继承-最理想" class="headerlink" title="6.3.6 寄生组合式继承(最理想)"></a>6.3.6 寄生组合式继承(最理想)</h5><p>解决了组合式继承调用两次超类型构造函数的问题</p><p>基本模式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(SubType,SuperType)&#123;</span><br><span class="line">    var prototype = Object.create(SuperType.prototype);</span><br><span class="line">    prototype.constructor = SubType;</span><br><span class="line">    SubType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//修改前面组合继承的例子</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;Red&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype = &#123;</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">    SuperType.call(this,name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType,SuperType);</span><br><span class="line"></span><br><span class="line">var subtype =new SubType(&quot;Tom&quot;,21)</span><br><span class="line"></span><br><span class="line">//成功继承超类型原型对象中的方法</span><br><span class="line">console.log(subtype.sayName());//Tom</span><br></pre></td></tr></table></figure><h2 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h2><h2 id="第八章-迭代器和生成器-ES6"><a href="#第八章-迭代器和生成器-ES6" class="headerlink" title="第八章  迭代器和生成器 ES6"></a>第八章  迭代器和生成器 ES6</h2><h3 id="8-1-迭代器-amp-amp-生成器"><a href="#8-1-迭代器-amp-amp-生成器" class="headerlink" title="8.1 迭代器&amp;&amp;生成器"></a>8.1 迭代器&amp;&amp;生成器</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>是一种特殊对象，具有一些专门为迭代过程设计的专有接口。</p><ul><li>next() 每次调用返回一个结果对象{value,done} value表示下一个将要返回的值，done在没有更多数据返回时为true。</li><li>一个内部指针 用来指向当前集合中值的位置</li></ul><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器是一种返回迭代器的函数，通过function关键字后的星号（*）来表示，会用到新的关键字yield。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = createIterator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>在上述示例中，createIterator()前面的星号表明他是一个生成器，yield可以用来指定调用迭代器的next方法时返回值及返回顺序。</p><p>每当执行完一条yield语句后函数就会自动停止执行，直到再次调用迭代器的next()方法才会继续执行。</p><p>yield只能在生成器内部使用，在其他地方使用会导致程序抛出错误，生成器内部的函数也不行。</p><p><strong>其他创建方式</strong></p><ul><li>函数表达式  let createIterator = function *(items){}</li><li>生成器对象 let o ={ *createIterator(item){}}   let iterator = o.createIterator([1,2,3]);</li></ul><h3 id="8-2-可迭代对象和for-of循环"><a href="#8-2-可迭代对象和for-of循环" class="headerlink" title="8.2 可迭代对象和for-of循环"></a>8.2 可迭代对象和for-of循环</h3><p>可迭代对象具有symbol.iterator属性，是一种与迭代器密切相关的对象。</p><p>symbol.iterator通过指定的函数可以返回一个作用于附属对象的迭代器。</p><p>for-of循环每执行一次都会调用可迭代对象的next()方法，并将迭代器返回的结果对象的value属性存储在一个变量中，循环将持续执行这一过程直到返回对象的done属性的值为true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> values)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//依次输出1，2，3</span></span><br></pre></td></tr></table></figure><p>如果只需迭代数组或者集合中的值，用for-of循环代替for循环是个不错的选择。</p><h4 id="访问默认迭代器"><a href="#访问默认迭代器" class="headerlink" title="访问默认迭代器"></a>访问默认迭代器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> iterator = values[<span class="built_in">Symbol</span>.iterator]();</span><br></pre></td></tr></table></figure><p>由于具有symbol.iterator属性的对象都有默认的迭代器，因此可以用他来检测对象是否为可迭代对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">object</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] == <span class="string">"function"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建可迭代对象"><a href="#创建可迭代对象" class="headerlink" title="创建可迭代对象"></a>创建可迭代对象</h4><p>默认情况下，开发者定义的对象都是不可迭代对象，但可以通过给Symbol.iterator属性添加一个生成器，则可以将其变为可迭代对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = &#123;</span><br><span class="line">    items:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.items)&#123;</span><br><span class="line">    <span class="keyword">yield</span> item;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> collection)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1,2,3</span></span><br></pre></td></tr></table></figure><h3 id="8-3-内建迭代器"><a href="#8-3-内建迭代器" class="headerlink" title="8.3 内建迭代器"></a>8.3 内建迭代器</h3><h4 id="集合对象迭代器"><a href="#集合对象迭代器" class="headerlink" title="集合对象迭代器"></a>集合对象迭代器</h4><p>ES6中有三种类型的集合对象：数组，Map集合，Set集合</p><p>这三种对象都内建了三种迭代器：</p><ul><li>entries() 返回一个迭代器，其值为多个键值对。</li><li>values() 返回一个迭代器，其值为集合的值。</li><li>keys() 返回一个迭代器，其值为集合中的所有键名</li></ul><h5 id="entries-迭代器"><a href="#entries-迭代器" class="headerlink" title="entries()迭代器"></a>entries()迭代器</h5><p>每次调用next方法，entries()迭代器都会返回一个数组，数组中的两个元素分别表示每个元素的键和值。</p><ul><li>数组：第一个元素是数字类型的索引，第二哥元素是数组值</li><li>set集合：第一个和第二个元素都是值</li><li>map集合，第一个元素为键名，第二个元素为键值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>,<span class="number">5678</span>,<span class="number">9012</span>]);</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">"title"</span>,<span class="string">"ES6"</span>);</span><br><span class="line">data.set(<span class="string">"format"</span>,<span class="string">"ebook"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> color.entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entrt);  <span class="comment">//[0,"red"] [1,"green"] [2,"blue"]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> tracking.entried())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entrt); <span class="comment">//[1234,1234] [5678,5678] [9012,9012]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> data.entried())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry);  <span class="comment">//["title","ES6"] ["format","ebook"]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="values-迭代器"><a href="#values-迭代器" class="headerlink" title="values()迭代器"></a>values()迭代器</h5><p>调用value()迭代器会返回集合中所存的所有值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>,<span class="number">5678</span>,<span class="number">9012</span>]);</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">"title"</span>,<span class="string">"ES6"</span>);</span><br><span class="line">data.set(<span class="string">"format"</span>,<span class="string">"ebook"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> color.values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);  <span class="comment">//"red" "green" "blue"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> tracking.values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">//1234 5678 9012</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> data.values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);  <span class="comment">//"ES6" "ebook"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="keys迭代器"><a href="#keys迭代器" class="headerlink" title="keys迭代器"></a>keys迭代器</h5><p>keys迭代器会返回集合中存在的每一个键</p><ul><li>数组：返回数字类型的键，数组本身的其他属性不会被返回</li><li>set集合：键与值相同，返回和values相同的迭代器</li><li>map集合：返回每个独立的键</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>,<span class="number">5678</span>,<span class="number">9012</span>]);</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">"title"</span>,<span class="string">"ES6"</span>);</span><br><span class="line">data.set(<span class="string">"format"</span>,<span class="string">"ebook"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">of</span> colors.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);   <span class="comment">//0 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">of</span> tracking.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);   <span class="comment">//1234,5678,9012</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">of</span> data.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);   <span class="comment">//"title" "format"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不同集合类型的默认迭代器"><a href="#不同集合类型的默认迭代器" class="headerlink" title="不同集合类型的默认迭代器"></a>不同集合类型的默认迭代器</h5><p>每个集合类型都有一个默认的迭代器，在for-of循环中，如果没有显示指定则使用默认的迭代器。</p><p>数组和set组合的默认迭代器是values()方法，Map集合的默认迭代器是entries()方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>,<span class="number">5678</span>,<span class="number">9012</span>]);</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">"title"</span>,<span class="string">"ES6"</span>);</span><br><span class="line">data.set(<span class="string">"format"</span>,<span class="string">"ebook"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> color)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);  <span class="comment">//"red" "green" "blue"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> tracking)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);  <span class="comment">//1234 5678 9012</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> data)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry);  <span class="comment">//["title","ES6]  ["format","ebook"]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解构语法使map访问更简单</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [value,key] <span class="keyword">of</span> data)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value+<span class="string">","</span>+key)  <span class="comment">//"title,ES6"  "format,ebook"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串迭代器"><a href="#字符串迭代器" class="headerlink" title="字符串迭代器"></a>字符串迭代器</h4><p>解决双字节字符问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"A 𠮷 B"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> message)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//(空)</span></span><br><span class="line"><span class="comment">//𠮷</span></span><br><span class="line"><span class="comment">//(空)</span></span><br><span class="line"><span class="comment">//B</span></span><br></pre></td></tr></table></figure><h4 id="NodeList迭代器"><a href="#NodeList迭代器" class="headerlink" title="NodeList迭代器"></a>NodeList迭代器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> div <span class="keyword">of</span> divs)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(div.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="展开运算符与非数组可迭代对象"><a href="#展开运算符与非数组可迭代对象" class="headerlink" title="展开运算符与非数组可迭代对象"></a>展开运算符与非数组可迭代对象</h4><p>展开运算符可以操作所有可迭代对象，并根据默认迭代器来选取要引用的值，从迭代器读取所有值，然后按照返回顺序将他们依次插入到数组中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]),</span><br><span class="line">    array = [...Set];</span><br><span class="line"><span class="built_in">console</span>.log(array);    <span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">"name"</span>,<span class="string">"Nicholas"</span>],[<span class="string">"ages"</span>,<span class="number">25</span>]]),</span><br><span class="line">    array = [...map];</span><br><span class="line"><span class="built_in">console</span>.log(array);   <span class="comment">//[["name","Nicholas"],["ages",25]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在数组字面量中可以多次使用展开运算符，将可迭代对象中的多个元素依次插入新数组中，替换原来展开运算符所在的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> smallNumber = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    bigNumber = [<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>],</span><br><span class="line">    allNumber = [<span class="number">0</span>,...smallNumber,...bigNumber];</span><br><span class="line"><span class="built_in">console</span>.log(allNumber.length); <span class="comment">//7</span></span><br><span class="line"><span class="built_in">console</span>.log(allNumber); <span class="comment">//[0,1,2,3,100,101,102]</span></span><br></pre></td></tr></table></figure><p>将可迭代对象转换为数组，最简单的方法就是使用展开运算符。可以将字符串中的每一个字符存入新数组中，可以刻将nodeList对象中的每一个节点存入新数组中。</p><h3 id="8-4-高级迭代器功能"><a href="#8-4-高级迭代器功能" class="headerlink" title="8.4 高级迭代器功能"></a>8.4 高级迭代器功能</h3><h4 id="给迭代器传递参数"><a href="#给迭代器传递参数" class="headerlink" title="给迭代器传递参数"></a>给迭代器传递参数</h4><p>如果给迭代器的next()方法传递参数，则这个参数的值就会替代生成器内部上一条yield语句的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span>;   <span class="comment">//4+2</span></span><br><span class="line">    <span class="keyword">yield</span> second+<span class="number">3</span>;   <span class="comment">//5+3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">//&#123;value:1,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>)); <span class="comment">//&#123;value:6,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">5</span>)); <span class="comment">//&#123;value:8,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">//&#123;value:undefined,done:true&#125;</span></span><br></pre></td></tr></table></figure><h4 id="生成器返回语句"><a href="#生成器返回语句" class="headerlink" title="生成器返回语句"></a>生成器返回语句</h4><p>生成器也是函数，因此可以通过return语句提前退出函数执行。</p><p>在生成器中，return表示所有操作已经完成，属性done被设置为true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">//&#123;value:1,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">//&#123;value:42,done:true&#125;</span></span><br></pre></td></tr></table></figure><p>展开运算符与for-of循环语句会直接忽略通过return语句指定的任何返回值，因为只要done一变成true就立即停止读取其他的值。</p><h4 id="委托生成器"><a href="#委托生成器" class="headerlink" title="委托生成器"></a>委托生成器</h4><p>将两个迭代器合二为一，创建一个生成器，再给yield语句添加星号，就可以将生成数据的过程委托给其他迭代器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumberItetator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createColorIterator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"red"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"green"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> *createNumberIterator();</span><br><span class="line">    <span class="keyword">yield</span> *createColorIterator();</span><br><span class="line">    <span class="keyword">yield</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = createCombinedIterator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:1,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:2,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:"red",done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:"green",done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:true,done:false&#125;</span></span><br></pre></td></tr></table></figure><p>每一次调用next方法就会委托相应的迭代器生成相应的值，直到迭代器无法返回更多的值，此时执行最后一条yield语句并返回true。</p><h3 id="8-5-异步任务执行"><a href="#8-5-异步任务执行" class="headerlink" title="8.5 异步任务执行"></a>8.5 异步任务执行</h3><h4 id="8-5-1-简单任务执行器"><a href="#8-5-1-简单任务执行器" class="headerlink" title="8.5.1 简单任务执行器"></a>8.5.1 简单任务执行器</h4><p>yield语句会暂停当前函数的执行过程并等待下一次调用next()方法。因此可以创建一个函数，在函数中调用生成器生成相应的迭代器，从而可以不用回调函数实现异步调用next()。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> task = taskDef();</span><br><span class="line">    <span class="keyword">let</span> result = task.next();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环调用next()的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//如果任务未完成则继续执行</span></span><br><span class="line">        <span class="keyword">if</span>(!result.done)&#123;</span><br><span class="line">            result = task.next();</span><br><span class="line">            step();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><h4 id="8-5-2-像任务执行器传递数据"><a href="#8-5-2-像任务执行器传递数据" class="headerlink" title="8.5.2 像任务执行器传递数据"></a>8.5.2 像任务执行器传递数据</h4><p>传递数据最简单的方法是，把yield返回的值传入下一次next()方法的调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上述代码中修改传入的生成器函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span>); <span class="comment">//1</span></span><br><span class="line">    value = <span class="keyword">yield</span> value+<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">//4</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="8-5-3-异步任务执行器"><a href="#8-5-3-异步任务执行器" class="headerlink" title="8.5.3 异步任务执行器"></a>8.5.3 异步任务执行器</h4><p>等待异步过程时，任务执行器需要知晓回调函数是什么以及如何使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//返回一个异步函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                callback(<span class="literal">null</span>, <span class="string">"Hello"</span>);</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> task = taskDef();</span><br><span class="line">        <span class="keyword">let</span> result = task.next();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">                <span class="comment">//如果result.value是一个函数，则传入一个回调函数作为参数来调用</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span>  result.value === <span class="string">"function"</span>) &#123;</span><br><span class="line">                    result.value(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                            result = task.throw(err);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        result = task.next(data);</span><br><span class="line">                        step();</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="comment">//如果不是函数则直接把值传入next方法</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = task.next(result.value);</span><br><span class="line">                    step();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">        value = <span class="keyword">yield</span> fetchData();</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"world"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出  一秒钟后连续输出hello world</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以和循环配合，循环输出</span></span><br><span class="line"></span><br><span class="line">    run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">yield</span> fetchData(<span class="string">"hello"</span>+i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="第十章-DOM"><a href="#第十章-DOM" class="headerlink" title="第十章 DOM"></a>第十章 DOM</h2><p>DOM(文档对象模型)是针对HTML和XML文档的一个API（应用程序编程接口）</p><h3 id="10-1-节点层次"><a href="#10-1-节点层次" class="headerlink" title="10.1 节点层次"></a>10.1 节点层次</h3><p>DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构</p><h4 id="10-1-1-Node类型"><a href="#10-1-1-Node类型" class="headerlink" title="10.1.1 Node类型"></a>10.1.1 Node类型</h4><p>每个节点都有一个nodeType属性，用于表明节点的类型</p><h5 id="nodeName和nodeValue属性"><a href="#nodeName和nodeValue属性" class="headerlink" title="nodeName和nodeValue属性"></a><strong>nodeName和nodeValue属性</strong></h5><p>这两个属性的值完全取决于节点的类型</p><h5 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a><strong>节点关系</strong></h5><p>节点间的各种关系可以用传统的家族关系来描述：在html中，可以将body看成是html的子元素，html是body的父元素；body是head的同胞元素。</p><ul><li><p>每个节点都有一个<strong>childNodes</strong>属性，其中保存着一个NodeList对象（NodeList是一个类数组对象，并不是Array的实例，独特之处在于他是基于DOM结构动态执行查询的结果，能够自动反应DOM结构的变化）</p><pre><code>访问方式： </code></pre></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstChild = someNode.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> secondChild = someNode.childNodes.item(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> count = someNode.childNodes.length;<span class="comment">//表示的是访问这一刻NodeList包含的节点数量</span></span><br></pre></td></tr></table></figure><p>可以通过<strong>Aarray.prototype.slice()</strong>方法将NodeList转化为数组（IE8以下不支持)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">covertToArray</span>(<span class="params">nodes</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> array = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">       array = <span class="built_in">Array</span>.prototype.slice.call(nodes);</span><br><span class="line">   &#125;<span class="keyword">catch</span>(ex)&#123;</span><br><span class="line">       array = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;nodes.length;i++)&#123;</span><br><span class="line">           array.push(nodes[i]);</span><br><span class="line">       &#125;       </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>每个节点都有一个<strong>parent</strong>属性，指向文档树中的父节点</p><p>包含在childerNodes列表中的每个节点之间都是同袍节点，可以用<strong>previousSibling</strong>和<strong>nextSlibing</strong>来访问邻近的节点。</p><p>父节点的<strong>firstChild</strong>和<strong>lastChild</strong>属性分别指向childNodes列表中的第一个和最后一个子节点</p></li><li><p><strong>hasChildNodes()</strong></p><p>这个方法在包含一个或多个子节点的情况下返回true</p></li><li><p><strong>ownerDocument</strong>属性指向表示整个文档的文档节点，可以不用层层回溯直接访问文档节点</p></li></ul><h5 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h5><ul><li><p><strong>appendChild()</strong> 向childNodes列表的末尾添加一个节点，返回值是新增的节点</p><p>参数：要添加的节点</p><p>返回：添加的新节点</p><p><em>注意：任何DOM节点不能同时出现在文档的多个位置</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> returnedNode = someNode.appendChild(newNode);</span><br><span class="line">alert(returnedNode == newNode); <span class="comment">//true</span></span><br><span class="line">alert(someNode.lastChild == newNode); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果appendChild()传入了父节点的第一个节点，那么这个节点就会成为父节点的最后一个节点</span></span><br><span class="line"><span class="keyword">var</span> resurnedNode = someNode.appendChild(someNode.firstChild);</span><br><span class="line">alert(returnedNode == someNode.firstChild); <span class="comment">//false</span></span><br><span class="line">alert(returnedNode == someNode.lastChild);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>insertBefore()</strong>  把节点放入childNodes列表中某个特定的位置上</p><p>参数:要插入的节点，参照节点</p><p>返回：要插入的节点</p><p>插入节点后，要插入的节点会成为参照节点的previousSibling</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入后成为第一个节点</span></span><br><span class="line">returnedNode = someNode.insertBefore(node,someNode.firstNode);</span><br><span class="line">alert(returnedNode == someNode.firstNode) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>replaceChild</strong> 替换节点</p><p>参数：要插入的节点，被替换的节点</p><p>返回：被替换的节点</p><p>要替换的节点被从文档树中移除，被要插入的节点替换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换第一个节点</span></span><br><span class="line">returnedNode = someNode.replaceChild(newNode,someNode.firstChild);</span><br></pre></td></tr></table></figure></li><li><p><strong>removeChild</strong> 移除节点</p><p>参数：要移除的节点</p><p>返回：被移除的节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除最后一个节点</span></span><br><span class="line">returnedNode = someNode.removeChild(someNode.lastChild)</span><br></pre></td></tr></table></figure></li></ul><h5 id="一些其他方法"><a href="#一些其他方法" class="headerlink" title="一些其他方法"></a>一些其他方法</h5><ul><li><p><strong>cloneNode</strong> 创建调用这个方法的节点的一个完全相同的副本</p><p>参数：一个布尔值参数 </p><pre><code>true:执行深复制，复制节点及其整个子节点树false:执行浅复制，只复制节点本身</code></pre><p>返回：复制好的副本</p><p><em>注意：这个方法不会复制添加到DOM节点的js属性，如时间处理程序等</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--假设已经将ul元素的引用保存在了变量myList中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> deepList = myList.cloneNode(<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">    alert(deepList.childNodes.length); <span class="comment">//3</span></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> shallowList = myList.cloneNode(<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">    alert(shallowList.childNodes.length); <span class="comment">//0</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>normalize() 处理文档树中的文本节点（后面补充）</p></li></ul><h4 id="10-1-2-Document类型"><a href="#10-1-2-Document类型" class="headerlink" title="10.1.2 Document类型"></a>10.1.2 Document类型</h4><p>JS通过Document类型表示文档。</p><p>document对象是HTMLDocument的一个实例，表示整个HTML界面。</p><p>document对象是window对象的一个属性，可以作为全局对象来访问</p><p><strong>Document节点具有以下特征：</strong></p><ul><li>nodeType的值为9</li><li>nodeName的值为”#document“</li><li>nodeValue的值为null</li><li>parentNode的值为null</li><li>owenerDocument的值为null</li></ul><h5 id="document的子节点"><a href="#document的子节点" class="headerlink" title="document的子节点"></a>document的子节点</h5><ul><li><p><strong>documentElement</strong> 属性   始终指向html页面中的html元素</p><p>document的documentElement属性，firstChild属性，以及childNodes[0]都指向html</p></li><li><p><strong>body</strong> 属性   指向body元素</p></li><li><p><strong>doctype</strong> 属性   指向&lt;!DOCTYPE&gt;标签</p></li></ul><h5 id="document的属性"><a href="#document的属性" class="headerlink" title="document的属性"></a>document的属性</h5><ul><li><p><strong>title</strong>属性：包含着<title>元素中的文本  可以获得当前页面的标题，也可以修改</title></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> originalTitle = <span class="built_in">document</span>.title;</span><br><span class="line"><span class="built_in">document</span>.title = <span class="string">"New page title"</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>URL</strong> <strong>domain</strong> <strong>referrer</strong></p><p>URL:保存页面完整的URL</p><p>domain:只包含页面的域名</p><p>referrer:链接到当前页面的页面的URL（没有来源页面的情况下，可能包含空字符串）</p></li></ul><h5 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h5><ul><li><p><strong>document.getElementById()</strong></p><p>参数：要取得的元素的ID</p><p>返回：返回要取得的元素，如果没有该元素则返回NULL</p></li><li><p><strong>document.getElementsByTagName()</strong> </p><p>参数：要取得元素的标签名</p><p>返回：HTML文档中返回一个HTMLCollection对象，对象中的元素数量可以通过length属性取得</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> images = ducoment.getElementsByTagName(<span class="string">"img"</span>);</span><br><span class="line">alert(images.length);</span><br><span class="line">alert(images[<span class="number">0</span>].src);</span><br><span class="line">alert(images.item(<span class="number">0</span>).src);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTMLCollection对象方法:namedItem() 可以通过name特性取得集合中的项</span></span><br><span class="line"><span class="comment">//假设页面中包含如下img元素</span></span><br><span class="line">&lt;img src=<span class="string">"myImage.gif"</span> name=<span class="string">"myImage"</span>&gt;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> myImage = images.namedItem(<span class="string">"myImage"</span>);</span><br><span class="line"><span class="keyword">var</span> myImage = images[myImage] <span class="comment">//也支持按名称访问</span></span><br></pre></td></tr></table></figure></li><li><p><strong>getElementsByName()</strong>  </p><p>参数：name值</p><p>返回：带有给定name特性的所有元素</p></li></ul><h5 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h5><p> document对象还有一些特殊的集合，这些特殊的集合都是HTMLCollection对象，为访问文档常用的部分提供了快捷方式</p><ul><li>document.anchors  包含文档中所有带name特性的<a>元素</a></li><li>document.forms      包含文档中所有的form元素</li><li>document.images    包含文档中所有的Image元素</li><li>document.links         包含文档中所有带href的a元素</li></ul><h5 id="一致性检测"><a href="#一致性检测" class="headerlink" title="一致性检测"></a>一致性检测</h5><h5 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h5><h4 id="10-1-3-Element类型"><a href="#10-1-3-Element类型" class="headerlink" title="10.1.3 Element类型"></a>10.1.3 Element类型</h4><p>Element类型用于表现XML或HTML元素，提供了对元素标签名，子节点以及特性的访问。</p><p>具有以下特性：</p><ul><li>nodeType的值为1</li><li>nodeName的值为元素的标签名</li><li>nodeValue的值为null</li><li>parentNode可能是Document或Element</li><li>其子节点可能是Element,Text,Comment,ProcessingInstruction,CDATASection或EntityReference</li></ul><p>nodeName和tagName都会返回元素的标签名</p><h5 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h5><p>所有的HTML元素都由HTMLElement类型的子类型来表示。该类型直接继承Element并添加了一下属性。</p><p>添加的这些属性分别对应于每个HTML元素中都存在的标准特性：</p><ul><li>id 元素在文档中的唯一标识符</li><li>title 有关元素的附加信息</li><li>lang 元素内容的语言代码</li><li>dir 语言的方向（ltr rtl)</li><li>className 对应元素的class属性</li></ul><h5 id="取得特性"><a href="#取得特性" class="headerlink" title="取得特性"></a>取得特性</h5><p>操作特性的三个主要方法:<strong>getAttribute()、setAttribute()、removeAttribute()</strong></p><p>这三个方法可以针对任何特性使用，包括自定义特性。</p><p>取得特性是：<strong>getAttribute()</strong>  </p><ul><li>参数：特性名称（id,class,title,lang或自定义特性）</li><li>返回：特性值</li></ul><p>有两类特殊的特性，属性的值与通过getAttribute返回的值不相同：style,onclick</p><h5 id="设置特性-amp-amp-删除特性"><a href="#设置特性-amp-amp-删除特性" class="headerlink" title="设置特性&amp;&amp;删除特性"></a>设置特性&amp;&amp;删除特性</h5><p><strong>setAttribute()</strong></p><ul><li>参数：要设置的特性名，特性值</li><li>如果特性已经存在会用特性值替换已有的值，如果不存在就创建特性并设定相应的值</li></ul><p>所有的特性都是属性，也可以直接给属性赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div.id = <span class="string">"someOtherId"</span></span><br><span class="line">div.align = <span class="string">"left"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是通过赋值添加新的自定义属性,属性不会成为元素的特性</span></span><br><span class="line">div.mycolor = <span class="string">"red"</span></span><br><span class="line">alert(div.getAttribute(<span class="string">"mycolor"</span>))  <span class="comment">//null</span></span><br></pre></td></tr></table></figure><p><strong>removeAttribute()</strong></p><p>不仅会清除特性的值，也会从元素中完全删除特性。</p><h5 id="arrtibute属性"><a href="#arrtibute属性" class="headerlink" title="arrtibute属性"></a>arrtibute属性</h5><p>Element类型是使用attribute属性的唯一一个DOM节点类型。</p><p>attribute属性中包含一个NameNodeMap,与NodeList类似，也是一个动态的集合。<strong>元素中的每一个特性都由一个Arrt节点表示，每个节点的nodeName就是特性的名称，而节点的nodeValue就是特性的值。</strong>每个节点都保存在NameNodeMap对象中。该对象拥有下列方法：</p><ul><li>getNamedItem(name):返回nodeName属性等于name的节点</li><li>removeNamedItem(name):从列表中移除nodeName属性等于name的节点</li><li>setNamedItem(node):像列表中添加节点，以节点的nodeName属性为索引</li><li>item(pos)：返回位于数字pos位置的节点</li></ul><p>取得元素的id特性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = element.attributes.getNamedItem(<span class="string">"id"</span>).nodeValue;</span><br><span class="line"><span class="keyword">var</span> id =element.attributes[<span class="string">"id"</span>].nodeValue;</span><br></pre></td></tr></table></figure><p>给id特性设置新值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.attributes[<span class="string">"id"</span>].nodeValue = <span class="string">"someOtherId"</span>;</span><br></pre></td></tr></table></figure><p>删除特性</p><p>调用removeNamedItem()和在元素上调用removeAttribute()的效果相同，直接删除具有给定名称的特性。</p><p>但是removeNamedItem()会返回表示被删除特性的Attr节点。</p><p>一般来说，操作element特性时更多的使用getAttribute(),removeAttribute(),setAttribute()这三个方法</p><p>但是遍历元素特性时，attributes属性就会比较有用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>,ien = element.attributes.length;i&lt;len;i++)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h5><p>方法：document.createElement()</p><p>参数：要创建元素的标签名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个div元素</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line"><span class="comment">//可以操作新创建的元素，为他添加更多的子节点</span></span><br><span class="line">div.id = <span class="string">"myNewDiv"</span>;</span><br><span class="line">div.className = <span class="string">"box"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在新元素上设置特性只是赋予相应的信息，还未添加到文档树中，要显示在浏览器中，必须要添加到文档树中</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line"><span class="comment">//或者使用insertBefore,replaceChild</span></span><br></pre></td></tr></table></figure><h5 id="元素的子节点"><a href="#元素的子节点" class="headerlink" title="元素的子节点"></a>元素的子节点</h5><p>元素可以有任意数目的子节点和后代节点，因为元素可以是其他元素的子节点。</p><p>元素的childNodes属性包含了它的所有子节点，这些子节点有可能是元素，文本节点，注释或者处理指令。</p><p>不同的浏览器看待节点方面存在着显著的不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"myList"</span>&gt;</span><br><span class="line">    &lt;li&gt;Item <span class="number">1</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Item 2&lt;/</span>li&gt;</span><br><span class="line">&lt;li&gt;Item <span class="number">3</span>&lt;<span class="regexp">/li&gt;  </span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure><p>上述代码在IE中，<ul>元素会有3个子节点，分别是3个<li>元素。</li></ul></p><p>在其他浏览器中，<ul>元素有7个子节点，分别是3个<li>元素，以及<ul>和<li>之间的2个空白符,</li><li></li><li>之间的2个空白符。</li></ul></li></ul></p><p>所以如果需要在元素类型的子节点上进行某些操作，要先检查一下nodeType属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len = element.childrenNodes.length;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(element.childrenNodes[i].nodeType == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//需要执行的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过特定的标签名来取得子节点或者后代节点，使用<strong>getElementsByTagName()</strong></p><p>除了搜索节点是当前元素外，其他都跟通过document调用相同。因此也会只返回符合条件的当前元素的后代。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得ul元素包含的所有li元素</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"myList"</span>);</span><br><span class="line"><span class="keyword">var</span> li = ul.getElementsByTagName(<span class="string">"li"</span>);</span><br></pre></td></tr></table></figure><h4 id="10-1-4-Text类型"><a href="#10-1-4-Text类型" class="headerlink" title="10.1.4  Text类型"></a>10.1.4  Text类型</h4><p>包含可以按照字面解释的纯文本内容，可以包含转义后的HTML字符，但是不能包含HTML代码</p><p><strong>text节点具有以下特征：</strong></p><ul><li>nodeType的值为3</li><li>nodeName的值为”#text“</li><li>nodeValue的值为节点所包含的文本</li><li>parentNode是一个Element</li><li>不支持没有子节点</li></ul><p>nodeValue和data属性都可以访问文本节点中的文本</p><p><strong>节点操作方法</strong></p><ul><li>appendValue(text):将text添加到节点末尾</li><li>deleteDate(offset,count) ：从offset指定的位置开始删除count个字符</li><li>insertData(offset,text)：在offset指定的位置插入text</li><li>replaceData(offset,count,text)：用text替换从offset指定的位置开始到offset+count为止处的文本</li><li>splitText(offset)：从offset指定的位置将当前文本分成两个文本节点</li><li>substringData(offset,count)：提取从offset指定的位置开始到offset+count为止处的字符串</li></ul><p>文本节点还有一个length属性，保存着节点中字符的数目</p><p>nodeValue.length和data.length中也保存着相同的值。</p><h5 id="创建文本节点"><a href="#创建文本节点" class="headerlink" title="创建文本节点"></a>创建文本节点</h5><p>方法：document.createTextNode()</p><p>参数：要插入节点中的文本（按照HTML或XML的格式进行编码）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"&lt;strong&gt;Hello&lt;/strong&gt; world"</span>);</span><br></pre></td></tr></table></figure><p>要将新节点添加到文档树中已经存在的节点中才能使新节点在浏览器中展示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">element.className = <span class="string">"message"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world"</span>);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br></pre></td></tr></table></figure><h5 id="规范化文本节点"><a href="#规范化文本节点" class="headerlink" title="规范化文本节点"></a>规范化文本节点</h5><p>DOM文档中存在相邻的同胞文本节点很容易导致混乱，因此产生了一个能够将相邻文本节点合并的方法。</p><p>这个方法是：<strong>normalize()</strong> ，由Node类型定义，因此所有节点类型都存在该方法</p><p>如果在含有一个或多个文本节点的父元素上调用这个方法，则会将所有的文本节点合并成一个节点，节点的nodeValue等于将合并前每个文本节点的nodeValue值拼接起来的值。</p><p><em>浏览器在解析文档时永远不会创建相邻的文本节点，只有在执行DOM操作时会出现</em></p><h5 id="分割文本节点"><a href="#分割文本节点" class="headerlink" title="分割文本节点"></a>分割文本节点</h5><p>Text类型提供了一个作用跟normalize()相反的方法：<strong>splitText()</strong></p><p>这个方法会将一个文本节点分成两个文本节点</p><p>原来的节点包含从开始到指定位置之前的内容，新文本节点包含剩下的文本，返回新文本节点。新文本节点个原节点的parentNode相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">element.className = <span class="string">"message"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello World"</span>);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newNode = element.firstChild.splitText(<span class="number">5</span>);</span><br><span class="line">alert(element.firstChild.nodeValue); <span class="comment">//Hello</span></span><br><span class="line">alert(newNode.nodeValue); <span class="comment">//World</span></span><br><span class="line">alert(element.childrenNodes.length);<span class="comment">//2</span></span><br></pre></td></tr></table></figure><h4 id="10-1-5-Attr类型"><a href="#10-1-5-Attr类型" class="headerlink" title="10.1.5  Attr类型"></a>10.1.5  Attr类型</h4><p>区分特性（attribute）和属性（property）：</p><p>元素的特性在DOM中以attr来表示，从技术角度讲，特性就是存在于元素的attributes属性中的节点。</p><p>特性用来描述属性</p><p>Attr对象有3个属性：name,value,specified</p><p>name：特性名称（与nodeName的值相同）</p><p>value:   特性的值   (与nodeValue的值相同)</p><p>specified：一个布尔值，用以区别特性是在代码中指定的还是默认的。</p><h3 id="10-2-DOM操作技术"><a href="#10-2-DOM操作技术" class="headerlink" title="10.2 DOM操作技术"></a>10.2 DOM操作技术</h3><h4 id="10-2-1-动态脚本"><a href="#10-2-1-动态脚本" class="headerlink" title="10.2.1 动态脚本"></a>10.2.1 动态脚本</h4><p>动态脚本指的是：在页面加载时不存在，但将来的某一时刻通过修改DOM动态添加的脚本</p><h4 id="10-2-2-动态样式"><a href="#10-2-2-动态样式" class="headerlink" title="10.2.2 动态样式"></a>10.2.2 动态样式</h4><h4 id="10-2-3-操作表格"><a href="#10-2-3-操作表格" class="headerlink" title="10.2.3 操作表格"></a>10.2.3 操作表格</h4><h4 id="10-2-4-使用nodeList"><a href="#10-2-4-使用nodeList" class="headerlink" title="10.2.4 使用nodeList"></a>10.2.4 使用nodeList</h4><h2 id="第十一章-DOM扩展"><a href="#第十一章-DOM扩展" class="headerlink" title="第十一章  DOM扩展"></a>第十一章  DOM扩展</h2><p>两个主要的扩展是：Selectors API 和 HTML5</p><h3 id="11-1-选择符API"><a href="#11-1-选择符API" class="headerlink" title="11.1 选择符API"></a>11.1 选择符API</h3><p>Selectors API是由W3C发起指定的标准，致力于让浏览器原生支持CSS查询。这样一来，解析和树查询操作可以在浏览器内部通过编译后的代码来完成，极大地改善了性能。(jquery就是通过css选择符查询DOM获得文档的应用)</p><p>两个核心方法：querySelector()和querySelectorAll()。在兼容的浏览器中，可以通过Document及Element类型的实例来调用。</p><h4 id="11-1-1-querySelector"><a href="#11-1-1-querySelector" class="headerlink" title="11.1.1 querySelector()"></a>11.1.1 querySelector()</h4><p>方法：document(element).querySelector()</p><p>参数：css选择符</p><p>返回：与该模式匹配的第一个元素，没有找到则返回null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">"body"</span>);<span class="comment">//取得body元素</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.querySelector(<span class="string">"#myDiv);//取得ID为myDiv的元素</span></span><br><span class="line"><span class="string">var select = document.querySelector("</span>.selected<span class="string">")//取得class为selected的第一个元素</span></span><br><span class="line"><span class="string">var img = myDiv.querySelector("</span>img.button<span class="string">") //取得myDiv子代中第一个class为button的img元素</span></span><br></pre></td></tr></table></figure><h4 id="11-1-2-querySelectorAll"><a href="#11-1-2-querySelectorAll" class="headerlink" title="11.1.2 querySelectorAll()"></a>11.1.2 querySelectorAll()</h4><p>方法：document(element).querySelectorAll()</p><p>参数：css选择符</p><p>返回：返回一个nodeList对象，包含匹配的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ems = <span class="built_in">document</span>.querySelector(<span class="string">"myDiv"</span>).querySelectorAll(<span class="string">"em"</span>) <span class="comment">//取得myDiv中的所有em元素</span></span><br><span class="line"><span class="keyword">var</span> selecteds = <span class="built_in">document</span>.querySelectorALL(<span class="string">".selected"</span>) <span class="comment">//取得所有class为selected的元素</span></span><br><span class="line"><span class="keyword">var</span> strongs = <span class="built_in">document</span>.querySelectorAll(<span class="string">"p strong"</span>) <span class="comment">//取得所有p元素的strong元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取得返回nodeList中的每一个元素</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>,len = strongs.length;i&lt;len;i++)&#123;</span><br><span class="line">    strong = strongs[i] <span class="comment">//或者strong.item(i)</span></span><br><span class="line">    <span class="comment">//执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-1-3-matchedSelector"><a href="#11-1-3-matchedSelector" class="headerlink" title="11.1.3 matchedSelector()"></a>11.1.3 matchedSelector()</h4><p>为Element类型新增的方法</p><p>方法：element.matchedSelector()</p><p>参数：css选择符</p><p>返回：ture,flase; 如果调用元素与选择符匹配则返回ture，否则返回fasle</p><h3 id="11-2-元素遍历（不包含空白文本节点）"><a href="#11-2-元素遍历（不包含空白文本节点）" class="headerlink" title="11.2 元素遍历（不包含空白文本节点）"></a>11.2 元素遍历（不包含空白文本节点）</h3><p>对于元素空格，IE9及之前不会返回文本节点，其他浏览器都会。为了弥补这一差异，E定义了一组新的属性。</p><p>添加了以下五个属性：</p><ul><li>childElementCount:返回子元素（不包括文本节点和注释）的个数</li><li>firstElementChild:指向第一个元素</li><li>lastElementChild:指向最后一个元素</li><li>previousElementSibling:指向前一个同胞元素</li><li>nextElementSibling:指向后一个同胞元素</li></ul><p>这些属性返回的元素都不包含空白文本节点</p><p>遍历所有子元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i,len,child = element.firstElementChild;</span><br><span class="line"><span class="keyword">while</span>(child!=element.lastElementChild)&#123;</span><br><span class="line">    <span class="comment">//某些操作</span></span><br><span class="line">    child = child.nextElementSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-3-HTML5"><a href="#11-3-HTML5" class="headerlink" title="11.3 HTML5"></a>11.3 HTML5</h4><h4 id="11-3-1-与类相关的扩充"><a href="#11-3-1-与类相关的扩充" class="headerlink" title="11.3.1  与类相关的扩充"></a>11.3.1  与类相关的扩充</h4><p>新增了很多致力于简化CSS类的用法</p><h5 id="getElementsByClassName-方法"><a href="#getElementsByClassName-方法" class="headerlink" title="getElementsByClassName() 方法"></a>getElementsByClassName() 方法</h5><p>方法：getElementsByClassName()</p><p>参数：一个包含一或多个类名的字符串</p><p>返回：带有指定类的所有元素的NodeList</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得所有类中包含“username"和”current"的元素</span></span><br><span class="line"><span class="keyword">var</span> allCurrentUsernames = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"username current"</span>);</span><br><span class="line"><span class="comment">//取得ID为"myDiv"的元素中带有类名"selectd"的所有元素</span></span><br><span class="line"><span class="keyword">var</span> selectd = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).getElementsByClassName(<span class="string">"selected"</span>);</span><br></pre></td></tr></table></figure><h5 id="classList-属性"><a href="#classList-属性" class="headerlink" title="classList 属性"></a>classList 属性</h5><p>操作类名时，通过className属性添加，删除和替换类名。但是因为className是一个字符串，所以即使只是修改字符串一部分也必须都设置整个字符串的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个div元素一共有三个类名，要从中删除一个类名需要把三个类名拆开，然后删除再拼接</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"bd user disabled"</span>&gt;....&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>HTML5为所有元素添加classList属性以便操作类名。有包含多少元素的length属性，取得每个元素可以使用item()方法，也可以使用方括号[]。</p><p>新类型定义的方法如下：</p><ul><li>add(value):将给定的字符串添加到列表中</li><li>contains(value):表示列表中是否存在给定的值，如果存在则返回true，否则返回false</li><li>remove(value)：从列表中删除给定的字符</li><li>toggle(value)：如果列表中存在给定的值，删除它；如果列表中没有给定的值，添加它</li></ul><p>比如从上面的div元素中删除user类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.classList.remove(<span class="string">"user"</span>);</span><br></pre></td></tr></table></figure><h4 id="11-3-2-焦点管理"><a href="#11-3-2-焦点管理" class="headerlink" title="11.3.2 焦点管理"></a>11.3.2 焦点管理</h4><p>新增document.activeElement属性，这个属性始终会引用DOM中当前获得了焦点的元素（页面加载，用户输入，代码调用focus）。</p><p>默认情况下，文档刚加载完这个属性保存的是document.body元素，加载期间，这个属性的值为null。</p><p>新增方法：document.hasFocus()，用于确定文档是否获得了焦点。</p><h4 id="11-3-3-HEMLDocument的变化"><a href="#11-3-3-HEMLDocument的变化" class="headerlink" title="11.3.3 HEMLDocument的变化"></a>11.3.3 HEMLDocument的变化</h4><h5 id="readyState属性"><a href="#readyState属性" class="headerlink" title="readyState属性"></a>readyState属性</h5><p>两个可能的值：</p><ul><li>loading:正在加载文档</li><li>complete:已经加载完文档</li></ul><p>应用：实现一个指定文档已经加载完的指示器。</p><p>在这个属性之前，必须借助onload时间处理程序设置一个标签来表明文档已经加载完毕。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.readyState == <span class="string">"complete"</span>)&#123;</span><br><span class="line">    <span class="comment">//执行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-3-4-自定义数据属性"><a href="#11-3-4-自定义数据属性" class="headerlink" title="11.3.4 自定义数据属性"></a>11.3.4 自定义数据属性</h4><p>HTML5规定可以为元素添加非标准的属性，但是要添加前缀data-。目的是为元素提供与渲染无关的信息，或者提供语义信息。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">data-appID</span>=<span class="string">"12345"</span> <span class="attr">data-mynane</span>=<span class="string">"Jack"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过元素的dataset属性来访问自定义数据属性。dataset属性的值是DOMStringMap的一个实例，是一个名值对的映射。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"><span class="keyword">var</span> appId = div.dataset.appID;</span><br><span class="line"><span class="keyword">var</span> myname = div.dataset.myname;</span><br><span class="line">alert(<span class="string">"hello,"</span>+appid+myname);<span class="comment">//hello,12345Jack</span></span><br><span class="line"></span><br><span class="line">也可以修改值</span><br><span class="line">div.dataset.appID=<span class="number">123</span>;</span><br></pre></td></tr></table></figure><h3 id="11-4-一些专有扩展"><a href="#11-4-一些专有扩展" class="headerlink" title="11.4 一些专有扩展"></a>11.4 一些专有扩展</h3><h2 id="第十二章-DOM2和DOM3"><a href="#第十二章-DOM2和DOM3" class="headerlink" title="第十二章 DOM2和DOM3"></a>第十二章 DOM2和DOM3</h2><h3 id="12-1-DOM变化"><a href="#12-1-DOM变化" class="headerlink" title="12.1 DOM变化"></a>12.1 DOM变化</h3><h3 id="12-2-DOM操作样式"><a href="#12-2-DOM操作样式" class="headerlink" title="12.2 DOM操作样式"></a>12.2 DOM操作样式</h3><p>DOM级样式提供了一套API来操作样式。</p><h4 id="12-2-1-访问元素的样式"><a href="#12-2-1-访问元素的样式" class="headerlink" title="12.2.1 访问元素的样式"></a>12.2.1 访问元素的样式</h4><p>任何支持style特性的HTML元素在javascript中都有一个对应的style属性。在style特性中指定的任何CSS属性都将表现为这个style对象的相应属性。</p><p>style对象不包含与外部样式表或嵌入样式表经层叠而来的样式。</p><p>js访问时，对于使用短划线的css属性，必须将其转换为驼峰大小写形势</p><table><thead><tr><th>CSS属性</th><th>JavaScript属性</th></tr></thead><tbody><tr><td>background-imgae</td><td>style.backgroundImage</td></tr><tr><td>color</td><td>style.color</td></tr><tr><td>display</td><td>style.display</td></tr><tr><td>font-family</td><td>style.fontFamily</td></tr></tbody></table><p>多数情况下都可以通过转换属性名的格式来实现转换，但是css属性float不能，因为float是javascript的保留字，不能用作属性名。DOM2规范规定相应属性名为cssFloat，大部分浏览器都支持，但是IE支持的是styleFloat。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置样式</span></span><br><span class="line">myDiv.style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line">myDiv.style.border=<span class="string">"1px solid red"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取样式</span></span><br><span class="line">alert(myDiv.style.background) <span class="comment">//red;</span></span><br></pre></td></tr></table></figure><h5 id="DOM样式属性和方法"><a href="#DOM样式属性和方法" class="headerlink" title="DOM样式属性和方法"></a>DOM样式属性和方法</h5><p>为style对象定义了一些方法和属性：</p><ul><li>cssText:访问到style特性中的css代码</li><li>length:应用给元素的css属性的数量</li><li>parentRule:表示css信息的CSSRule对象</li><li>getPropertyCSSValue(propertyName):返回包含给定属性值的CSSValue对象（CSSValue对象包含两个属性：cssText,cssValueType。cssText属性的值和getPropertyValue()返回的值相同；cssValueType属性的值是一个数据常量，表示值的类型：0表示继承的值，1表示基本的值，2表示值列表，3表示自定义的值）</li><li>getPropertyPriority(propertyName):如果给定的属性使用了!important设置，返回”important”，否则返回空字符串</li><li>getPropertyValue(propertyName):返回给定属性的字符串值</li><li>item(index):返回给定位置的css属性的名称</li><li>removeProperty(propertyName):从样式中删除给定属性</li><li>setProperty(propertyName,value,priority):将给定属性设置为相应的值，并加上优先权标志(important或空字符串）</li></ul><h5 id="计算的样式"><a href="#计算的样式" class="headerlink" title="计算的样式"></a>计算的样式</h5><p>document.defaultView提供了getComputedStyle()方法</p><p>方法：getComputedStyle()</p><p>参数：要计算样式的元素，一个伪元素字符串（不选为null）</p><p>返回：一个CSSStyleDeclaration对象（与style属性的类型相同），包含当前元素的所有计算的样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span> = <span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.myDiv</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv1"</span> <span class="attr">class</span>=<span class="string">"myDiv"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv2"</span> <span class="attr">class</span>=<span class="string">"myDiv"</span> <span class="attr">style</span>=<span class="string">"background-color:red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> myDiv1 = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv1"</span>); </span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(myDiv1.style.width) <span class="comment">//"" undifined 无法访问到嵌入样式表的样式</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> computedStyle = <span class="built_in">document</span>.defaultView.getComputedStyle(myDiv1,<span class="literal">null</span>);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(computedStyle.width); <span class="comment">//100px</span></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> myDiv2 = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv2"</span>); </span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(myDiv1.style.backgroundColor); <span class="comment">//red</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(myDiv1.style.width); <span class="comment">//undefined</span></span></span><br><span class="line"><span class="undefined">   </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="12-2-2-操作样式表"><a href="#12-2-2-操作样式表" class="headerlink" title="12.2.2 操作样式表"></a>12.2.2 操作样式表</h4><h4 id="12-2-3-元素大小"><a href="#12-2-3-元素大小" class="headerlink" title="12.2.3 元素大小"></a>12.2.3 元素大小</h4><h3 id="12-3-遍历"><a href="#12-3-遍历" class="headerlink" title="12.3 遍历"></a>12.3 遍历</h3><p>NodeIterator和TreeWalker</p><p>深度优先的遍历</p><h3 id="12-4-范围"><a href="#12-4-范围" class="headerlink" title="12.4 范围"></a>12.4 范围</h3><p>##第十三章 事件</p><p>JavaScript与HTML之间的交互式通过事件来实现的。</p><h3 id="13-1-事件流"><a href="#13-1-事件流" class="headerlink" title="13.1 事件流"></a>13.1 事件流</h3><p>事件流描述的是从页面中接收事件的顺序。</p><h4 id="13-1-1-事件冒泡"><a href="#13-1-1-事件冒泡" class="headerlink" title="13.1.1 事件冒泡"></a>13.1.1 事件冒泡</h4><p>IE的事件流叫做事件冒泡，事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接受，然后逐级向上传播到较为不具体的节点（文档）</p><h4 id="13-1-2-事件捕获"><a href="#13-1-2-事件捕获" class="headerlink" title="13.1.2 事件捕获"></a>13.1.2 事件捕获</h4><p>不太具体的节点应该更早接收到事件，最具体的节点应该最后接收到事件</p><h4 id="13-1-3-DOM事件流"><a href="#13-1-3-DOM事件流" class="headerlink" title="13.1.3 DOM事件流"></a>13.1.3 DOM事件流</h4><p>DOM2级事件规定的事件流包括三个阶段：事件捕获阶段，处于目标阶段和事件冒泡阶段</p><ul><li>事件捕获阶段：从Document查找到最具体元素之前的阶段</li><li>处于目标阶段：最具体元素</li><li>事件冒泡阶段：从最具体元素冒泡到Document</li></ul><h3 id="13-2-事件处理程序"><a href="#13-2-事件处理程序" class="headerlink" title="13.2 事件处理程序"></a>13.2 事件处理程序</h3><p>响应某个事件的函数叫做事件处理程序（或事件监听器）</p><p>事件处理程序的名字以“on”开头，如：click事件的时间处理程序就是onclick，load事件的时间处理程序就是onload。为事件指定处理程序的方式有很多</p><h4 id="12-2-1-HTML事件处理程序"><a href="#12-2-1-HTML事件处理程序" class="headerlink" title="12.2.1 HTML事件处理程序"></a>12.2.1 HTML事件处理程序</h4><p>这个操作是通过指定onclick特性并将一些JavaScript代码作为它的值来定义的。因此不能使用未转义的HTML语法字符。</p><p>HTML时间处理程序可以包含要执行的具体动作，也可以调用在页面其他地方定义的脚本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//具体动作</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"button"</span> <span class="attr">value</span> = <span class="string">"click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert('clicked')"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">//其他地方定义的脚本</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">showMessage</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">"Hello world!"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click Me"</span> <span class="attr">onclick</span>=<span class="string">"showMessage()"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="12-2-2-DOM0级事件处理程序"><a href="#12-2-2-DOM0级事件处理程序" class="headerlink" title="12.2.2 DOM0级事件处理程序"></a>12.2.2 DOM0级事件处理程序</h4><p>传统方式：将一个函数赋值给一个事件处理程序属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Clicked"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用DOM0级方法指定的时间处理程序被认为是元素的方法，因此这时的时间处理程序是在元素的作用域中运行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id);   <span class="comment">//"myBtn"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。</p><p>也可以删除事件处理程序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick=<span class="literal">null</span></span><br></pre></td></tr></table></figure><h4 id="13-2-3-DOM2级事件处理程序"><a href="#13-2-3-DOM2级事件处理程序" class="headerlink" title="13.2.3 DOM2级事件处理程序"></a>13.2.3 DOM2级事件处理程序</h4><p>处理指定事件处理程序：<strong>addEventListener()</strong></p><p>删除指定事件处理程序：<strong>removeEventListener()</strong></p><p>都接受3个参数：要处理的事件名，作为事件处理程序的函数，一个布尔值（true捕获阶段调用，false冒泡阶段调用）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   <span class="comment">//可以添加多个事件处理程序</span></span><br><span class="line">    alert(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>通过addEventListener添加的事件处理程序只能通过removeEventListener()来移除，移除时传入的参数与添加时相同，但像上面代码中的匿名函数无法被删除。</p><p>大多数情况下都是将事件处理程序添加到事件流的冒泡阶段</p><h4 id="13-2-4-IE事件处理程序"><a href="#13-2-4-IE事件处理程序" class="headerlink" title="13.2.4 IE事件处理程序"></a>13.2.4 IE事件处理程序</h4><p>两个类似的方法：attachEvent(),detachEvent()</p><p>主要区别在于这两个方法的事件处理程序会在全局作用域中运行，this等于window</p><h3 id="13-3-事件对象"><a href="#13-3-事件对象" class="headerlink" title="13.3 事件对象"></a>13.3 事件对象</h3><p>在触发DOM上的某个对象时，会产生一个事件对象event，这个对象包含着所有与事件有关的信息，包括事件的元素，事件的类型以及其他与特性时间相关的信息。</p><h4 id="13-3-1-DOM中的事件对象"><a href="#13-3-1-DOM中的事件对象" class="headerlink" title="13.3.1 DOM中的事件对象"></a>13.3.1 DOM中的事件对象</h4><p>兼容DOM的浏览器会将一个event对象传入到事件处理程序中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    alert(event.type); <span class="comment">//"click"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    alert(event.type);  <span class="comment">//"click"</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h5 id="target-currentTarget"><a href="#target-currentTarget" class="headerlink" title="target currentTarget"></a>target currentTarget</h5><p>在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标。如果直接将事件处理程序指定了目标元素，则三个值相同。如果把事件处理程序指定了目标元素的父节点中，则this,currentTarget指的是父节点，而target指的是目标元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&quot;myBtn&quot;);</span><br><span class="line">btn.onclick = function(event)&#123;</span><br><span class="line">    alert(this == event.currentTarget); //true</span><br><span class="line">    alert(this == event.target);        //true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.body.onclick = function(event)&#123;</span><br><span class="line">    alert(event.currentTarget == document.body);//true</span><br><span class="line">    alert(event.currentTarget == this); //true</span><br><span class="line">    alert(event.target == myBtn);  //true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h5><p>通过一个函数处理多个事件可以用type</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(event.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">            alert(<span class="string">"Clicked"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"mouseover"</span>:</span><br><span class="line">            event.target.style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"mouseout"</span>:</span><br><span class="line">            event.target.style.backgroundColor = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">break</span>;           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">btn.onclick = handler;</span><br><span class="line">btn.onmouseover = handler;</span><br><span class="line">btn.onmouseout = handler;</span><br></pre></td></tr></table></figure><h4 id="13-4-事件类型"><a href="#13-4-事件类型" class="headerlink" title="13.4 事件类型"></a>13.4 事件类型</h4><h4 id="13-5-内存性能-amp-amp-模拟事件"><a href="#13-5-内存性能-amp-amp-模拟事件" class="headerlink" title="13.5 内存性能&amp;&amp;模拟事件"></a>13.5 内存性能&amp;&amp;模拟事件</h4><h4 id="13-5-1-事件委托"><a href="#13-5-1-事件委托" class="headerlink" title="13.5.1  事件委托"></a>13.5.1  事件委托</h4><p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的事情。不需要给每个可单击的元素分别添加事件处理程序。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"palette"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:crimson"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:bisque"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:blueviolet"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:coral"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:chartreuse"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:darkolivegreen"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:cyan"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:#194738"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> uList = <span class="built_in">document</span>.querySelector(<span class="string">"ul"</span>);</span></span><br><span class="line"><span class="javascript">uList.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        thisLi = event.target;  <span class="comment">//获得用户实际点击的li</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(thisLi);</span></span><br><span class="line"><span class="javascript">         <span class="comment">//执行某些操作</span></span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="第十四章-表单脚本"><a href="#第十四章-表单脚本" class="headerlink" title="第十四章 表单脚本"></a>第十四章 表单脚本</h2><p>JavaScript最初的一个应用就是分担服务器处理表单的责任，打破处处依赖服务器的局面</p><h3 id="14-1-表单的基础知识"><a href="#14-1-表单的基础知识" class="headerlink" title="14.1 表单的基础知识"></a>14.1 表单的基础知识</h3><p>在HTML中，表单元素<form>，在javascript中，表单对应的则是HTMLFormElement类型。</form></p><p>一些除默认属性外的独特的属性和方法：</p><ul><li>acceptCharset:服务器能够处理的字符集，等价于HTML中的accept-charset特性</li><li>action 接受请求的URL，等价于HTML中的action特性</li><li>elements:表单中所有控件的集合</li><li>enctype:请求编码的类型</li><li>length:表单中控件的数量</li><li>method：要发送的HTTP请求类型（get,post)</li><li>name:表单的名称</li><li>reset():将所有表单域重置为默认值</li><li>submin():提交表单</li><li>target():用于发送请求和接受响应的窗口名称</li></ul><p>取得form元素引用的方式：</p><ul><li><p>将他看成和其他元素一样，添加id特性，然后使用getElementById()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"form1"</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过document.forms可以取得页面中所有表单，在这个集合中可以通过数组索引或name值来取得特定的表单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstForm = <span class="built_in">document</span>.forms[<span class="number">0</span>];   <span class="comment">//取得页面中第一个表单</span></span><br><span class="line"><span class="keyword">var</span> myForm = <span class="built_in">document</span>.forms[<span class="string">"form2"</span>];  <span class="comment">//取得页面中名称为"form2"的表单</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="14-1-1-提交表单"><a href="#14-1-1-提交表单" class="headerlink" title="14.1.1 提交表单"></a>14.1.1 提交表单</h4><h5 id="提交方法"><a href="#提交方法" class="headerlink" title="提交方法"></a>提交方法</h5><ol><li>使用<input>或<button>都可以定义提交按钮，只要将type特性设置为”submit”即可，而图像按钮则是通过将</button><input>的type特性设置为image来定义的 </li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"submit"</span> value=<span class="string">"Submit Form"</span></span><br><span class="line">&lt;button type=<span class="string">"submit"</span> value=<span class="string">"Submit Form"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;input type=<span class="string">"image"</span> src=<span class="string">"graphic.gif"</span>&gt;</span><br></pre></td></tr></table></figure><pre><code>只要表单中存在上面列出的任何一种按钮，那么在相应表单空间拥有焦点的情况下，按回车键就可以提交该表  单。 以这种方式提交表单，浏览器会在将请求发送给服务期之前触发submit事件。这样就有机会验证表单数据，并以此决定是否允许表单提交。</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</span><br><span class="line">EventUtil.addHandler(form,<span class="string">"submit"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//阻止默认事件</span></span><br><span class="line">    EventUtil.preventDefault(event);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>也可以在js中以编程方式调用submit方法来提交</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</span><br><span class="line">form.submit();</span><br></pre></td></tr></table></figure><p>以这种方式调用submit的方式提交表单不会触发submit事件，因此要先验证表单数据。</p></li></ol><h5 id="解决出现的问题"><a href="#解决出现的问题" class="headerlink" title="解决出现的问题"></a>解决出现的问题</h5><p>可能出现的最大问题就是重复提交表单：如果服务器长时间没反应用户可能会反复单击提交按钮会造成错误</p><p>解决方法：</p><ul><li>在第一次提交表单后就禁用提交按钮</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(form,<span class="string">"submit"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> btn = target.element[<span class="string">"submit-btn"</span>];</span><br><span class="line">    btn.disabled = ture;   </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能使用onclick来实现这个功能，因为无法确定submit和禁用事件的执行顺序。因此最好通过监听submit事件来实现。</span></span><br></pre></td></tr></table></figure><ul><li>利用onsubmit事件处理程序取消后续的表单提交操作</li></ul><h4 id="14-1-2-重置表单"><a href="#14-1-2-重置表单" class="headerlink" title="14.1.2 重置表单"></a>14.1.2 重置表单</h4><p>在用户单击重置按钮时，表单会被重置。使用type特性值为“reset”的input或button都可以创建重置按钮。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"reset"</span> value=<span class="string">"Reset Form"</span>&gt;</span><br><span class="line">&lt;button type=<span class="string">"reset"</span>&gt;Reset Form&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>重置表单时，所有表单字段都会恢复到页面刚加载完毕的初始值。</p><p>用户单击重置按钮重置表单时，会触发reset事件，利用这个机会，可以在必要时取消重置操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var form = document.getElementById(&quot;myForm&quot;);</span><br><span class="line">EventUtil.addHandler(form,&quot;reset&quot;,function(event)&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    </span><br><span class="line">    //阻止默认事件</span><br><span class="line">    EventUtil.preventDefault(event);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>与提交表单一样，重置也可以使用js,form.reset()即可</p><p>不一样的是，使用js调用也会像单击重置按钮一样触发reset事件。</p><h4 id="14-1-3-表单字段"><a href="#14-1-3-表单字段" class="headerlink" title="14.1.3 表单字段"></a>14.1.3 表单字段</h4><p>每个表单都有elements属性，该属性是表单中所有表单字段的集合。elements集合是一个有序列表，其中包含着表单中的所有字段，例如input textarea button filedset。表单字段在集合中的顺序，与他们出现在标记中的顺序相同，可以按照位置和name特性来访问他们。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> field1 = form.elements[<span class="number">0</span>]; <span class="comment">//取得表单中第一个字段</span></span><br><span class="line"><span class="keyword">var</span> field2 = form.elements[<span class="string">"textbox1"</span>] <span class="comment">//去的表单中名为”textbox1"的字段</span></span><br><span class="line"><span class="keyword">var</span> fieldCout = form.elements.length;  <span class="comment">//取得表单中包含的字段数量</span></span><br></pre></td></tr></table></figure><p>如果有多个表单控件都在使用一个name(如单选按钮)，那么就会返回一个以该name命名的一个NodeList。</p><h5 id="共用的表单字段属性"><a href="#共用的表单字段属性" class="headerlink" title="共用的表单字段属性"></a>共用的表单字段属性</h5><p>除了fieldset元素之外，所有表单字段都拥有相同的一组属性。表单字段共有的属性如下：</p><ul><li>disabled:布尔值，表示当前字段是否被禁用</li><li>form:指向当前字段所属表单的指针（只读）</li><li>name:当前字段的名称</li><li>readOnly:布尔值，表示当前字段是否只读</li><li>tabIndex:表示当前字段的切换序号</li><li>type:当前字段的类型（checkbox,radio)</li><li>value:当前字段将被提交给服务器的值，对于文件字段来说这个属性只读，包含文件在计算机中的路径。</li></ul><p>除了form属性，可以通过JS来修改其他任何属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</span><br><span class="line"><span class="keyword">var</span> field = form.elements[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">field.value=<span class="string">"Another value"</span>;</span><br><span class="line">alert(field.form === form)  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">field.disabled=ture;<span class="comment">//禁用当前字段</span></span><br></pre></td></tr></table></figure><h5 id="共有的表单字段方法"><a href="#共有的表单字段方法" class="headerlink" title="共有的表单字段方法"></a>共有的表单字段方法</h5><p>每个表单字段都有两个方法：focus()和blur()。</p><p><strong>focus：</strong>将浏览器的焦点设置到表单字段，即激活表单字段。</p><p>例如，可以在页面加载完毕后，将焦点转移到表单的第一个字段。（监听load事件，并在事件发生时在表单的第一个字段上调用focus方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>,<span class="string">"load"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="number">0</span>].focus();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果上述表单中第一个表单字段是input,并且type特性的值为hidden，则上述代码会导致错误。css的display和visibility属性也会导致错误</span></span><br></pre></td></tr></table></figure><p>HTML5新增autofocus属性。不用js也能自动移动焦点</p><p>input type=”text” autofocus</p><p><strong>blur:</strong> 从元素中移走焦点</p><p>调用blur()方法时，并不会把焦点转移到某个特定的元素上，仅仅是将焦点从调用这个方法的元素上面移走。</p><h5 id="共用的表单字段事件"><a href="#共用的表单字段事件" class="headerlink" title="共用的表单字段事件"></a>共用的表单字段事件</h5><p>除了支持鼠标，键盘，更改和HTML时间之外，所有的表单都支持下列三个事件：</p><ul><li>blur:当前字段失去焦点时触发</li><li>change:对于input和textarea元素，失去焦点且value值改变时触发；对于select元素，在选项值改变时触发</li><li>focus：当前字段获得焦点时触发</li></ul><h3 id="14-2-文本框脚本"><a href="#14-2-文本框脚本" class="headerlink" title="14.2 文本框脚本"></a>14.2 文本框脚本</h3><p>input 单行文本框</p><ul><li>表现文本框必须将input元素的type特性设置为text</li><li>size：指定文本框中能够显示的字符数</li><li>value:设置文本框的初始值</li><li>maxlength：指定文本框个可以接受的最大字符数</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">size</span>=<span class="string">"25"</span> <span class="attr">maxlength</span>=<span class="string">"50"</span> <span class="attr">value</span>=<span class="string">"initial value"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><textarea> 多行文本框</textarea></p><ul><li>rows：指定文本框的字符行数</li><li>cols：指定文本框的字符列数</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"25"</span> <span class="attr">cols</span>=<span class="string">"5"</span>&gt;</span>inital value<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>两种文本框都会将用户输入的内容保存在value属性中，可以通过这个属性来读取和设置文本框的值。</p><h4 id="14-2-1-选择文本"><a href="#14-2-1-选择文本" class="headerlink" title="14.2.1  选择文本"></a>14.2.1  选择文本</h4><p>上述两种文本框都支持select()方法，这个方法用于选择文本框中的所有文本。调用select()方法是，大多数浏览器会将焦点设置到文本框中。</p><p>在文本获得焦点是选择所有文本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(textbox,<span class="string">"focus"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">    </span><br><span class="line">    target.select();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="选择事件"><a href="#选择事件" class="headerlink" title="选择事件"></a>选择事件</h5><p>在选择了文本框的文本后，就会触发select事件。用户选择了文本或者调用select方法都会触发select事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(textbox,<span class="string">"select"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">    </span><br><span class="line">    alert(target.value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="取得选择的文本"><a href="#取得选择的文本" class="headerlink" title="取得选择的文本"></a>取得选择的文本</h5><p>HTML通过扩展方案以便顺利取得选择的文本。</p><p>添加两个属性：selectionStart  selectionEnd</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSelectedText</span>(<span class="params">textbox</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> textbox.value.substring(textbox.selectionStart,textbox.selectionEnd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="选择部分文本"><a href="#选择部分文本" class="headerlink" title="选择部分文本"></a>选择部分文本</h5><p>方法：setSelectionRange()</p><p>参数：要选择的第一个字符的索引和最后一个字符之后的字符的索引</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">textbox.value = <span class="string">"Hello world"</span>;</span><br><span class="line"></span><br><span class="line">textbox.setSelectionRange(<span class="number">0</span>,textbox.value.length);<span class="comment">//Hello world</span></span><br><span class="line">textbox.setSelectionRange(<span class="number">0</span>,<span class="number">3</span>) <span class="comment">//Hel</span></span><br></pre></td></tr></table></figure><p>要见到选择的文本必须在调用该方法之前或者之后立即将焦点设置到文本框</p><h4 id="14-2-2-过滤输入"><a href="#14-2-2-过滤输入" class="headerlink" title="14.2.2 过滤输入"></a>14.2.2 过滤输入</h4><h5 id="屏蔽字符"><a href="#屏蔽字符" class="headerlink" title="屏蔽字符"></a>屏蔽字符</h5><p>屏蔽所有按键操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(textbox,<span class="string">"keypress"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    EventUtil.preventDefault(event);   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>屏蔽特定的字符：检测keypress事件对应的字符编码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只允许用户输入数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正则表达式判断不是数字(\d)的字符要屏蔽同时这个字符编码大于9(不屏蔽非字符键)</span></span><br><span class="line"><span class="comment">//复制粘贴等组合需要用到ctrl键，需要确保用户没有按下ctrl键 !event.ctrlKey</span></span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(text,<span class="string">"keypress"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">    <span class="keyword">var</span> charCode = EventUtil.getCharCode(event);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!<span class="regexp">/\d/</span>.text(<span class="built_in">String</span>.fromCharCode(charcode))&amp;&amp;charCode&gt;<span class="number">9</span>&amp;&amp;!event.ctrlKey)&#123;  <span class="comment">//fromCharCode()将字符编码转换为字符串</span></span><br><span class="line">        EventUtil.preventDefault(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="操作剪贴板-424"><a href="#操作剪贴板-424" class="headerlink" title="操作剪贴板 424"></a>操作剪贴板 424</h5><h4 id="14-2-3-自动切换焦点-P426"><a href="#14-2-3-自动切换焦点-P426" class="headerlink" title="14.2.3 自动切换焦点 P426"></a>14.2.3 自动切换焦点 P426</h4><h4 id="14-2-4-HTML5约束验证API-P427"><a href="#14-2-4-HTML5约束验证API-P427" class="headerlink" title="14.2.4 HTML5约束验证API P427"></a>14.2.4 HTML5约束验证API P427</h4><h3 id="14-3-选择框脚本"><a href="#14-3-选择框脚本" class="headerlink" title="14.3 选择框脚本"></a>14.3 选择框脚本</h3><p>选择框脚本是通过<select>和<option>元素创建的。</option></select></p><p>HTMLSelectElement类型特有的属性和方法：</p><ul><li>add(newOption,relOption):向控件插入新<option>元素，位置在相关项(relOption)之前</option></li><li>multiple:布尔值，是否允许多项选择；允许：type:select-multiple; 不允许：type:select-one;</li><li>options:控件中所有<option>元素的HTMLCollection</option></li><li>remove(index):移除给定位置的选项</li><li>selectedIndex:基于0的选中项的索引，如果没有则为1.多选空间只保存选中项中第一项的索引</li><li>size:选择框中可见的行数</li></ul><p>type属性由multiple决定</p><p>value属性由当前选择项决定（1.没有选中项为空字符串 2.有选中项等于其value值 3.选中项没有value值等于文本值 4.有多个选中项根据2.3取第一个选中项的值）</p><p>每个<option>元素都有一个HTMLOptionElement对象。属性如下：</option></p><ul><li>index:当前选项在options集合中的索引</li><li>label:当前选项的标签</li><li>selected:布尔值，表示当前选项是否被选中</li><li>text:选项的文本</li><li>value:选项的值</li></ul><h4 id="14-3-1-选择选项"><a href="#14-3-1-选择选项" class="headerlink" title="14.3.1 选择选项"></a>14.3.1 选择选项</h4><p>对于只允许选择一项的选择框，访问选择项的最简单方式，就是使用选择框的selectedIndex属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selectedOption = selectbox.options[selectbox.selectedIndex];</span><br></pre></td></tr></table></figure><p>对于多选的选择框，可以循环遍历选项集合，测试每个选项的selected属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSelectedOptions</span>(<span class="params">selectbox</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">var</span> option = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=selectbox.options.length;i&lt;len;i++)&#123;</span><br><span class="line">        option = selectbox.options[i];</span><br><span class="line">        <span class="keyword">if</span>(option.selected == <span class="literal">true</span>)&#123;</span><br><span class="line">            result.push(option[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-3-2-添加选项"><a href="#14-3-2-添加选项" class="headerlink" title="14.3.2 添加选项"></a>14.3.2 添加选项</h4><ol><li><p>使用DOM方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newOption = <span class="built_in">document</span>.createElement(<span class="string">"option"</span>);</span><br><span class="line">newOption.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Option text"</span>));</span><br><span class="line">newOption.setAttribute(<span class="string">"value"</span>,<span class="string">"Option value"</span>);</span><br><span class="line"></span><br><span class="line">selectbox.appendChild(newOption);</span><br></pre></td></tr></table></figure></li><li><p>使用option构造函数，兼容DOM的浏览器会返回一个<option>元素。接受两个参数，文本和值，值可选。</option></p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newOption = <span class="keyword">new</span> Option(<span class="string">"Option text"</span>,<span class="string">"Option Value"</span>);</span><br><span class="line">selectbox.appendChild(newOption);  <span class="comment">//IE8之前有问题</span></span><br></pre></td></tr></table></figure></code></pre></li><li><p>使用选择框的add方法。接受两个参数：要添加的项和位于新项之后的选项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newOption = <span class="keyword">new</span> Option(<span class="string">"Option text"</span>,<span class="string">"Option Value"</span>);</span><br><span class="line">selectbox.add(newOption,<span class="literal">undefined</span>);  <span class="comment">//最佳方案  undefined会让新选项位于列表最后</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="14-3-3-移除选项"><a href="#14-3-3-移除选项" class="headerlink" title="14.3.3 移除选项"></a>14.3.3 移除选项</h4><p>三种方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">selectbox.removeChild(selectbox.options[<span class="number">0</span>]);</span><br><span class="line">selectbox.remove(<span class="number">0</span>);<span class="comment">//接受一个参数，被移除项的索引</span></span><br><span class="line">selecrbox.options[<span class="number">0</span>]=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="14-3-4-移动和重排序"><a href="#14-3-4-移动和重排序" class="headerlink" title="14.3.4 移动和重排序"></a>14.3.4 移动和重排序</h4><p>移动:appendChild()传入一个已有的元素，会先从该元素的父节点中移除它，再把它添加到指定的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selectbox1 = <span class="built_in">document</span>.getElementById(<span class="string">"selLocations1"</span>);</span><br><span class="line"><span class="keyword">var</span> selectbox2 = <span class="built_in">document</span>.getElementById(<span class="string">"selLocations2"</span>);</span><br><span class="line"></span><br><span class="line">selectbox2.appendChild(selectbox1.options[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>重排序：insertBefore()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optionToMove = selectbox.options[<span class="number">1</span>];</span><br><span class="line">selectbox.insertBefore(optionToMove,selectbox.options[optionToMove.index<span class="number">-1</span>]);<span class="comment">//前移一个</span></span><br><span class="line">selectbox.insertBefore(optionToMove,selectbox.options[optionToMove.index+<span class="number">2</span>]);<span class="comment">//后移一个</span></span><br></pre></td></tr></table></figure><h3 id="14-4-表单序列化-P436"><a href="#14-4-表单序列化-P436" class="headerlink" title="14.4 表单序列化 P436"></a>14.4 表单序列化 P436</h3><h3 id="14-5-富文本编辑"><a href="#14-5-富文本编辑" class="headerlink" title="14.5 富文本编辑"></a>14.5 富文本编辑</h3><p>本质：在页面中嵌入一个包含HTML页面的iframe。通过设置designMode属性，这个空白的HTML可以被编辑，编辑的对象则是该页面<body>元素的HTML代码。</body></p><p>design属性有两个可能的值：off on  当设置为on时，整个文档都会变得可以编辑。</p><p>design属性只有在页面加载完才能被设定，因此需要使用onload事件处理程序来设置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"richedit"</span> <span class="attr">style</span>=<span class="string">"height:100px;width:100px;"</span> <span class="attr">src</span>=<span class="string">"blank.htm"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span> = <span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    EventUtil.addHandler(<span class="built_in">window</span>,<span class="string">"load"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        frames[<span class="string">"richedit"</span>].document.designMode = <span class="string">"on"</span>;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="14-5-1-使用contenteditable属性"><a href="#14-5-1-使用contenteditable属性" class="headerlink" title="14.5.1 使用contenteditable属性"></a>14.5.1 使用contenteditable属性</h4><p>把contenteditable属性应用给页面中的任何元素，然后用户就可以立即编辑该元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"editable"</span> id=<span class="string">"richedit"</span> contenteditable&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//js方法</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"richedit"</span>);</span><br><span class="line">div.contenteditable = <span class="literal">true</span>; <span class="comment">//true表示打开，false表示关闭，inherit表示从父元素继承</span></span><br></pre></td></tr></table></figure><h4 id="14-5-2-操作富文本"><a href="#14-5-2-操作富文本" class="headerlink" title="14.5.2 操作富文本"></a>14.5.2 操作富文本</h4><p>主要方式：document.execCommand()</p><p>参数：要执行的命令名称，浏览器是否为当前命令提供用户界面的一个布尔值，执行命令必须的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frames[<span class="string">"richedit"</span>].document.execCommand(<span class="string">"bold"</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">frames[<span class="string">"richedit"</span>].document.execCommand(<span class="string">"createlink"</span>,<span class="literal">false</span>,<span class="string">"http//www.wrox.com"</span>);</span><br></pre></td></tr></table></figure><h4 id="14-5-3-富文本选区"><a href="#14-5-3-富文本选区" class="headerlink" title="14.5.3 富文本选区"></a>14.5.3 富文本选区</h4><p>使用frame的getSelection()方法，可以确定实际选择的文本。返回一个表示当前选择文本的selection对象。</p><p>提供了一些方法，支持对选取的操作 P442</p><h4 id="14-5-4-表单与富文本"><a href="#14-5-4-表单与富文本" class="headerlink" title="14.5.4 表单与富文本"></a>14.5.4 表单与富文本</h4><p>富文本中的HTML不会被自动提交给服务器，需要手动来提取并提交。</p><p>通常添加一个隐藏表单字段，在提交表单之前，从iframe中提取出HTML，并插入隐藏的字段中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(form,<span class="string">"submit"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">    </span><br><span class="line">    target.elements[<span class="string">"comments"</span>].value = frames[<span class="string">"richedit"</span>].document.body.innerHTML;<span class="comment">//frame元素</span></span><br><span class="line">    target.elements[<span class="string">"comments"</span>].value = <span class="built_in">document</span>.getElementById(<span class="string">"richedit"</span>).innerHTML <span class="comment">//contentditable元素</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
