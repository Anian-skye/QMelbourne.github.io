<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode0134_Gas_Station]]></title>
    <url>%2F2019%2F03%2F02%2Fleetcode0134-Gas-Station%2F</url>
    <content type="text"><![CDATA[加油站的油是否够走一个来回 假设有一条环形的路，路上分布着若干个加油站 每个加油站有gas[i]的油，去往下一个加油站需要cost[i]的油 问一辆空油箱（无上限）的车从一个加油站出发是否可以回到这个加油站 可以的话返回加油站的编号，不可以的话返回-1 思路邮箱油量 tank 起点 start 中点 end 123456if(tank&lt;cost[i]) updata start tank=0else updata end updata tank updata start: 当无法前进时，更新起点分两种情况 第一种情况 start=start+1 i=start 第二种情况 start=i+1 i+1 不要忘记这个时候i也需要更新 结束条件 start==end或者start&gt;=length的时候结束 代码 123456789101112131415161718192021222324252627282930313233class Solution(object): def canCompleteCircuit(self, gas, cost): """ :type gas: List[int] :type cost: List[int] :rtype: int """ length = len(gas) start=-1 i=0 end=-2 tank=0 while(start&lt;length and start!=end): if(i&gt;=length): i = i-length #循环 tank += gas[i] if(tank&lt;cost[i]): start = max(start+1,i+1) # i,tank,end都需要重置 i=start tank=0 end=-2 else: if(start==-1): start=i # end也需要循环 不能简单的等于1+1 end=(i+1)%length tank = tank-cost[i] i+=1 if(end==start): return start else: return -1 参考资料]]></content>
      <categories>
        <category>leetcode</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode299Bulls_and_Cows]]></title>
    <url>%2F2019%2F03%2F01%2Fleetcode299Bulls-and-Cows%2F</url>
    <content type="text"><![CDATA[猜数字 299. Bulls and Cows 数位置猜对的（A）和位置没对但是数字猜对的（B） 思路一先遍历一遍，找到位置对的数字，然后把它们分别设置成-1和-2（防止查找B时重复） 再遍历一遍guess，找相同的数字 当在guess中找到一个数字n也在secret中时，分两种情况讨论： 如果countguess&lt;countsecret 则直接cow+1 如果countguess&gt;countsecret 则意味着这个n会被重复查找，可以先减去countguess-countsecret再加一 然后再次遇到这个n时就不需要减而是可以直接+1 12345678910111213141516171819202122232425262728class Solution(object): def getHint(self, secret, guess): """ :type secret: str :type guess: str :rtype: str """ bull=0 cow=0 s = list(secret) g = list(guess) length = len(secret) for i in range(length): if(s[i]==g[i]): bull+=1 s[i]=-1 g[i]=-2 d = set([]) for i in range(length): if(g[i] in s): scount = s.count(g[i]) gcount = g.count(g[i]) if(gcount&gt;scount and g[i] not in d): cow=cow - (gcount-scount) +1 d.add(g[i]) else: cow+=1 return str(bull)+'A'+str(cow)+'B' 自己想的思路，感觉很繁复，速度超慢 思路二 他山之石原理其实是一样的，就是通过一些巧妙的思路减少了时间复杂度 首先还是要先把bull找出来，在找的过程中可以用字典记录下那些不是bull的数字，以及他们分别出现的次数 然后再遍历guess字典，cow其实就是min(dic_guess[i],dic_secret[i])的和 两个用到的python技巧 12345678#zip函数#可以将两个可迭代元素两两结合变成一个元祖A = [1，2，3]B = [4，5，6]C = zip(A,B) #[(1,4),(2,5),(3,6)]#为字典设置初始值dic_secret = collections.defaultdict(lambda: 0) 代码 123456789101112131415161718192021class Solution(object): def getHint(self, secret, guess): """ :type secret: str :type guess: str :rtype: str """ bull=0 cow=0 dic_secret = collections.defaultdict(lambda: 0) dic_guess = collections.defaultdict(lambda: 0) for i,j in zip(secret,guess): if(i==j): bull+=1 else: dic_secret[i]+=1 dic_guess[j]+=1 for item in dic_guess: cow += min(dic_guess[item],dic_secret[item]) return str(bull)+'A'+str(cow)+'B' 参考资料]]></content>
      <categories>
        <category>leetcode</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode189_Rotate_Array]]></title>
    <url>%2F2019%2F02%2F21%2Fleetcode189-Rotate-Array%2F</url>
    <content type="text"><![CDATA[以某一点为中心旋转数组 注意这个k是从右数k步，而不是从左数k步 如果k比数组长度大，则循环数，也就是k=k-l 如果用python切片来做就很简单，但是空间复杂度不是o(1) 12345678910class Solution(object): def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. """ if k &gt; len(nums): k = k-len(nums) nums[:] = nums[-k: ] + nums[ :-k] #负数指从右向左数 然后看到一种很巧妙的方法 依次反转后k个和前l-k个，最后反转整个数组 如： 1，2，3，4，5，6，7 k=3 4，3，2，1，5，6，7 反转前l-k个 4，3，2，1，7，6，5 反转后k个 5，6，7，1，2，3，4 反转整个数组得到答案 12345678910111213141516class Solution(object): def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. """ l = len(nums) if(k&gt;l): k=k-l for i in range((l-k)/2): nums[i],nums[l-k-1-i] = nums[l-k-1-i],nums[i] for i in range(l-k,l-k+k/2): nums[i],nums[l-i-1+(l-k)] = nums[l-i-1+(l-k)],nums[i] for i in range(l/2): nums[i],nums[l-i-1] = nums[l-i-1],nums[i] 还有其他不需要额外空间的解法，二刷的时候可以看一下 参考资料 http://www.cnblogs.com/grandyang/p/4298711.html]]></content>
      <categories>
        <category>leetcode</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Topological_Spines_A_Structure-Preserving_Visual_Representation_of_Scalar_Fields]]></title>
    <url>%2F2019%2F02%2F21%2FTopological-Spines-A-Structure-Preserving-Visual-Representation-of-Scalar-Fields%2F</url>
    <content type="text"><![CDATA[Topological spines:可以展示梯度区域的拓扑和几何结构的可视化方案 [TOC] 同其他拓扑表示方法相比（contour tree)，文章提出的新方法可以保持局部的几何结构， 方法：基于极值图的方法 极值图：这些More-Smale复合体的稀疏子集保持了结构的重要信息并且不会出现混乱和遮挡问题 Introduction现有的拓扑表示方法在特征提取，数据挖掘，降维等问题上有着好的表现，但是不能解决需要提取数据空间特征的任务 同时保持拓扑结构和几何结构： 提取出嵌套的层次结构并且critical点相互连接 避免混乱和遮挡 文章提出extremum图（极值图）: 几何上相邻的极值点通过鞍点连接起来 这个结果即保持了contour-tree的拓扑结构也保持了morse-smale的几何临近关系 Extremum GraphsMores-Smale ComplexMores Functionscritical point：一阶导数为零的点 Hessian: f二阶偏导的矩阵 如果critical point x的Hessian是一个可逆矩阵，则称这个点为non-singular 如果Hessian不可逆（行列式为0）则这会产生一个特殊的零空间，Hessian就不能很好地描述在这个点function发生了什么 如果function f的所有cirtical point都是non-singular，则这个function被称为Morse Function 把Hessian矩阵对角化，所得矩阵的负特征值的个数称为critical point的index，这个数就是有多少个不同的方向，也是index的最大值 比如有一个2-dimensional mainfold，那么critical point的index最大值就是2 index最大值是n，最小值是0，有n-2个鞍点 Morse Complex这个mainfold上的每一个点都有一个随梯度陡峭上升的方向。想象mainfold上所有的点都朝着指定的方向流动 把这个mainfold分解成积分曲线，这些曲线积分是不同微积分方程的轨迹或者解。根据微积分的性质，这些曲线存在并且他们不会相交 因为这个function随着flow是增加的，因此我们总能到达最大值，相反的也可以得到最小值。因此对每一个点，都可以为他定义起点和终点 stable manifold at u: u是一个critical point，u和所有以u为destination的点构成了u的stable mainfold unstable mainfold的概念正好相反 Morse Complex就是使用stable和unstable mainfold来分解总mainfold 曲线积分会穿过一对critical points，这些曲线积分的组合构成了complex的cells. 参考资料 Topological Spines: A Structure-Preserving Visual Representation of Scalar Fields https://www.quora.com/What-is-the-Morse-complex]]></content>
      <categories>
        <category>vis</category>
        <category>graph</category>
        <category>topo</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spines:]]></title>
    <url>%2F2019%2F02%2F21%2FSpines%2F</url>
    <content type="text"><![CDATA[参考资料]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode80_Remove_Duplicates_from_Sorted_Array_II]]></title>
    <url>%2F2019%2F02%2F20%2Fleetcode80-Remove-Duplicates-from-Sorted-Array-I%2F</url>
    <content type="text"><![CDATA[去除数组中重复两次以上的数字 26题的升级版 重复两次以上的需要被去除，保存一个count值来记录数字重复的次数 关键在于要保存一个result值，始终指向已经去除好的数组的后一位，跟26题中result作用一样 然后思路就很简单了： 如果count&lt;=2 result随着变化，nums[result]=nums[i] result+1 如果count&gt;2 result则不变，在当前位置等待新的数据 1234567891011121314151617181920class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ n = len(nums) if(n&lt;=2): return n count = 1 result = 1 for i in range(1,n): if(nums[i-1]==nums[i]): count+=1 else: count=1 if(count&lt;=2): nums[result] = nums[i] result+=1 return result]]></content>
      <categories>
        <category>leetcode</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The_Core_Decomposition_of_Networks_Theory_Algorithms_and_Applications]]></title>
    <url>%2F2019%2F02%2F19%2FThe-Core-Decomposition-of-Networks-Theory-Algorithms-and-Applications%2F</url>
    <content type="text"><![CDATA[[TOC] 有关核分解（core-decomposition）的深度讨论，主要关注 基础理论和概念 不同设置下高效的算法 相关应用 节点重要性的概念在网络分析中十分重要。core decomposition可以在不同领域高效的衡量节点重要性 图G的k-core就是一个所有顶点都有至少k个邻居的最大子图。节点的core值就是包含该节点的最高层次的k值 c(v8) = 1 c(v1) = 2 c(v6) = 3 现有工作： 分为两大类：概念和算法；应用 基础概念 Simple Graphs围绕core decomposition的一些概念 K-shell subgraph: k-shell是G的一个子图，包含属于k-core但不属于（k+1）-core的顶点 K-core subgraph: 满足所有顶点的度都大于等于k的最大子图 graph degeneracy: G的k-core子图的最大k值 core number: c(v)=k 如果v属于k-core但不属于(k+1)-core 根据概念可以得到： 注意：k-core子图并不一定是连通图 其他类型图有向图 D-cores是k-core在有向图上的扩展，(k, l)-core用来代表某个子图所有的节点有至少k个入度或者l个出度 权重图 带权重的图比简单图更难计算，因为很难界定节点的core值 Signed Graphs singed Graphs表示节点间存在正向或者负向关系的网络（比如信任和怀疑，朋友关系或者敌对关系等） 动态网络 节点和边都有可能增加或者减少。这类网络的难点在于只通过少量计算去监视所有节点core值的变化，避免重新执行整个分解算法。 Temporal Graph 这种网络是动态网络一种特殊形式，网络内每一条边都有一个时间戳，用来标记他们出现的时间段 （k,h)-core k表示节点的度，h表示同这个顶点相连的特殊边的个数 Probabilistic Graph 图中节点或边的存在具有不确定性，这种不确定性根据具体情况而定 Multilayer Graph 节点或者边不一定是同一种类型 Hidden graphs 在一个hidden graphs中边集合没有预先给出，而是通过f()来计算得到其是否存在 Core Decomposition的一般化最初core分解是同节点的度有关，但实际上可以推广到其他节点的性质上，这些性质都可以用来计算得到core Core Decomposition的扩展Truss Decomposition用三角（长度为3的环图）的概念来扩展 Density-friendly Core Decompositioncore Decomposition有一个缺点，这些嵌套的k-core子图并不会跟原图的密度关系保持一致，也就是说最大的k-core子图并不一定是原图上密度最大的子图。 密度友好的分解满足 外层子图的密度要低于内层子图的密度 最内层子图的密度是最大的 Peak Decompositionk-core分解的另一个缺点是他是全局计算的，当图中存在密度不同的区域时，较稀疏的区域有可能被忽略 k-peak分解的目的是找到图中不同区域的中心，将图的全局结构看成是区域的集合，每一个区域都像是一个拥有中心峰顶的山 参考资料 The Core Decomposition of Networks: Theory, Algorithms and Applications]]></content>
      <categories>
        <category>vis</category>
        <category>graph</category>
      </categories>
      <tags>
        <tag>paper，suvery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Topolayout_Muli-Level_Graph_Layout_by_Topological_Features]]></title>
    <url>%2F2019%2F02%2F19%2FTopolayout-Muli-Level-Graph-Layout-by-Topological-Features%2F</url>
    <content type="text"><![CDATA[[TOC] TopoLayout，基于拓扑特征的多层次的绘制不连通图的算法 未读完 为了解决图规模的限制和可视化质量的问题提出了多层次的绘制方法，现有的方法很难看出高层结构内部的低层结构。 文章提出了基于特征的方法，将感兴趣的特征迭代的提取出来并在低层次中用元节点代替。绘制每一个特征的算法由特征的类型决定。 与其他层次绘制方法不同的是，topolayout是自下而上的绘制，在图的高层次考虑低一级层次绘制所需要的空间。 相关工作 多层次的绘制算法 不能展示数据中高层和底层的特征 交互探索的层次绘制 图绘制中的拓扑特征 都是在单一层次上探索拓扑结构（运算时间长，特征单一） 高维嵌入（High-Dimensional Embedder HDE） Topolayout可以检测何时可以使用HDE 算法TopoLayout包含四个主要过程 A. Decomposition参考资料 TopoLayout: Multi-Level Graph Layout by Topological Features]]></content>
      <categories>
        <category>vis</category>
        <category>graph</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k-peak]]></title>
    <url>%2F2019%2F02%2F17%2Fk-peak%2F</url>
    <content type="text"><![CDATA[[TOC] k-core是所有节点的度都大于k的最大子图 k-cores分解算法缺陷：k-cores是全局计算的，如果网络里存在着密度不同的区域，则那些稀疏的区域会被忽略 ​ k-cores不能捕捉到局部结构信息 shell, contour,peak,mountain把图的结构看成一个区域的集合，每个区域都像是一个有着中心峰值的山。这些山画在拓扑地图上用等高线来表示他们的海拔。 k-shell: 递归的剥夺网络中度为K的节点，直到网络中不存在度为k的节点，被剥夺的这些节点就成为k-shell k-contour: 满足如下条件的最大子图：1.K-contour不会包含来自高层contour的节点 2.k-contour内的每一个节点和contour内的节点有至少k个相连 peak number: 一个节点的peak number是他所属的k-contour的k值 k-peak分解： 为每一个顶点分配一个k-contour k-peak: 是j-contours联合的子图,对所有的j大于等于k k-peak分解是唯一的，每一个节点都有唯一的peak number k-mountain:是原图G的子图。满足Ckv&lt;C(k+1)v。 Ckv是指在原图中去掉k-peak的节点后节点v的core值 k-mountain包含k-contour和那些高一层k-contour被移除后core值发生变化的点 k-peak分解算法做法：反复移除最高core的节点并且计算剩下节点的core值直到图为空 一个节点的peak值就是他被移除前的度 123456789101112131415161718192021222324def get_kpeak_decomposition(G): G.remove_edges_from(G.selfloop_edges()) G = removeSingletons(G) orig_core_nums = nx.core_number(G) H = G.copy(); H_nodes = set(G.nodes()) current_core_nums = orig_core_nums.copy() peak_numbers = &#123;&#125; # Each iteration of the while loop finds a k-contour while(len(H.nodes()) &gt; 0): # degen_core is the degeneracy of the graph degen_core = nx.k_core(H) # Degen-core # Nodes in the k-contour. Their current core number is their peak number. kcontour_nodes = degen_core.nodes() for n in kcontour_nodes: peak_numbers[n] = current_core_nums[n] # Removing the kcontour (i.e. degeneracy) and re-computing core numbers. H_nodes = H_nodes.difference(set(kcontour_nodes)) H = G.subgraph(list(H_nodes)) current_core_nums = nx.core_number(H) return peak_numbers, orig_core_nums 可视化mountain plot简明刻画了网络总体结构并且展示了节点core和peak值的不同，有助于理解k-contours上的节点依赖性。 不重叠处理： We associate each node in the graph with the contour whose removal produced the greatest drop in itscore number: these nodes constitute a plot-mountain. (Note that a node in the contour itself may not be assigned to that plot-mountain if it were more affected by an earlier plot-mountain.) The resulting plot-mountains are thus non-overlapping. 将plot-mountains按照与之相关联的contours的peak值递减排序 在每一个mountain的内部，将节点按照core值递减排序，对于core值相同的节点，按照peak值排序 mountain plot解释 mountain的数量代表图中独特区域的个数 最左边的山代表图中连接最为紧密的区域，越往右代表越稀疏的区域 高度代表core值，宽度代表节点数量（观察发现，每一个mountain内最大peak的点都是让山的高度上升的点） core值和peak值的不同给出了moutain所代表子图的连通性和独立性信息 参考资料 The k-peak Decomposition: Mapping the Global Structure of Graphs]]></content>
      <categories>
        <category>vis</category>
        <category>graph</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A_Survey_of_Two-Dimensional_Graph_Layout_Techniques_for_Information_Visualisation]]></title>
    <url>%2F2019%2F01%2F27%2FA-Survey-of-Two-Dimensional-Graph-Layout-Techniques-for-Information-Visualisation%2F</url>
    <content type="text"><![CDATA[[TOC] 图布局算法的综述 主要内容 回顾了大图应用于集群信息可视化的优点 讨论了专用于大图可视化的一系列技术 图绘制算法有以下分类：力导向布局算法，图布局中的降维，计算性能提升 文章的目的是对当前可行的图布局算法，尤其是可以被用作可视化的算法提供一个详细的评估。 介绍图的绘制有两个不同的方向：理论算法研究；信息可视化的应用研究 网络的可视化目的是为了分析并且理解网络。在信息可视化的领域，绘制图有助于提出假设并且在数据中验证 文章结构： 介绍主要的图绘制技术：基于降维的力导向；计算性能改进技术（多层次布局） 利用节点属性进行大图可视化的技术 结论以及对未来研究的展望 力导向及相关算法大部分图绘制算法都是基于力导向的，将图看成一个物理系统，系统内的节点都被某种力排斥或者吸引 力导向的原型算法和多种变形 降维布局和力导向布局的相似处及延伸 图规模的增大出现了一些提高计算性能的算法 算法比较 力导向布局力导向布局算法的先驱是Tutte的重心算法。（两个物体的重心是他们所施加重力互相抵消的点） 算法思想：最初至少固定三个点，然后将其他点放置在这些点跟他们邻居的重心的位置上 Eades的spring-embedded力导向布局被广泛接受并且启发了其他的布局算法 绘制图的美学理论图绘制的美学同图的可读性有关，好的可读性可以让用户更好的理解图 在一个布局算法中包含所有的美学理论是不可能的，因为他们之前存在互斥，达到一个标准有可能需要破坏另一个标准。 力导向布局算法有两种方法： 基于Eades的spring-embedder算法使用弹簧电场系统并找到能够使系统内所有节点总作用力为0的平衡点 适用于节点数少于50的网络 改编1 针对运行速度和图的简化 主要根据相互连接节点的属性进行优化，希望得到服从下面条件的布局：节点均匀分布，边交叉减少，统一的边长，对称，充分填充画布 基于优化问题 参考资料 A Survey of Two-Dimensional Graph Layout Techniques for Information Visualisation]]></content>
      <categories>
        <category>vis</category>
        <category>graph</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode392Is_Subsequence]]></title>
    <url>%2F2019%2F01%2F17%2Fleetcode392Is-Subsequence%2F</url>
    <content type="text"><![CDATA[是否是子串 s能由t中的字符构成，但是不能改变字符在t中的位置 一开始把这个题想复杂了，字符并不是完全相邻一致的，只是相对位置一样就行了，所以只要遍历一次t就可以得到答案了 保存一个s的指针，每次得到相同的字符就+1，直到等于s的长度返回True即可。 12345678910111213141516class Solution(object): def isSubsequence(self, s, t): """ :type s: str :type t: str :rtype: bool """ if(not s): return True s_ptr = 0 for item in t: if(s[s_ptr] == item): s_ptr+=1 if(s_ptr==len(s)): return True return False]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode241_Different_Ways_to_Add_Parentheses]]></title>
    <url>%2F2019%2F01%2F14%2Fleetcode241-Different-Ways-to-Add-Parentheses%2F</url>
    <content type="text"><![CDATA[添加括号得到表达式的不同值 分治 按照运算符来分割字符串，当左右两边都是数字的时候进行计算，否则继续分割 问题出在一些细节问题上： 如何保存单次计算的到的值 什么时候像结果数组里面添加值 跟22的区别在于回溯里面还要有循环，而不是可以一条语句判断结束，也就是分治的思想 保存在数组中，每一次回溯都会有自己新的result数组，最后返回的是最外层的result 最外层的result数组，当第一次分割的字符串两边得到运算结果时才会更新。 12345678910111213141516171819202122class Solution(object): def diffWaysToCompute(self, input): result=[] if(input.isdigit()): return [int(input)] for i in range(len(input)): if(input[i] in '*-+'): left = self.diffWaysToCompute(input[:i]) right = self.diffWaysToCompute(input[i+1:]) op = input[i] for i in left: for j in right: result.append(self.helper(i,j,op)) return result def helper(self,before,after,op): if(op=='-'): return before-after elif(op=='+'): return before+after elif(op=='*'): return before*after 参考资料 http://bookshadow.com/weblog/2015/07/27/leetcode-different-ways-add-parentheses/]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>分治</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contextual_Contour_Visual_Analysis_on_Dynamic_Multi-Relational_Clustering]]></title>
    <url>%2F2019%2F01%2F14%2FContextual-Contour-Visual-Analysis-on-Dynamic-Multi-Relational-Clustering%2F</url>
    <content type="text"><![CDATA[动态关系数据可视化分析 [TOC] ##概览 文章介绍了一个探索分析系统：contexTour,这个系统生成可以探索多维集群活动的可视化表达，包括热点话题，代表用户以及集群生成的话题以及他们的进化。 系统包括两个重要的部分： Dynamic Realtional Clustering(DRC) 有效追踪集群的进化并可以平滑的适应集群的变化 Dynamic Network Contour-map(DNC) 多维的可视化社区活动和进化 Multi-relational: DRC同步地聚集多重关系，使得所有聚类在所有关系中都是一致的（DRC clusters multi-relations simultaneously such that all clusters are consistent across all relations). Soft-clustering: DRC生成软聚类结果提供一个有效的总结方法，可以让DNC选择重要的实体并且计算相似性 Time-evolving: DRC可以按照时间来追踪集群的变化，让DNC可以生成一个平滑的动态布局 Adaptive: DRC可以按照时间来自动调整集群的数目并且按概率生成集群的过渡，让DNC可以追踪集群 Scalable：算法时间空间都是线性的，可以处理大规模数据 DRC 注释： $W_{t}^{r}$ 时间t时关系r的矩阵 为了表达简便，省略r和t 其中 $p_{k}$ 是这个关系在集群k中的先验概率 $p_{t|k}^{q}$ Sq中第t个实体在集群k中存在的概率 矩阵格式 问题规划优化问题：目标是找到可以完美解释随时间变化数据实体的多重关系的smoothly evolving soft clusters DNC可视化DRC的结果 将实体总结成一个网络 可视化的表现随时间的进化以及维度转换 网络总构建和总结重点：将数据集缩小以便高效清晰的进行可视化 选择重要的实体衡量实体重要性 Cluster important 是实体i在cluster k中的重要性得分，等于$p_{i|k}$ 总重要性是指实体i在所有cluster中的得分之和 选取子集的抽样原则 选择具有全局高$s_{i}$的实体 每一个个cluster中选择固定个数的实体，每一层都倾向选择高$p_{i|k}$的实体 混合使用两种方法 相似度计算和网络构建将两个实体间的相似度定义为两个实体模糊集的成员得分的相似度 根据相似度来构建网络 如果$s_{i,j}$的值在top-a highest中就在i和j之间添加一条边（a选5%） 对于孤立的实体，将他们同大组件中最相近的实体连接起来 轮廓布局在整体网络上覆盖一个轮廓图来描述实体分布的密度 First put kernel functions over all the sampled entities then estimate the joint density distribution of allkernels. 把每一个未被抽样的实体分配给与他最相近的抽象实体 参考资料 ContexTour: Contextual Contour Visual Analysis on Dynamic Multi-Relational Clustering]]></content>
      <categories>
        <category>vis</category>
        <category>graph</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode22_Generate_Parentheses]]></title>
    <url>%2F2019%2F01%2F13%2Fleetcode22-Generate-Parentheses%2F</url>
    <content type="text"><![CDATA[生成括号，回溯 看到这种枚举所有可能的题就很自然的想到回溯，就是没想到咋写.. 看了答案 结束条件肯定是字符串的长度==n*2 剩下的问题就是如何添加括号 记录下左右括号的个数，左括号个数小于n添加左括号，右括号个数小于左括号添加右括号 123456789101112131415161718class Solution(object): def generateParenthesis(self, n): """ :type n: int :rtype: List[str] """ s='' result=[] def parenthesis(s,left,right): if(len(s)==n*2): result.append(s) return if(left&lt;n): parenthesis(s+'(',left+1,right) if(right&lt;left): parenthesis(s+')',left,right+1) parenthesis(s,0,0) return result]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bubble_Treemaps_for_Uncertainty_Visualization]]></title>
    <url>%2F2019%2F01%2F13%2FBubble-Treemaps-for-Uncertainty-Visualization%2F</url>
    <content type="text"><![CDATA[气泡树图 摘要文章提出了一种新型的气泡树图，在图中特意为额外的视觉变量留出空间。通过这个增加的视觉设计空间，可以将层次结构数据及其不确定性编码在一个结合的图中。文章提出了一个层次的，基于力的打包气泡的算法去计算气泡树图，在图中，每一个节点都被可视化成一个嵌套轮廓圆弧。气泡树图不需要颜色和纹理，这些可以用来提供额外的设计选择。 介绍气泡树图在紧凑性和可读性中间找到一个好的折中方案. 文章认为不确定性是每一个节点可能值的分布，是确定值的反义。仅仅展示平均值不足够描述一个分布，我们需要的可视化方案应该能够展示多种附加的统计学数值，这样可以帮助读者更好的理解数据。 文章的三个贡献： 一个保持空间紧密性和可读性的基于打包气泡的布局 一个供额外可视化变量使用的节点轮廓参数域 介绍了不同不确定值的模型以及他们和层次化数据的关系 概览 步骤：给定一个具有不确定值的层次数据，从每一层提取出分布参数然后把这些参数对应为气泡，然后再分别为叶子节点和内部结点定义基于弧的轮廓（为了得到一个紧凑的布局，使用了力导向模型） 文章的目标是可以一次展示多个分布的统计性质，为了达到这个目标，并不去追求划分完美的划分空间，而是刻意分配空间用于编码这些额外信息。 建模并传播不确定性参考资料 Bubble Treemaps for Uncertainty Visualization]]></content>
      <categories>
        <category>vis</category>
        <category>graph</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode131_Palindrome_Partitioning]]></title>
    <url>%2F2019%2F01%2F11%2Fleetcode131-Palindrome-Partitioning%2F</url>
    <content type="text"><![CDATA[找出字符分割后全是回文子串的分割方式 题目不是要找出所有的回文子串，而是要按照字符分割来找，如果一种分割方式分割后所有的子串都是回文就把这一组回文加入到结果中，否则不加入 因此不能简单的对子串进行遍历 可以用递归回溯的方法，DFS 1234567def helper(self,s,path,result): if not s: ## 当传入空串时则证明前面的均为回文，可以加入结果 result.append(path) for i in range(1,len(s)+1): prefix = s[:i] if self.isPali(prefix): self.helper(s[i:],path+[prefix],result) 123456789101112131415161718192021222324class Solution(object): def partition(self, s): """ :type s: str :rtype: List[List[str]] """ result=[] path=[] self.helper(s,path,result) return result def helper(self,s,path,result): if not s: result.append(path) for i in range(1,len(s)+1): prefix = s[:i] print(prefix) if self.isPali(prefix): self.helper(s[i:],path+[prefix],result) def isPali(self,s): for i in range(len(s)): if s[i] != s[len(s) - i - 1]: return False return True]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[An_Om_Algorithm_for_Cores_Decomposition_of_Networks]]></title>
    <url>%2F2019%2F01%2F11%2FCores-Decomposition-of-Networks%2F</url>
    <content type="text"><![CDATA[识别网络中联系紧密的子组的算法 [TOC] 介绍文章介绍了一个可以将网络分解为更小的部分，识别出网络中联系紧密的子组（cohesive subgroups）的时间复杂度为o(m)的算法。 相关概念cores 12345令G=（V,L)，V是顶点的集合，L是边的集合。n=|V|,m=|L|存在一个子图Hk，子图内所有顶点的度&gt;=k，且这个子图是总图中满足上述条件的最大子图，则说这个子图是k-core性质：1. i&lt;=j =&gt; Hj ⊆ Hi2. cores并不一定是连接的子图 算法从图G中删除度小于k的顶点和与顶点相连的边，剩下的图就是k-core图 参考资料]]></content>
      <categories>
        <category>vis</category>
        <category>graph</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Identifying_and_Comparing_Multiple_Graphs_at_a_Glance]]></title>
    <url>%2F2019%2F01%2F05%2FIdentifying-and-Comparing-Multiple-Graphs-at-a-Glance%2F</url>
    <content type="text"><![CDATA[提取大图结构信息 [TOC] 摘要文章提出“Graph Thumbnails”，是一种图标式网络数据高层结构的可视化。相比其他大图可视化技术作者认为这个技术的优点是： 计算是线性的 同形的图会得到同样的缩略图 提供了图结构的准确信息 文章通过总结一系列物种蛋白质-蛋白质相互作用的网络来证明这种表达的有效性 介绍传统的算法在树状网状图上表现良好，但是在无标度网络（典型特征是在网络中的大部分节点只和很少节点连接，而有极少的节点与非常多的节点连接）和小世界网络（在这种网络中大部分的节点彼此并不相连，但绝大部分节点之间经过少数几步就可到达。）会出现毛球问题（图a）。邻接矩阵可以用来解决上述问题，但是当节点的数据增大时，行和列会非常拥挤，变得难以理解（图b) 论文提出的“Graph Thumbnail”可以从复杂大规模网络中提取出能保持的结构和等级信息的概览图。 这种可视化方案的作用有三种： 识别： 从大规模数据集中识别出网络 比较：寻找相似网络或找出异常网络 概览：迅速得到一个网络的关键结构信息 论文的主要贡献： 一个线性的，唯一的，准确的可以得到网络表现的算法 详细介绍了缩略图设计的考虑演变过程，介绍了用来获得图的层次信息的分解选择以及缩略图的可视化元素 评估了人们使用缩略图，矩阵图，节点连接图来分辨不同图相似性的能力 评估了人们使用缩略图，矩阵图，节点连接图来分辨不同图结构细节的能力 在实际应用中使用缩略图 设计层次分解技术Calculate a hierarchy of k-connected subgraphs in the network, i.e., subgraphs for which between each pair of vertices there are at least k vertex-disjoint paths. 计算网络中k连接子图的层次。在子图中，每一对顶点之间都存在至少k个顶点不相交的路径。 缩略图的层次分解 k&gt;2时，对一个图G连续移除当前度小于k的结点，留下的的各连通分量称为G的k-cores； k=1,2时，k-cores定义为k-连通分量。（根据节点边的数量计算） 蓝色是1连通分量，绿色是2连通分量，橘色是3-core分量（节点度分别为1，2，3） 层次的可视化方案五个设计要求: 成为一种大图数据标准的可视化方法之一； 在支持small-multiple对比的基础上尽可能多地提高可读性； 使各个层次结构内部的视觉元素保持清晰； 视觉元素的规模能够传递层次结构规模的信息； 适用于任意图数据。 作者依据以上提出的五项设计要求，比对了三种常见层次数据可视化方法，最后选定线性时间复杂度的circle packing[7]作为Graph Thumbnails的最终表现形式。它的主体为circle packing下的布局，而边角为各层次结构在边、结点的分布信息以及结点度数分布信息。相对而言，这种表现形式的可扩展性更高，对空间的利用也比较好。 实例作者利用Graph Thumbnails对生物数据库DIP (Database of Interacting Proteins)2008至2017年的数据进行了可视化（见图4）。蛋白质交互数据是学者通过各种实验归纳而手动标记而成的，对于每一条边都会有相应的显著水平，每一年的数据都在不断完善。在Graph Thumbnails的可视化下，可以直接了解到每一年各种微生物研究的发展水平并分析不同微生物之间蛋白质交互方式的差异。 小结Graph Thumbnails可以较好地支持用户纵观大量大图数据并进行对比。在未来的工作中，如何利用Graph Thumbnails对图数据进行交互式的探索以便于深入分析具体网络性质是一个具有广泛应用前景的方向；此外，目前的circle packing布局还有待进一步探索，或能对最终可视化结果增添更多图的拓扑结构信息。 参考资料 Graph Thumbnails: Identifying and Comparing Multiple Graphs at a Glance]]></content>
      <categories>
        <category>vis</category>
        <category>graph</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode5_Longest_Palindromic_Substring]]></title>
    <url>%2F2018%2F12%2F27%2Fleetcode5-Longest-Palindromic-Substring%2F</url>
    <content type="text"><![CDATA[找到最长的回文子序列 寻找最长回文子序列 回文子序列的特点就是有对称轴，左右两边相等。因此依次遍历字符串的每个字符，计算如果这个字符是对称轴得到的回文子序列，返回最长的子序列。 需要考虑的一个问题是，当字符串长度是偶数时，对称轴不是字符，而是在中间两个字符之间 代码: 123456789101112131415161718class Solution: # @return a string def getlongestpalindrome(self, s, l, r): while l &gt;= 0 and r &lt; len(s) and s[l] == s[r]: l -= 1; r += 1 return s[l+1 : r] def longestPalindrome(self, s): palindrome = '' for i in range(len(s)): # 对称轴是s[i] len1 = len(self.getlongestpalindrome(s, i, i)) if len1 &gt; len(palindrome): palindrome = self.getlongestpalindrome(s, i, i) # 对称轴在s[i]和s[i+1]之间 len2 = len(self.getlongestpalindrome(s, i, i + 1)) if len2 &gt; len(palindrome): palindrome = self.getlongestpalindrome(s, i, i + 1) return palindrome Manacher算法奇偶性首先解决奇偶回文字符串要分开求的问题，把问题简化 为了将最长子串长度为奇数和偶数这两种情况统一转成奇数情况处理，Manacher’s算法在输入字符串的每个字符之间加了一个特殊字符； 为了简化处理过程中遍历字符串时对边界条件的判断，在开头加上另一个特殊字符，这些特殊字符要保证不会出现在任何输入字符串里，见下图： 这样每一个回文字符串都是一个奇数串 算法核心保存一个数组p，记录以每一个字符为对称轴时的最长回文字符，算法的核心就是计算这个数组 （实际上这个p是新数组每一个字符为对称轴时最长回文字符的半径） 同时保存一个当前最长回文字符串 current_longest，以及这个字符串的中心center,和他的右边界mx 分两种情况讨论 s[i]在current_longest中 记j为i关于center的对称点 a. 如果i+p[j]&lt;mx 则说明以s[i]为对称轴的回文序列均在current_longest中 ​ 直接让p[i]=p[j] ​ b. 如果i+p[j]&gt;=mx 则说明以s[i]为对称轴的回文序列一部分在current_longest中，还有一部分不确定，需要继续遍历 但可以确认的是p[i]至少大于mx-i 写成代码 123456if(i+p[center*2-i]&lt;mx): p[i]=p[center*2-i]else: p[i]=mx-i# 可以简化为一句代码p[i] = min(p[center*2-i],mx-i) i不在current_longest中 没有办法只能将p[I]设为1，然后逐一遍历 遍历求最大回文12while (i - p[i] - 1) &gt; 0 and (i + p[i] + 1) &lt; len(s_new) and s_new[i - p[i] - 1] == s_new[i + p[i] + 1]: p[i] += 1 P[i]相对源字符串保存的是长度，但是相对于新字符串保存的是半径，所以可以用上述求 整体代码1234567891011121314151617181920212223242526class Solution: def pre_process(self, s): return "".join(("$#", "#".join(s), "#")) # @return a string def longestPalindrome(self, s): s_new = self.pre_process(s) p = [0] center = 0 mx = 0 for i in range(1, len(s_new)): # 情况2，s[i]不在current_longest_p_str中 if i &gt; mx: p.append(0) # 情况1，s[i]在current_longest_p_str中 else: p.append(min(mx - i, p[2 * center - i])) # 没办法，只能一个一个去匹配了 # 注意，对于以s[i]为中心的最长回文子串完完整整包括在current_longest_p_str的情况，while循环不会执行，想想为什么 while (i - p[i] - 1) &gt; 0 and (i + p[i] + 1) &lt; len(s_new) and s_new[i - p[i] - 1] == s_new[i + p[i] + 1]: p[i] += 1 # 更新current_longest_p_str相关信息 if p[i] &gt; mx - center: center = i mx = i + p[i] return s_new[center - p[center]: center + p[center] + 1].replace("#", "") 参考资料 https://segmentfault.com/a/1190000003914228 http://ju.outofmemory.cn/entry/130005]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue动画]]></title>
    <url>%2F2018%2F12%2F27%2Fvue%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[vue动画 [TOC] Vue动画vue中css动画原理在需要加动画的元素外边包裹transition标签 1234567891011121314151617181920212223 &lt;style&gt; .fade-enter &#123; opacity: 0; &#125; .fade-enter-active &#123; transition: opacity 3s; &#125; .fade-leave-to&#123; opacity:0 &#125; .fade-leave-active&#123; transition: opacity 3s; //监听opacity，一旦发生变化让变化三秒后完成 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition name="fade"&gt; &lt;!-- name对应fade-enter中的fade，如果不写name则写v-enter--&gt; &lt;div v-if="show"&gt;Hello world&lt;/div&gt; &lt;/transition&gt; &lt;button @click="handleClick"&gt;切换&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; Animate.css库使用keyframe动画123456789101112131415161718@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125;.fade-enter-active &#123; transform-origin:left center; animation: bounce-in 1s;&#125;.fade-leave-active&#123; transform-origin:left center; animation: bounce-in 1s reverse; 可以不用默认的类名，自己重命名自定义 123456789101112131415 .enter&#123; transform-origin:left center; animation: bounce-in 1s; &#125; .leave&#123; transform-origin:left center; animation: bounce-in 1s reverse; &#125;&lt;transition name="fade" enter-active-class="enter" leave-active-class="leave"&gt; &lt;div v-if="show"&gt;Hello world&lt;/div&gt; &lt;/transition&gt; 利用这一点可以使用animate库 123&lt;transition name="fade" enter-active-class="animated swing" leave-active-class="animated wobble"&gt; &lt;div v-if="show"&gt;Hello world&lt;/div&gt; &lt;/transition&gt; 第一次显示时添加动画 添加appear 和 appear-active-class 1234&lt;transition name="fade" appear enter-active-class="animated swing" leave-active-class="animated wobble" appear-active-class="animated swing"&gt; &lt;div v-if="show"&gt;Hello world&lt;/div&gt; &lt;/transition&gt; 同时使用过渡和动画123456789101112131415161718192021222324&lt;style&gt; .fade-enter,.fade-leave-to&#123; opacity:0; &#125; .fade-enter-active,.fade-leave-active&#123; transition: opacity 3s; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition :duration="&#123;enter:5000,leave:10000&#125;" &lt;!-- 可以自定义动画时间 --&gt; type="transition" &lt;!-- 定义动画时长以transition为准 --&gt; name="fade" appear &lt;!-- 加入过渡动画--&gt; enter-active-class="animated swing fade-enter-active" leave-active-class="animated wobble fade-leave-active" appear-active-class="animated swing"&gt; &lt;div v-if="show"&gt;Hello world&lt;/div&gt; &lt;/transition&gt; &lt;button @click="handleClick"&gt;切换&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[calable_Graph_Exploration_and_Visualization_Sensemaking_Challenges_and_Opportunities]]></title>
    <url>%2F2018%2F12%2F26%2FScalable-Graph-Exploration-and-Visualization-Sensemaking-Challenges-and-Opportunities%2F</url>
    <content type="text"><![CDATA[论文:Scalable Graph Exploration and Visualization:Sensemaking Challenges and Opportunities 作者:Robert Pienta†, James Abello∗, Minsuk Kahng†, Duen Horng Chau† 会议:BigComp 2015 [TOC] 背景在很多领域，数据都可以被表示为图或者是网络。例如，线上的社交网络（谁和谁是相识的），网络流量（哪两个电脑在通信）等等。 现在，理解大图存在着很多的挑战，很少有能够允许用户去交互的探索，想象并且理解百万数据量图的工具 Graph SensemakingGraph Sensemaking: 指的是理解图形格式数据的迭代过程，在这个过程中用户逐渐建立起对于信息空间的表达，最终用于达到分析目的。 Sensemaking: 是一个动态的，交互的过程，这个过程包括搜索，过滤，组织信息，创建模式，构建证据等。 理论认为有两个主要的sensemaking范例: global views Shneiderman[^1]提出的可视分析“overview, zoom &amp; filter,details-on-demand” 模式被广泛应用 但是这种提供全局数据概览的方法当数据量达到数百万，数十亿时就很乏力了[^2][^3]，有一些论文提出了耗时较少的生成全局概览图的方法[^4][^5] Leskovec &amp; Faloutsos[^6]在他们对图聚类非常有影响力的工作中提出：没有完美的overview（没有一个最好的单独的方法可以将图分隔成小的集合）。一个支持这种说法的认知理论是因为目的和先验经验的不同，人们对于同一个信息会有不同的主观表达。 local views 可以帮助用户找到一些独立节点的详细信息和他们的邻居 当用户局部浏览的时候，他们会停留在最初感兴趣的部分还是会去浏览图更大的区域？[^7]被调查节点的特征是否存在相关的模式？如果存在，这些模式是否可以用来提升调查工具的性能？[^8] 文章将graph sensemaking领域的划分了类别，结果如下 Scaling up Graph Sensemaking: Interactive Sensemaking&amp; Scalable Algorithms 交互认知和可扩展算法在面对大规模数据集的挑战时，分析者们往往需要多种工具结合使用来支持他们的分析。文章中着重介绍了支持这个观点的最新研究并且探索了可扩展算法以及以图为基础的工具的交互设计之间复杂的关系。 Interactive &amp; Adaptive Views将图探索和信息检索，机器学习，数据挖掘等结合起来可以帮助用户在探索过程中更好的理解他们所探索的内容以及探索所使用的方法。 Scalable Algorithms在先后的工作中，图的可扩展性是需要首要考虑的并且是衡量工作成功与否的标准[^9] 可扩展性的目标和努力去可视化全部图的目标非常不同。现在的技术允许布局一个百万节点的图，但是在可视化上是极端复杂的[^10]。这意味着，即使算法可以运行在整张图上，用户可能仅仅只是想要可视化和他们认知相关的部分子图。最新的工作开始关注可扩展的局部节点的计算，像[^11]可以在150ms之内提取出以一个节点为中心的其他数百万节点。 我们见证了很多结合了机器学习数据挖掘算法的交互式系统的诞生，这些系统都有着良好的用户界面。 在这篇综述中，介绍了对graph sensemaking作出贡献的工具，技术和相关研究。 文章结构: 将介绍图形探索和可视化所需的可扩展性和技术 讨论图的交互技术 未来的研究方向 图探索和可视化先前的工作静态： 图可视化最原始工作的综述：[^12] 2000年以来新的可视化方法:[^13] 动态: 综述:[^14] 可视化和探索技术让大图更容易被展示和探索的方法有: 抽样(sampling)，过滤(flitering)，分割(partitioning)，聚类(clustering) 抽样 通过抽样降低图的规模。随机或者指定。相关论文:[^15][^16] 缺点: 很多抽样方法都会对原图的拓扑特性造成严重的偏差[^17] 过滤 根据近似中介中心性（approximate betweeness centrality）进行过滤可以在保证原图主要结构的情况下降低图的规模。相关论文:[^18] 减少边的数量：束边（edge bunding） 相关论文:[^19] 分割 分割图并且可视化分割部分是建立图概览的常用方法。相关论文:[^20] [^21] [^22] 一个最近的提出的分割small-world 网络的方法对传统的方法(如METIS)做了改进[^24] 缺点: 大规模图的分割计算复杂性太高，在没有标度（scale-free）的网络上情况可能会非常差[^23] 因为分割算法复杂性的缺点，这种方法一般不会被用于交互的动态图 聚类 将拥有相似属性的节点聚成一类，或者使用OLAP（online analytical processing）对具有相同属性的节点进行上卷下钻等分析。 相关论文: [^25] 提出SNAP：允许用户自定义的属性去决定节点的相似性，并且生成一个图的总结 结合结构和属性信息产生图的简化版本，其中聚类在结构上都是紧密的并且具有相似的属性。 相关论文： [^26] :提出了一种新的距离度量方法，将节点属性相似性和结构距离结合在一起 ​ [^27 ] :根据属性将节点和边聚集在一起。使用网格布局来关注节点属性和连接之间的关系 聚类也可以是用户驱动的,由用户来定义聚类规则。 相关论文:[^28] [^29] 全局和局部参考资料[^1]: B. Shneiderman, “The eyes have it: A task by data type taxonomy for information visualizations,” in Visual Languages, 1996. Proceedings., IEEE Symposium on. IEEE, 1996, pp. 336–343.[^2]: D. A. Keim, “Visual exploration of large data sets,” Communications of the ACM, vol. 44, no. 8, pp. 38–44, 2001.[^3]: “Information visualization and visual data mining,” IEEE TVCG, vol. 8, no. 1, pp. 1–8, 2002.[^4]: V. Kwatra, A. Scho ̈dl, I. Essa, G. Turk, and A. Bobick, “Graphcut textures: image and video synthesis using graph cuts,” in ACM Trans- actions on Graphics (ToG), vol. 22, no. 3. ACM, 2003, pp. 277–286.[^5]: G. Karypis and V. Kumar, “Metis-unstructured graph partitioning and sparse matrix ordering system, version 2.0,” 1995.[^6]: J. Leskovec, K. J. Lang, A. Dasgupta, and M. W. Mahoney, “Commu- nity structure in large networks: Natural cluster sizes and the absence of large well-defined clusters,” Internet Mathematics, vol. 6, no. 1, pp. 29–123, 2009.[^7]: M. Bilenko and R. W. White, “Mining the search trails of surfing crowds: Identifying relevant websites from user activity,” in Proceedings of WWW, ser. WWW ’08. ACM, 2008, pp. 51–60.[^8]: A. Singla, R. White, and J. Huang, “Studying trailfinding algorithms for enhanced web search,” in Proceedings of the 33rd International ACM SIGIR Conference on Research and Development in Information Retrieval, ser. SIGIR ’10. ACM, 2010, pp. 443–450.[^9]: J. Abello, P. M. Pardalos, and M. G. Resende, Handbook of massive data sets. Springer, 2002, vol. 4.[^10]: G. J. Wills, “Nicheworksinteractive visualization of very large graphs,” Journal of computational and Graphical Statistics, vol. 8, no. 2, pp. 190–212, 1999.[^11]: Z. Lin, M. Kahng, K. M. Sabrin, D. H. P. Chau, H. Lee, and U. Kang, “Mmap: Fast billion-scale graph computation on a pc via memory mapping,” in Proceedings of the IEEE International Conference on Big Data. IEEE, 2014.[^12]: I. Herman, G. Melanc ̧on, and M. S. Marshall, “Graph visualization and navigation in information visualization: A survey,” IEEE TVCG, vol. 6, no. 1, pp. 24–43, 2000.[^13]: T. von Landesberger, A. Kuijper, T. Schreck, J. Kohlhammer, J. van Wijk, J.-D. Fekete, and D. Fellner, “Visual analysis of large graphs: State-of-the-art and future research challenges,” Computer Graphics Forum, vol. 30, no. 6, pp. 1719–1749, 2011.[^14]: F. Beck, M. Burch, S. Diehl, and D. Weiskopf, “The state of the art in visualizing dynamic graphs,” in EuroVis - STARs. Eurographics Association, 2014, pp. 83–103.[^15]: J. Leskovec and C. Faloutsos, “Sampling from large graphs,” in Proceedings of the 12th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, ser. KDD ’06. ACM, 2006, pp. 631–636.[^16]: V. Krishnamurthy, M. Faloutsos, M. Chrobak, L. Lao, J. H. Cui, and A. G. Percus, “Reducing large internet topologies for faster simula- tions,” ser. NETWORKING’05. Springer-Verlag, 2005, pp. 328–341.[^17]: S. Lee, P.-J. Kim, and H. Jeong, “Statistical properties of sampled networks,” Phys. Rev. E, vol. 73, p. 016102, Jan 2006.[^18]: Y. Jia, J. Hoberock, M. Garland, and J. Hart, “On the visualization of social and other scale-free networks,” IEEE TVCG, vol. 14, no. 6, pp. 1285–1292, Nov. 2008.[^19]: D. Holten, “Hierarchical edge bundles: Visualization of adjacency relations in hierarchical data,” IEEE TVCG, vol. 12, no. 5, pp. 741– 748, Sep. 2006.[^20]: A. Lex, C. Partl, D. Kalkofen, M. Streit, S. Gratzl, A. M. Wassermann, D. Schmalstieg, and H. Pfister, “Entourage: Visualizing relationships between biological pathways using contextual subsets,” IEEE TVCG, vol. 19, no. 12, pp. 2536–2545, Dec. 2013.[^21]: B. Lee, C. S. Parr, C. Plaisant, B. B. Bederson, V. D. Veksler, W. D. Gray, and C. Kotfila, “Treeplus: Interactive exploration of networks with enhanced tree layouts,” IEEE TVCG, vol. 12, no. 6, pp. 1414–1426, 2006.[^22]: S. S. Shen-Orr, R. Milo, S. Mangan, and U. Alon, “Network motifs in the transcriptional regulation network of escherichia coli,” Nature Genetics, vol. 31, no. 1, pp. 64–68, 2002.[^23]: J. Leskovec, K. J. Lang, A. Dasgupta, and M. W. Mahoney, “Commu- nity structure in large networks: Natural cluster sizes and the absence of large well-defined clusters,” Internet Mathematics, vol. 6, no. 1, pp. 29–123, 2009.[^24]: G. Slota, K. Madduri, and S. Rajamanickam, “Pulp: Scalable multi- objective multi-constraint partitioning for small-world network,” in In the Proceedings of the 2014 IEEE Conference on Big Data. IEEE, 2014.[^25]: Y. Tian, R. A. Hankins, and J. M. Patel, “Efficient aggregation for graph summarization,” in Proceedings of the 2008 ACM SIGMOD international conference on Management of data. ACM, 2008, pp. 567–580.[^26]: M. Wattenberg, “Visual exploration of multivariate graphs,” in Proceed- ings of CHI. ACM, 2006, pp. 811–819.[^27]: Y. Zhou, H. Cheng, and J. X. Yu, “Graph clustering based on struc- tural/attribute similarities,” Proc. VLDB Endow., vol. 2, no. 1, pp. 718– 729, Aug. 2009.[^28]: D. H. Chau, A. Kittur, J. I. Hong, and C. Faloutsos, “Apolo: inter- active large graph sensemaking by combining machine learning and visualization,” in Proceedings of the 17th ACM SIGKDD international conference on Knowledge discovery and data mining. ACM, 2011, pp. 739–742.[^29]: B. Shneiderman and A. Aris, “Network visualization by semantic substrates,” IEEE TVCG, vol. 12, no. 5, pp. 733–740, 2006.]]></content>
      <categories>
        <category>vis</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode395_Longest_Substring_with_At_Least_K_Repeating_Characters]]></title>
    <url>%2F2018%2F12%2F25%2Fleetcode395-Longest-Substring-with-At-Least-K-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[寻找每一个字符重复次数不小于k的最大子串 分治 用分治的想法，首先找到一个个数少于k的字符，然后根据这个字符把字符串划分为左右两部分，再分别把这两部分继续划分，返回这两部分的最大值 1234567891011121314151617class Solution(object): def longestSubstring(self, s, k): """ :type s: str :type k: int :rtype: int """ return self.findlongestSubstring(s,k) def findlongestSubstring(self,s,k): sets = set(list(s)) i=0 for item in sets: if(s.count(item)&lt;k): i=s.index(item) return max(self.findlongestSubstring(s[:i],k), self.findlongestSubstring(s[i+1:],k)) return len(s) 利用python的一些库函数可以更简洁 123456789101112131415class Solution(object): def longestSubstring(self, s, k): """ :type s: str :type k: int :rtype: int """ if len(s)&lt;k: return 0 c=min(set(s),key=s.count) #找出个数最小的 if s.count(c)&gt;=k: return len(s) return max(self.longestSubstring(t,k) for t in s.split(c)) Solution().longestSubstring('baaabcb',3) 参考资料]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入vue组件]]></title>
    <url>%2F2018%2F12%2F25%2F%E6%B7%B1%E5%85%A5vue%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[深入vue组件 [TOC] 一些小细节is属性解决小bugh5规范里面如tbody标签里面只能跟tr标签，如果使用模板则导致模板出现在tbody外层，可以使用is属性解决这类问题 123456789101112131415161718192021&lt;div id="root"&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr is="row"&gt;&lt;/tr&gt; &lt;tr is="row"&gt;&lt;/tr&gt; &lt;tr is="row"&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;script&gt; Vue.component('row',&#123; template: '&lt;tr&gt;&lt;td&gt;This is a row&lt;/td&gt;&lt;/tr&gt;' &#125;); var vm = new Vue(&#123; el: '#root' &#125;)&lt;/script&gt; data属性data在根实例可以直接用对象的方式定义，子组件里必须是一个函数 因为希望子组件都拥有自己独立的数据，而不是共享 1234567891011121314151617181920212223242526&lt;div id="root"&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr is="row"&gt;&lt;/tr&gt; &lt;tr is="row"&gt;&lt;/tr&gt; &lt;tr is="row"&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;script&gt; Vue.component('row',&#123; data() &#123; return&#123; content: 'This is row' &#125; &#125;, template: '&lt;tr&gt;&lt;td&gt;&#123;&#123;content&#125;&#125;&lt;/td&gt;&lt;/tr&gt;' &#125;); var vm = new Vue(&#123; el: '#root' &#125;)&lt;/script&gt; ref 操作dom通过ref来获取dom节点 直接把ref加在div等标签上 123456789101112131415161718192021222324252627&lt;div id="root"&gt; &lt;div ref="hello" @click="handleClick"&gt; hello world &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('row',&#123; data() &#123; return&#123; content: 'This is row' &#125; &#125;, template: '&lt;tr&gt;&lt;td&gt;&#123;&#123;content&#125;&#125;&lt;/td&gt;&lt;/tr&gt;' &#125;); var vm = new Vue(&#123; el: '#root', methods: &#123; handleClick: function()&#123; console.log(this.$refs.hello.innerHTML) &#125; &#125; &#125;)&lt;/script&gt; 获取组件的引用 把ref加在模板标签上 123456789101112131415161718192021222324252627282930&lt;script&gt; Vue.component('counter',&#123; data() &#123; return&#123; number : 0 &#125; &#125;, template: '&lt;div @click="handleClick"&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;', methods: &#123; handleClick ()&#123; this.number++ this.$emit('numberchange') &#125; &#125; &#125;); var vm = new Vue(&#123; el: '#root', data: &#123; total: 0 &#125;, methods:&#123; add () &#123; this.total = this.$refs.one.number +this.$refs.two.number &#125; &#125; &#125;)&lt;/script&gt; 组件参数校验与非Props特性参数校验子组件props不是一个数组而是一个对象 123456789101112131415161718&lt;div id="root"&gt; &lt;child content="hello world"&gt;&lt;/child&gt;&lt;/div&gt;&lt;script&gt; Vue.component('child',&#123; props: &#123; content: String //限定父组件传递参数的类型 &#125;, template: '&lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;' &#125;); var vm = new Vue(&#123; el: '#root', &#125;)&lt;/script&gt; 123456789101112131415props:&#123; content:[String , Number] //接受string或者number&#125;//更复杂 接受一个对象props:&#123; content:&#123; type: String required: false //是否一定需要传值 default: 'default value' //不传值时的默认值 validator: function(value) &#123; //自定义校验器 return (value.length &gt; 5) &#125; &#125;&#125; 非props特性props特性: 父组件利用属性给子组件传值，子组件定义了props来接受这个值 特定： 在子组件中可以使用 这个属性不会显示在子组件最外层dom标签的html属性上 非props特性：父组件利用属性给子组件传值，但是子组件没有定义props来声明这个值 特点： 在子组件中不能使用 这个属性会展示在子组件最外层dom标签的html属性上 给组件绑定原生事件在html元素绑定原生事件是指的原生事件本身，但如果在模板上绑定原生事件则会指向同名的自定义事件。 父组件监听子组件的自定义事件需要emit传递,或者写在子组件的模板里面 12345678910111213141516171819202122&lt;script&gt; Vue.component('child',&#123; template: '&lt;div @click="handleChildClick"&gt;child&lt;/div&gt;', methods: &#123; handleChildClick()&#123; alert('child click') this.$emit('click') &#125; &#125; &#125;); var vm = new Vue(&#123; el: '#root', methods: &#123; handleClick() &#123; alert('click') &#125; &#125; &#125;)&lt;/script&gt; 如果想在父组件上直接监听模板的原生事件，可以加上.native修饰符 1234567891011121314151617181920&lt;div id="root"&gt; &lt;child @click.native="handleClick"&gt;&lt;/child&gt;&lt;/div&gt;&lt;script&gt; Vue.component('child',&#123; template: '&lt;div&gt;child&lt;/div&gt;' &#125;); var vm = new Vue(&#123; el: '#root', methods: &#123; handleClick()&#123; alert('click') &#125; &#125; &#125;)&lt;/script&gt; 非父子组件之间的传值 发布订阅模式（Bus,总线，观察者模式）首先需要在vue实例的原型上添加一个bus属性 1Vue.prototype.bus = new Vue() 随后在这个属性上进行触发和监听 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id="root"&gt; &lt;child content="Dell"&gt;&lt;/child&gt; &lt;child content="Lee"&gt;&lt;/child&gt;&lt;/div&gt; &lt;script&gt; Vue.prototype.bus = new Vue(); Vue.component('child',&#123; template: '&lt;div @click="handleChildClick"&gt;&#123;&#123;selfcontent&#125;&#125;&lt;/div&gt;', data() &#123; return&#123; 'selfcontent' :this.content &#125; &#125;, props:&#123; content:String &#125;, methods: &#123; handleChildClick()&#123; this.bus.$emit('change',this.selfcontent) &#125; &#125;, mounted: function() &#123; let this_ = this; this.bus.$on('change',function(msg)&#123; this_.selfcontent = msg &#125;) &#125; &#125;); let vm = new Vue(&#123; el: '#root', &#125;) &lt;/script&gt; vuex插槽 slot插槽介绍slot用于子组件像父组件传递dom 12345678910111213141516171819202122232425&lt;body&gt; &lt;div id="root"&gt; &lt;child&gt; &lt;div slot="header"&gt;header&lt;/div&gt; &lt;div slot="footer"&gt;footer&lt;/div&gt; &lt;/child&gt; &lt;/div&gt; &lt;script&gt; Vue.prototype.bus = new Vue(); Vue.component('child',&#123; template: '&lt;div&gt;&lt;slot name="header"&gt;&lt;/slot&gt;heihei&lt;slot name="footer"&gt;&lt;/slot&gt;&lt;/div&gt;', &#125;); let vm = new Vue(&#123; el: '#root', &#125;) &lt;/script&gt;&lt;/body&gt; 具名插槽可以对应不同的插槽 如果没有具名则对应标签内全部的dom元素 slot内可以传入默认值，如果子组件没有传递dom元素则展示默认值 作用域插槽应用: 子组件的某一部分需要由外部传递的时候使用作用域插槽 语法: 作用域插槽必须有template包裹 需要有slot-scope来声明父组件需要接受的内容 1234567891011121314151617181920212223242526&lt;body&gt; &lt;div id="root"&gt; &lt;child&gt; &lt;template slot-scope="props"&gt; &lt;li&gt;&#123;&#123;props.item&#125;&#125;&lt;/li&gt; &lt;/template&gt; &lt;/child&gt; &lt;/div&gt; &lt;script&gt; Vue.prototype.bus = new Vue(); Vue.component('child',&#123; template: '&lt;div&gt;&lt;ul&gt;&lt;slot v-for = "item of list" :item = item&gt;&#123;&#123;item&#125;&#125;&lt;/slot&gt;&lt;/ul&gt;&lt;/div&gt;', data() &#123; return&#123; list:[1,2,3,4] &#125; &#125; &#125;); let vm = new Vue(&#123; el: '#root', &#125;) &lt;/script&gt;&lt;/body&gt; 动态组件&amp;v-once指令component 动态组件component是vue自带的组件，根据is绑定的值来动态的渲染不同的组件 12345678910111213141516171819202122232425262728293031&lt;div id="root"&gt; &lt;comment :is="type"&gt;&lt;/comment&gt; &lt;!--&lt;child-one v-if="type === 'child-one'"&gt;&lt;/child-one&gt;--&gt; &lt;!--&lt;child-two v-if="type === 'child-two'"&gt;&lt;/child-two&gt;--&gt; &lt;button @click="handleClick"&gt;button&lt;/button&gt; &lt;/div&gt; &lt;script&gt; Vue.prototype.bus = new Vue(); Vue.component('child-one',&#123; template: '&lt;div&gt;child-one&lt;/div&gt;', &#125;); Vue.component('child-two',&#123; template: '&lt;div&gt;child-two&lt;/div&gt;', &#125;); let vm = new Vue(&#123; el: '#root', data: &#123; type: 'child-one' &#125;, methods:&#123; handleClick: function()&#123; this.type = (this.type === 'child-one'?'child-two':'child-one') &#125; &#125; &#125;) &lt;/script&gt; v-once指令加入v-once指令的元素会被放入内存，而不是被销毁，提高性能 1&lt;div v-once&gt;child-two&lt;/div&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flexible_Linked_Axes_for_Multivariate_Data_Visualization]]></title>
    <url>%2F2018%2F12%2F25%2FFlexible-Linked-Axes-for-Multivariate-Data-Visualization%2F</url>
    <content type="text"><![CDATA[论文:Flexible Linked Axes for Multivariate Data Visualization 作者:Jarry H.T. Claessen and Jarke J. van Wijk 发表期刊:TVCG [TOC] #Flexible Linked Axes for Multivariate Data Visualization Introduction多变量数据是一种非常常见的数据格式，由数据的值以及数据的属性组成。如：人数据，有性别，年龄，身高，体重等等属性。现在有很多方法来对这样的数据进行可视化分析，如散点图，平行坐标图等。但是现有的方法在可视化结构上基本上都是固定的，用户只能改变一些属性 文章提出了Flexible Linked Axes，一种可视化多变量数据的新方法。这种方法允许用户自由的定义并定位坐标轴的位置，然后通过连接这些坐标轴来指定合适的可视化方案。 文章的流程如下: 介绍背景和现有方法的缺陷以及启发 介绍Flexible Linked Axes 应用方法 用户评估 结论和对未来工作的建议 Background出发点:用户对于多变量数据分析的兴趣点 独特数据项以及他们的属性 相同属性不同数据项的分布 两个属性值之间的关系 现有方法都是基于属性关系图（ARGOI）: 顶点代表属性，边代表属性之间的关系。这种方式可以解决2，3。 现有方法示例: 通过变换轴的构造可以得到不同的结果，给用户展示不同构造的ARGOI。在现有的方法中，这些结构都是由作者定义好的，Flexible Linked Axes允许用户自定义结构。 Flexible Linked Axes简写：FLINA 定义FLINAPlot: 轴 Axis（最主要元素）轴由两点之间的线段定义，每一个轴都有一些关联的数据属性： 方向(direction)：A-&gt;B或者B-&gt;A 边距(margin)：决定线段的哪一部分被使用 范围(range)：决定轴的起始和终点对应属性值域的哪一段 [dmin , dmax ] 过滤器(filter)：[fmin , fmax ] 根据属性值来过滤掉不展示的数据项 多边形 Polygons一个点可以被多个轴共享，为了方便用户的使用，轴的集合可以被定义为多边形。 连接 LinkLink定义了成对轴之间的关系，因此也定义了ARGOI中的边。 对于每一个Link用户可以选择是使用PCP还是散点图来可视化这些数据项 一些定义 数据项：item i 属性$A_{i}$ 的轴： a 定义点$p_{ia}$ : $T_{i,j}$ (数据项i的第j个属性) 在轴a上的映射 两种风格的表达 PCP-style: 数据项i被表示为$p_{ia}$和$p_{ib}$的连线 scatterplot-style: 数据项被表述为两轴之间的一个点 ExamplesCars Many-to-Many PCPS对于PCP如何定义轴和连接的最小结构的挑战给出了一个可能的解决方法 CountriesFLINAPLOTS 一个应用是可以结合scaterplot和PCPS Network monitoring User Study Conclusion文章提出了一个非常简单直接的想法：允许用户灵活的设置坐标轴，实用这些坐标轴去自定义可视化方案。这种方法简单易用，具有灵活性，可以结合使用不同的可视化方案 参考资料 Flexible Linked Axes for Multivariate Data Visualization]]></content>
      <categories>
        <category>vis</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode3Longest_Substring_Without_Repeating_Characters]]></title>
    <url>%2F2018%2F12%2F24%2Fleetcode3Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[滑动窗口，寻找不重复的最大子串 Longest Substring Without Repeating Characters 自己的思路用一个字典保存已经遍历过的字符 遇到重复的: 判断长度是否需要更新 从重复的这个字符（index大的）开始重新遍历 清空字典 不重复: 长度+1 写入字典 1234567891011121314151617181920212223242526class Solution(object): def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ logdict = dict() result=0 currentResult = 0 i=0 while(i&lt;len(s)): if(s[i] not in logdict or logdict[s[i]]==i): logdict[s[i]] = i currentResult+=1 i+=1 else: index=logdict[s[i]] logdict.clear() i = index+1 if(result&lt;currentResult): result = currentResult currentResult=0 if(result&lt;currentResult): result=currentResult return result 想法太繁琐了，运行速度也比较慢 滑动窗口维持一个滑动窗口和一个hash表logdict hash表记录每一个字符最后出现的位置 遇到重复的: 判断滑动窗口的左边界 start = max(start,logdict[s[i]]) 更新hash表 不重复： 加入hash表 每次结束判断result是否需要更新 result = max(result,i-start+1) 123456789101112131415class Solution(object): def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ logdict = dict() start=0 result=0 for i in range(len(s)): if(s[i] in logdict): start = max(start,logdict[s[i]]+1) logdict[s[i]] = i result = max(result,i-start+1) return result 参考资料]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode12Integer_to_Roman]]></title>
    <url>%2F2018%2F12%2F22%2Fleetcode12Integer-to-Roman%2F</url>
    <content type="text"><![CDATA[阿拉伯数字转罗马数字 and 罗马数字转阿拉伯数字 Roman to Integer罗马转阿拉伯比较简单，遍历罗马字符串 处理两种情况 相邻的两个前一个比后一个小，直接相加、 前一个比后一个大，先减去已经加入结果的前一个值，再加上二者的差值 123456789101112131415class Solution(object): def romanToInt(self, s): """ :type s: str :rtype: int """ d = &#123;'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000&#125; result=d[s[0]] for i in range(1,len(s)): if(d[s[i]]&lt;=d[s[i-1]]): result+=d[s[i]] else: result-=d[s[i-1]] result+=d[s[i]]-d[s[i-1]] return result Integer to Roman数字转罗马要稍微复杂一点，因为需要处理的情况增多了 先得到每个位上的数字，判断这个数字的情况 等于9或者4 大于等于5 小于5 第一种情况单独处理 第二种情况先把5加入结果，再将剩下的数字同第三种情况合并处理 123456789101112131415161718192021222324class Solution(object): def intToRoman(self, num): """ :type num: int :rtype: str """ result="" d = &#123;1:'I',5:'V',10:'X',50:'L',100:'C',500:'D',1000:'M'&#125; for i in range(3,-1,-1): thisnum = int(num/(10**i)) thisrom = d[10**i] num = int(num%(10**i)) if(thisnum==4): result+=d[10**i]+d[5*10**i] continue if(thisnum==9): result+=d[10**i]+d[10**(i+1)] continue if(thisnum&gt;=5 and thisnum&lt;9): result+=d[5*10**i] thisnum-=5 for j in range(thisnum): result+=d[10**i] return result]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuemooc笔记]]></title>
    <url>%2F2018%2F12%2F22%2Fvuemooc%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[vue2.5笔记 vue慕课网笔记基础语法挂载点 模板 实例vue实例el属性所指定的dom就是挂载点，挂载点里面的内容就是模板 12345678910&lt;div id="root"&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: "#root", template: '&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;', data:&#123; msg: "Hello world" &#125; &#125;)&lt;/script&gt; 数据，事件，方法如何把数据显示在模板上v-text 接受一个变量，并显示文字 v-html 接受一个变量，并显示相应的html 双花括号 直接显示在模板中12345678910111213141516171819202122232425**v-on 绑定click事件,事件发生时触发handleClick方法**~~~html&lt;div id=&quot;root&quot;&gt; &lt;div v-on:click=&quot;handleClick&quot;&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &quot;#root&quot;, data: &#123; content: &quot;hello&quot; &#125;, methods: &#123; handleClick: function()&#123; this.content = &quot;world&quot; &#125; &#125; &#125;)~~~v-on简写: ```@ 如: 123&lt;div v-on:click=""&gt;&lt;/div&gt;&lt;!-- 等价于 --&gt;&lt;div @click=""&gt;&lt;/div&gt; ###属性绑定 v-bind 绑定元素属性 简写 : 123456789101112131415&lt;div id="root"&gt; &lt;div v-bind:title="title"&gt;Hello world&lt;/div&gt; &lt;div :title="title"&gt;Hello world&lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: "#root", data: &#123; content: "hello", title:"this is hello world" &#125; &#125;)&lt;/script&gt; ###双向数据绑定 v-model input改变 content也会发生改变(v-bind 不会发生这样的变化) 12345678910111213141516171819202122&lt;div id="root"&gt; &lt;div v-bind:title="title"&gt;Hello world&lt;/div&gt; &lt;input v-model:value="content"/&gt; &lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: "#root", data: &#123; content: "hello", title:"this is hello world" &#125;, methods: &#123; handleClick: function()&#123; this.content = "world" &#125; &#125; &#125;)&lt;/script&gt; 计算属性computed 依赖的属性发生变化时才会重新计算，否则返回之前的值 1234567891011121314151617181920212223&lt;div id="root"&gt; 姓： &lt;input v-model="firstName"/&gt; 名： &lt;input v-model="lastName"/&gt; &lt;div&gt; &#123;&#123;fullName&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: "#root", data: &#123; firstName: '', lastName: '' &#125;, computed: &#123; fullName: function()&#123; return this.firstName + ' ' + this.lastName &#125; &#125; &#125;) &lt;/script&gt; 监听器watch 监测某一个属性的变化，一旦发生了变化就执行相应的操作 不仅可以监听普通的人属性，也可以监听计算属性 123456789101112131415161718192021222324252627282930313233343536373839&lt;div id="root"&gt; 姓： &lt;input v-model="firstName"/&gt; 名： &lt;input v-model="lastName"/&gt; &lt;div&gt; &#123;&#123;fullName&#125;&#125; &lt;/div&gt; &lt;div&gt; &#123;&#123;count&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: "#root", data: &#123; firstName: '', lastName: '', count: 0 &#125;, computed: &#123; fullName: function()&#123; return this.firstName + ' ' + this.lastName &#125; &#125;, watch: &#123;// firstName: function()&#123;// this.count++// &#125;,// lastName: function()&#123;// this.count++// &#125; fullName: function()&#123; this.count++ &#125; &#125; &#125;) &lt;/script&gt; v-if v-show v-for控制元素存在or显示v-if 用来控制元素是否存在并显示 接受一个布尔值，真值则元素存在并显示，假值则元素直接被移除 v-show用来控制元素是否显示 接受一个布尔值，值修改display属性 如果某一个元素需要频繁隐藏显示，使用v-show会好一点 如果隐藏不频繁，选用v-if 123456789101112131415161718192021&lt;div id="root"&gt; &lt;div v-show="show"&gt; Hello world &lt;/div&gt; &lt;button @click="handleClick"&gt;toggle&lt;/button&gt;&lt;/div&gt; &lt;script&gt; new Vue(&#123; el: "#root", data: &#123; show: true, &#125;, methods:&#123; handleClick: function()&#123; this.show = !this.show &#125; &#125; &#125;) &lt;/script&gt; 展示可迭代数据v-for 加key可以提醒渲染效率,key值要求不同 1234567891011121314151617181920212223242526&lt;div id="root"&gt; &lt;div v-show="show"&gt; Hello world &lt;/div&gt; &lt;button @click="handleClick"&gt;toggle&lt;/button&gt; &lt;ul&gt; &lt;li v-for="(item,index) of list" :key="index"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; &lt;script&gt; new Vue(&#123; el: "#root", data: &#123; show: true, list: [1,2,3], &#125;, methods:&#123; handleClick: function()&#123; this.show = !this.show &#125; &#125; &#125;) &lt;/script&gt; 组件局部 or 全局全局组件12345//通过Vue.component定义的是全局组件Vue.component('todo-item',&#123; props: ['content'], template: '&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;'&#125;) 全局组件可以直接使用 1&lt;todo-item&gt;&lt;/todo-item&gt; 局部组件1234567891011//局部组件 在vue实例中用component来注册var TodoItem = &#123; template:'&lt;li&gt;item&lt;/li&gt;'&#125;new Vue(&#123; el: "#root", components:&#123; 'todo-item': TodoItem //注册这个局部组件 &#125;&#125;) 使用方法也一样 1&lt;todo-item&gt;&lt;/todo-item&gt; 父组件-子组件传参如果需要通过不同的条件创建不同的组件实例，则需要对组件传参 生成实例时用 :=””进行属性参数的传递(v-bind的简写) 在组件里用props来接收 实际上就是组件的属性保存在props中，使用v-bind来改变属性的值 在vue中，父组件像子组件传递参数就是通过属性的方式来进行传递 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id="root"&gt; &lt;div&gt; &lt;input v-model="inputValue" /&gt; &lt;button @click="handleSubmit"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;todo-item v-for="(item,index) of list" :key="index" :content="item" &gt; &lt;/todo-item&gt; &lt;/ul&gt;&lt;/div&gt; &lt;script&gt; //通过Vue.component定义的是全局组件 Vue.component('todo-item',&#123; props: ['content'], template: '&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;' &#125;) new Vue(&#123; el: "#root", data: &#123; inputValue:'', list: [], &#125;, methods:&#123; handleSubmit: function()&#123; this.list.push(this.inputValue) this.inputValue = "" &#125; &#125; &#125;) &lt;/script&gt; 子组件-父组件传参子组件触发事件 1this.$emit('delete',this.index) 父组件监听事件 1:delete="handleDelete" 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;div id="root"&gt; &lt;div&gt; &lt;input v-model="inputValue" /&gt; &lt;button @click="handleSubmit"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;todo-item v-for="(item,index) of list" :key="index" :content="item" :index="index" @delete="handleDelete" &gt; &lt;/todo-item&gt; &lt;/ul&gt;&lt;/div&gt; &lt;script&gt; //通过Vue.component定义的是全局组件 Vue.component('todo-item',&#123; props: ['content','index'], template: '&lt;li @click="deleteThis"&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;', methods: &#123; deleteThis: function()&#123; this.$emit('delete',this.index) &#125; &#125; &#125;); new Vue(&#123; el: "#root", data: &#123; inputValue:'', list: [] &#125;, methods:&#123; handleSubmit: function()&#123; this.list.push(this.inputValue); this.inputValue = "" &#125;, handleDelete: function(index)&#123; this.list.splice(index) &#125; &#125; &#125;) &lt;/script&gt; 组件与实例的关系一个组件就是一个vue实例 在实例里面可以添加的属性在组件中同样可以添加 每一个实例都会有template,如果没有显式定义则会去找到挂载点，挂载点中的所有内容就是这个实例的template vue-cli生命周期生命周期函数就是vue实例在某一个时间点会自动执行的函数 参考资料 https://www.imooc.com/video/16975]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interpretable_Decision_Sets]]></title>
    <url>%2F2018%2F12%2F20%2FInterpretable-Decision-Sets%2F</url>
    <content type="text"><![CDATA[Interpretable Decision Sets: A Joint Framework for Description and Prediction以后再看吧&gt;&lt; 被老板毙掉的方向 AbstractA framework for building predictive models that are highly accurate, yet also highly interpretable. Decision sets are sets of independent if-then rules.Because each rule can be applied independently, decision sets are simple, concise, and easily interpretable. Our framework provides a new approach to interpretable machine learning that balances accuracy, interpretability, and computational efficiency. IntroductionLearning interpretable models is challenging because interpretability and accuracy aregenerally two competing objectives, one favoring simplicity and generalization, the otherfavoring nuance and exception. Even quantifying interpretability is a challenge.： Decision Tree: Just being rule-based, however, is not sufficient; the structure connecting a set of rules is also an important factor in interpretability. Decision List: Considered the sturcture but still has drawbacks:The chaining of rules via if-then-else statements means that new rules can only cover increasingly narrow slices of the feature space. Even if the first few rules in the list are interpretable, each additional rule becomes less so because it only applies to more and more narrow situations present work: Interpretable desicion sets参考资料 http://europepmc.org/backend/ptpmcrender.fcgi?accid=PMC5108651&amp;blobtype=pdf]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode168&171]]></title>
    <url>%2F2018%2F12%2F17%2Fleetcode168Excel-Sheet-Column-Title%2F</url>
    <content type="text"><![CDATA[Excel_Sheet_Column_Title Excel Sheet Column Number Excel_Sheet_Column_Title 这个题目有点不好懂，试了几次才知道是啥意思 大概有点像进制的感觉，28是AB，52是AZ，53是BA 当成26进制写 有一点小区别，这个进制表示里面没有0，取余等于0的时候要放入Z，高位要减一 123456789101112131415class Solution(object): def convertToTitle(self, n): """ :type n: int :rtype: str """ result="" while(n!=0): if(n%26==0): result+="Z" n=n/26-1 else: result+=chr(n%26+64) n=n/26 return result[::-1] Excel Sheet Column Number 跟上面那个题的输入输出相反 12345678910class Solution(object): def titleToNumber(self, s): """ :type s: str :rtype: int """ result=0 for i in range(len(s)): result+= (ord(s[i])-64)*(26**(len(s)-i-1)) return result]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TDA拓扑数据分析]]></title>
    <url>%2F2018%2F12%2F16%2FTDA%2F</url>
    <content type="text"><![CDATA[拓扑基础 #拓扑数据分析-持续同调（一） 持续同调（PH）为我们提供了一个寻找不需要降维就能精要的刻画数据全貌的方法。 拓扑学领域在数学空间性质的研究中主要关注的是点与点之间的关系。 拓扑学入门拓扑空间拓扑学关注的数学对象是拓扑空间： 拓扑空间是一组有序对 ，其中 是集合， 是 的子集的集群，他们满足以下性质： 空集和 属于 ， 中任意多个元素的并仍属于 ， 中有限个元素的交仍属于 。 的元素称为 开集，集群 称为 上的一个拓扑。 紧密性拓扑空间的重要性是什么？一个重要的方面是拓扑空间最终定义了一个定义拓扑的元素之间的紧密关系。 图论无向图： G是顶点V的集合和边E的集合组成的有序二元组，即G=（V , E） 有向图： G(V , E)的边集E是顶集V中元素的有序配对。因此，顶点之间的“连接”有方向。有序对的第一个顶点是开始，第二个顶点是结束。 预序关系可以在集合X和拓扑上建立一个二元的预序关系。（具有自反性和传递性） 自反性：每一个元素和自己有关， 传递性：如果 与 有关， 与 有关，那么 与 有关，即 预序关系（更准确的是X上的特殊预序关系）可以通过分析X上元素的成对关系得到。 特殊化预序关系一般用 表示 Definition (Specialization Pre-order) x≤y, if and only if y is contained in all the open sets containing x 举例： , 只有一个预序关系 cb Z={a,b,c,d}，τZ={Z,∅,{b},{a,b},{b,c,d}} 预序关系： ab cb cd db dc By just looking at the graph you can determine a lot of the topological properties of the space. Connectedness(连通性)连通性：如果 不能表示为两个非空互斥的开集的并，我们说拓扑空间 是连通的。也就是说，如果 中两个非空互斥的子集的并是 ，此拓扑空间是不连通的。 举例： 1X=&#123;a,b,c&#125;,τ=&#123;&#123;&#125;,&#123;a&#125;,&#123;b&#125;,&#123;a,b&#125;,&#123;b,c&#125;,&#123;a,b,c&#125;&#125;X=&#123;a,b,c&#125;,τ=&#123;&#123;&#125;,&#123;a&#125;,&#123;b&#125;,&#123;a,b&#125;,&#123;b,c&#125;,&#123;a,b,c&#125;&#125; 对于上面的例子，拓扑空间是不连通的，因为 {a}∪{b,c}=X，{a},{b,c}非空互斥 如果一个拓扑空间是联通的，那么所有的顶点都会被连接。 在纯拓扑空间上，没有了距离的概念，只能说一个元素比另一个元素距离某个元素更近或者更远。 Metric Spaces(度量空间)Metric Spaces是一种有着明确距离定义的拓扑空间 拓扑数据分析使用的也是度量空间，而不是纯拓扑空间 Definition (Metric Space): A metric space is an ordered pair (M,d) where M is a set and d is a metric on M, that is, a functiond: d: M×M→ℝ (This defines a function d mapping every ordered pair of elements in M to an element in the set of real numbers ℝ) d(x,y)&gt;=0（所有距离都是非负的） d(x,y)=0 当且仅当 x=y d(x,y)=d(y,x)（距离是对称的） d(x,z)&lt;=d(x,y)+d(y,z)（从x 到 z 的直线距离必不大于经过任何中间点到达） 度量空间由一个集合，以及一个可以返回任何两个元素之间距离的度量函数组成。 举例： 最常见的度量空间是数轴，集合是所有的实数，距离就是两个实数之间差值的绝对值（对于任意实数域 中的 ） 度量空间不局限于实数，一堆图片，一些文本块都可以。只要能够计算出集合中任何两个元素之间的距离，他就是一个有效的度量空间。 Continuity(连续性)因为拓扑定义的是点之间的相近关系，所以更改点的形状对于拓扑关系没有影响 Definition (Continuous Function) 对于两个拓扑空间 和 而言，如果每个元素 （正如 的开集）的原像 存在于 中，那么函数 是连续的。 使用特殊化预序的理解 当且仅当函数 是保序的： 中 表示 中 ，函数 是连续的。 Definition(Homomorphism) 同态（等价关系） 如果两个拓扑空间之间存在函数 ，其中 和 是两个拓扑空间 和 ，那么它们是同态的，其中 满足以下条件： 映射了 到 一一对应的关系（双射）。 是连续的。 反函数 是连续的。 像，原像 f:X-Y f的像是Y的子集，f的原像是X 一个连续函数的例子： Simplices and Simplicial Complexes 单纯形，单纯复形单纯复形可以逼近复杂的形状，并且比原始的形状在数学和计算上更容易处理 Example 两个三角形共用一条边，中间是一个一维单纯形连接另一个二维单纯形。 因为这个单纯复形的最高维单纯形是二维，所以他是一个二维单纯复形。 在作图表示的时候，如果没有颜色填充，则表示线段（一维单纯形）组成的单纯复形而不是一个单纯形。 Definition(Abstract simplex) 一个抽象的单纯形是任何一个有限的顶点集合。例如，单纯形 和单纯形 分别代表了1维单纯形和2维单纯形。 Definition(simplicial complex) 单纯复形： 一个单纯复形 是单纯形的集合，它满足以下条件： 中任意一个单纯形的任意面仍属于 中任意两个单纯形 的交集是空集或者二者共享的面中的其中一个。 拓扑学家并不关心大小/规模的差异，也不关心边缘的扩展，他们关心拓扑的不变量(拓扑空间的性质不随特定类型的连续变形而变化)，例如孔、环和连接的组件。 Construct a simplicial complex from data(建立单纯复形) The most common simplicial complexes go by names such as the Čech complex, Vietoris-Rips complex, alpha complex, and witness complex. Take what are called the ϵ-balls around each point in P (the dotted circles of radius ϵ) and build edges between that point and all other points within its ball. How to choose ϵ？ The key to actually discovering meaningful patterns in a simplicial complex is to continuously vary the ϵ parameter (and continually re-build complexes) from 0 to a maximum that results in a single massive simplex. Then you generate a diagram that shows what topological features are born and die as ϵ continuously increases. 随着ϵ 的变化能保留更长时间的特征大概率是有用的特征，那些寿命比较短的特征更有可能是噪音。这个过程称为持续同调 （随着ϵ 的变化在拓扑空间寻找持续存在的同源特征） Definition(Vietoris-Rips Complex) VR 复形：如果在d-维空间中有一个点集P， 的子集，那么比例 的VR复形 是这样定义的： 也就是说 中任何不同点之间的距离不大于参数 。 基本上，如果我们有包含一系列点的数据集 ，是P的一个子集，并且中所有点之间的距离都小于 ，那么P的所有子集都是单纯形，则P是一个单纯复形。 参考资料 http://outlace.com/TDApart1.html https://zhuanlan.zhihu.com/p/31734839]]></content>
      <tags>
        <tag>拓扑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode38_Count_and_Say]]></title>
    <url>%2F2018%2F12%2F15%2Fleetcode38-Count-and-Say%2F</url>
    <content type="text"><![CDATA[递归+字符串 #leetcode38_Count_and_Say 这个题就是题意写的很难懂 大概意思就是数前一个输出的字符串的字符的个数 n=1时输出“1” n=2的时候数“1”，有1个1，所以输出’11’ n=3的时候数“11”，有2个1，所以输出“21” n=4的时候数”21”，有一个2一个1，所以输出”1211” n=4的时候数“1211”，有一个1，一个2，两个1，所以输出”111221”(不是直接计数，而是按顺序) n=5,输出“312211” 先解决如何数数的问题，然后不管是递归还是直接循环求解都非常简单 12345678910111213def count(self,phrase): result = "" count=0 curr = phrase[0] for i in phrase: if(i!=curr): result+=str(count)+curr count=1 curr=i else: count+=1 result+=str(count)+curr return result 解法一 递归很明显的递归思路，把问题分解成数数的问题 1234567891011121314151617181920212223class Solution(object): def countAndSay(self, n): """ :type n: int :rtype: str """ if(n==1): return "1" else: return self.count(self.countAndSay(n-1)) def count(self,phrase): result = "" count=0 curr = phrase[0] for i in phrase: if(i!=curr): result+=str(count)+curr count=1 curr=i else: count+=1 result+=str(count)+curr return result 解法二 循环很简单的思路 从1开始数，直到数到n个结束并返回 123456789101112131415161718192021222324class Solution(object): def countAndSay(self, n): """ :type n: int :rtype: str """ phrase = "1" for i in range(n-1): phrase = self.count(phrase) return phrase def count(self,phrase): count=0 result="" curr = phrase[0] for i in phrase: if(i!=curr): result+=str(count)+curr count=1 curr=i else: count+=1 result +=str(count)+curr return result]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PROTOTYPE_SELECTION]]></title>
    <url>%2F2018%2F12%2F15%2FPROTOTYPE-SELECTION%2F</url>
    <content type="text"><![CDATA[减少可解释分类器的数据量 PROTOTYPE SELECTION FOR INTERPRETABLE CLASSIFICATIONIntroduction Selecting a small number of “representative” samples from a large data set may be of greater interpretative value than generating some “optimal” linear combination of all the elements of a data set. In this paper, we motivate a particular method for selecting prototypes in the classification setting. Formulation as an optimization problemThe intuitionA good set of prototypes: Every train-ing example should have a prototype of its same class in its neighborhood No point should have a prototype of a different class in its neighborhood There should be as few prototypes as possible The notion of neighborhood: For a given choice of Pl ⊆ X , we consider the set of ε-balls centered at each xj ∈ Pl . Covers as many training points of class l as possible Covers as few training points as possible of classes other than l Is sparse set cover integer program Set cover can be seen as a clustering problem in which we wish to find the smallest number of clusters such that every point is within ε of at least one cluster center. From intuition to integer program. Express the three properties（notion of neighborhood）as an integer program Solving the problemPresent two algorithms for approximately solving our problem, both based on standard approximation algorithms for set cover. LP relaxation with randomized rounding.A greedy approach.Examples on simulated and real dataMixture of Gaussion simulation ZIP code digits data 参考资料 Bien J, Tibshirani R. Prototype selection for interpretable classification[J]. The Annals of Applied Statistics, 2011: 2403-2424.]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode49_Group_Anagrams]]></title>
    <url>%2F2018%2F12%2F14%2Fleetcode49-Group-Anagrams%2F</url>
    <content type="text"><![CDATA[把anagrams(颠倒字母顺序产生的单词)放在一起输出 49. Group Anagrams 暴力解会超时 思路一： 很自然的想到把字符串排序，然后用hash表来保存 12345678910111213141516171819202122class Solution(object): def groupAnagrams(self, strs): """ :type strs: List[str] :rtype: List[List[str]] """ hash_result = dict() result = [] pos = 0 for item in strs: sitem = self.sort(item) if(sitem not in hash_result): hash_result[sitem] = pos result.append([]) result[pos].append(item) pos+=1 else: result[hash_result[sitem]].append(item) return result def sort(self,s): return "".join(sorted(list(s))) 思路二： 不同素数的乘积不同，可以用素数来代替26个字母，然后用素数的乘积去代替思路一中字符串的排序 123456789101112131415161718192021222324252627class Solution(object): def groupAnagrams(self, strs): """ :type strs: List[str] :rtype: List[List[str]] """ hash_result = dict() result = [] pos = 0 for item in strs: mul = self.multi(item) if(mul not in hash_result): hash_result[mul] = pos result.append([]) result[pos].append(item) pos+=1 else: result[hash_result[mul]].append(item) return result def multi(self,s): primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103]; result = 1 for i in s: result *= primes[(ord(i)-97)] return result]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue_router]]></title>
    <url>%2F2018%2F12%2F12%2Fvue-router%2F</url>
    <content type="text"><![CDATA[vue router Vue RouterGetting started告诉Vue Router在哪里渲染组件 123456789&lt;!-- use router-link component for navigation. --&gt;&lt;!-- specify the link by passing the `to` prop. --&gt;&lt;!-- `&lt;router-link&gt;` will be rendered as an `&lt;a&gt;` tag by default --&gt;&lt;router-link to="/foo"&gt;Go to Foo&lt;/router-link&gt;&lt;!-- component matched by the route will render here --&gt;&lt;!-- 会指向new Router所定义的routes --&gt;&lt;router-view&gt;&lt;/router-view&gt; 参考资料 https://router.vuejs.org/guide/#html]]></content>
      <categories>
        <category>vue</category>
        <category>router</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode205_290]]></title>
    <url>%2F2018%2F12%2F11%2Fleetcode205-Isomorphic-Strings%2F</url>
    <content type="text"><![CDATA[是否可以用一个字符串的字母去替换另一个字符串的字母 leetcode205_Isomorphic_Strings 这个题做了蛮久，没搞清楚能够替换到底应该满足什么条件 如果能够替换应该满足，两个字符串每个位置上对应的字符可以相互替换 比如 abb 写成 011 ​ bab 写成 010 就不能替换 一个思路是把字符串改写成数字的形势，再去判断是否可以替换 另一个思路是用字典去保存上一次该字符对应的位置，看看两个字符是否相等，如果相等则更新位置，如果不等则返回False 123456789101112131415161718192021class Solution(object): def isIsomorphic(self, s, t): """ :type s: str :type t: str :rtype: bool """ s_count = dict() t_count = dict() for i in range(len(s)): # 如果字典中没有这个字符，则说明还没有进行过匹配，标为-1 if(s_count.has_key(s[i])==False): s_count[s[i]] = -1 if(t_count.has_key(t[i])==False): t_count[t[i]] = -1 if(s_count[s[i]]!=t_count[t[i]]): return False # 记录下这次匹配的两个字符的下标，用于下次匹配时做判断 s_count[s[i]]=i t_count[t[i]]=i return True leetcode290_Word_Pattern 跟205其实是一个题，只不过第二个是一个多单词的字符串，把str转换成list用一样的方法求解就可以了 12345678910111213141516171819202122class Solution(object): def wordPattern(self, pattern, str): """ :type pattern: str :type str: str :rtype: bool """ lstr = str.split(" ") mpattern = dict() mstr = dict() if(len(pattern)!=len(lstr)): return False for i in range(len(lstr)): if(pattern[i] not in mpattern): mpattern[pattern[i]] = -1 if(lstr[i] not in mstr): mstr[lstr[i]] = -1 if(mpattern[pattern[i]]!=mstr[lstr[i]]): return False mpattern[pattern[i]] =i mstr[lstr[i]] = i return True]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rough_set_theory]]></title>
    <url>%2F2018%2F12%2F11%2Frough-set-theory%2F</url>
    <content type="text"><![CDATA[参考资料]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode345Reverse_Vowels_of_a_String]]></title>
    <url>%2F2018%2F12%2F10%2Fleetcode345Reverse-Vowels-of-a-String%2F</url>
    <content type="text"><![CDATA[还是一道简单的string类型的题目 345. Reverse Vowels of a String 思路很自然想到了，双指针，然后一个从前往后一个从后往前，遇到都是元音的时候就交换 1234567891011121314151617181920class Solution(object): def reverseVowels(self, s): """ :type s: str :rtype: str """ ns = list(s) vowels = ['a','e','i','o','u','A','E','I','O','U'] front = 0 later = len(ns)-1 while(front&lt;later): if(ns[front] not in vowels): front+=1 if(ns[later] not in vowels): later-=1 if(ns[later] in vowels and ns[front] in vowels): ns[later],ns[front] = ns[front],ns[later] later-=1 front+=1 return "".join(ns) 一种快一点的解法: 1234567891011121314151617181920class Solution(object): def reverseVowels(self, s): """ :type s: str :rtype: str """ ns = list(s) vowels = ['a','e','i','o','u','A','E','I','O','U'] front = 0 later = len(ns)-1 while(front&lt;later): while(ns[front] not in vowels and front &lt; later): front+=1 while(ns[later] not in vowels and front &lt; later): later-=1 if later &lt;= front: break ns[front],ns[later] = ns[later],ns[front] front+=1 later-=1 参考资料]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode151_Reverse_Words_in_a_String]]></title>
    <url>%2F2018%2F12%2F08%2Fleetcode151-Reverse-Words-in-a-String%2F</url>
    <content type="text"><![CDATA[将字符串按单词逆序输出 Reverse Words in a String 思想很简单，用两个指针，然后从后向前遍历，每得到一个单词加入到结果中，最后返回结果 出错了很多次，条件判断太多了，写了一堆的if,else..这种解法肯定不好 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def reverseWords(self, s): """ :type s: str :rtype: str """ result="" end = l = len(s)-1 flag=0 if(l==0 and s!=" "): return s while(l&gt;=0): if(s[l]==" " and end!=l): result+=s[l+1:end+1] result+=" " end=l elif(s[l]!=" " and l!=0): flag=1 l-=1 elif(s[l]==" " and end==l): end-=1 l-=1 elif(l==0 and s[l]!=" "): flag=1 result+=s[l:end+1] l-=1 else: l-=1 if(flag==0): return "" if(result==""): return s if(result[-1]==" "): return result[0:len(result)-1] return result 很多边界条件都是因为字符串的首尾有可能存在空格，用strip去掉首尾空格会减少很多判断 123456789101112131415161718192021222324252627class Solution(object): def reverseWords(self, s): """ :type s: str :rtype: str """ s = s.strip() result="" end = l = len(s)-1 if(l==0): return s while(l&gt;=0): if(s[l]==" " and end!=l): result+=s[l+1:end+1] result+=" " end=l elif(s[l]!=" " and l!=0): l-=1 elif(s[l]==" " and end==l): end-=1 l-=1 elif(l==0 and s[l]!=" "): result+=s[l:end+1] l-=1 else: l-=1 return result 调用库的算法 1234567class Solution(object): def reverseWords(self, s): """ :type s: str :rtype: str """ return " ".join(s.split()[::-1]).strip() 参考资料]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F08%2Fless%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[title: less基本语法toc: truedate: 2018-12-08 09:13:49tags: [前端]categories: [css,less] less的基本语法 [TOC] Less基本语法Variables Variables do not have to be declared before being used. selectors12345678@my-selector: banner;// Usage.@&#123;my-selector&#125; &#123; font-weight: bold; line-height: 40px; margin: 0 auto;&#125; URLs1234567@images: "../img";// Usagebody &#123; color: #444; background: url("@&#123;images&#125;/white-sand.png");&#125; properties123456@property: color;.widget &#123; @&#123;property&#125;: #0ee; background-@&#123;property&#125;: #999;&#125; Properties as VariablesYou can easily treat properties like variables using the $prop syntax. 1234.widget &#123; color: #efefef; background-color: $color;&#125; Parent SelectorsMultiple &amp;Referencing parent selectors with &amp; The &amp; operator represents the parent selectors of a nested rule and is most commonly used when applying a modifying class or pseudo-class to an existing selector: 1234567891011121314a:&#123; color:blue &amp;:hover:&#123; color:green &#125;&#125;//result ina &#123; color: blue;&#125;a:hover &#123; color: green;&#125; For example another typical use of the &amp; is to produce repetitive class names: 123456789101112131415161718192021222324.button &#123; &amp;-ok &#123; background-image: url("ok.png"); &#125; &amp;-cancel &#123; background-image: url("cancel.png"); &#125; &amp;-custom &#123; background-image: url("custom.png"); &#125;&#125;//result in .button-ok &#123; background-image: url("ok.png");&#125;.button-cancel &#123; background-image: url("cancel.png");&#125;.button-custom &#123; background-image: url("custom.png");&#125; Changing Selector OrderIt can be useful to prepend a selector to the inherited (parent) selectors. This can be done by putting the &amp; after current selector. 1234567891011121314151617.header &#123; .menu &#123; border-radius: 5px; .no-borderradius &amp; &#123; background-image: url('images/button-background.png'); &#125; &#125;&#125;//result in .header&#123; .menu&#123; border-radius:5px &#125;&#125;.no-borderadius .header .menu&#123; background-image: url('images/button-background.png');&#125; Combination explosion&amp; can also be used to generate every possible permutation of selectors in a comma separated list: 123456789101112131415161718192021222324252627282930313233p, a, ul, li &#123; border-top: 2px dotted #366; &amp; + &amp; &#123; border-top: 0; &#125;&#125;//result in p,a,ul,li &#123; border-top: 2px dotted #366;&#125;p + p,p + a,p + ul,p + li,a + p,a + a,a + ul,a + li,ul + p,ul + a,ul + ul,ul + li,li + p,li + a,li + ul,li + li &#123; border-top: 0;&#125; ExtendExtend is a Less pseudo-class which merges the selector it is put on with ones that match what it references. 12345678910111213141516nav ul &#123; &amp;:extend(.inline); background: blue;&#125;.inline &#123; color: red;&#125;outputs:nav ul &#123; background: blue;&#125;.inline,nav ul &#123; color: red;&#125; 参考资料 http://lesscss.org/features/]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode383Ransom_Note]]></title>
    <url>%2F2018%2F12%2F07%2Fleetcode383Ransom-Note%2F</url>
    <content type="text"><![CDATA[判断一个字符串是否能用另一个字符串里的字符来构成 还是一道简单的string类型的题目 count第一个想法就是用hash表记录下每个字符的个数，然后发现python的count函数可以直接计算个数 有一个小技巧，在遍历ransomNote时使用set函数，去掉重复的值，加快运行速度 1234567891011class Solution(object): def canConstruct(self, ransomNote, magazine): """ :type ransomNote: str :type magazine: str :rtype: bool """ for item in set(ransomNote): if(ransomNote.count(item)&gt;magazine.count(item)): return False return True find不用count的方法: 无非两种情况返回False: ransomNote需要的字符不在magazine中 ransomNote需要的某个字符的个数大于该字符在magazine中的个数 保存一个字典result，记录下ransomNote所需字符在magazine中的位置 遍历ransomNote 个数是否满足：如果需要的字符char在result中，位置是index，则从magazine[index:]中查找看是否还有一个char，有的话则更新result，没有则返回False 是否存在：如果需要的char不在result中，则中magazine中查找看是否有char，有的话更新result,没有的话则返回False 12345678910111213141516171819202122232425class Solution(object): def canConstruct(self, ransomNote, magazine): """ :type ransomNote: str :type magazine: str :rtype: bool """ l = &#123;&#125; m = len(ransomNote) if(m==0): return True if(m&gt;len(magazine)): return False for i in ransomNote: if(i in l): p = magazine.find(i,l[i]+1) if(p==-1): return False l[i] = p else: p = magazine.find(i) if(p==-1): return False l[i] = p return True]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件实例_二]]></title>
    <url>%2F2018%2F12%2F06%2Fvue%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[一个复用组件 [TOC] 需求每一行的列表是一个组件，列表内可能出现按钮组件或者箭头组件，点击按钮组件可以自定义事件，同时可以根据不同的参数来决定当前列表是带按钮的列表or带箭头的列表。 List组件123456789101112131415161718192021222324252627282930313233343536&lt;!-- quiList.vue --&gt;&lt;template&gt; &lt;div class="qui-list"&gt; &lt;span class='list-tips'&gt;&#123;&#123;tipsText&#125;&#125;&lt;/span&gt; &lt;!-- component是一个容器，决定里面装什么内容的是is=“” --&gt; &lt;!-- keep-alive保持组件在内存中是常驻的 --&gt; &lt;component :is="currentView" v-on:btnClickEvent = 'clickEvent' :msg=msg class="small" keep-alive&gt;&lt;/component&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import quiButton from '../components/quiButton.vue'import quiArrow from '../components/quiArrow.vue'export default &#123; props:&#123; msg:&#123; default:'下载' &#125;, tipsText:&#123; default:'默认的文案' &#125;, currentView:&#123; default:'qui-btn' &#125; &#125;, components:&#123; 'qui-btn':quiButton, 'qui-arrow':quiArrow &#125;, methods:&#123; clickEvent:function()&#123; alert("按钮点击事件") this.$emit("clickEvent") &#125; &#125;&#125;&lt;/script&gt; 复用组件的复用，在queList中复用了quiButton，quiArrow 动态切换实现quiButton和quiArrow根据参数来动态切换的是component这个标签 component是一个容器，决定里面装什么内容的是is=“” 1&lt;component :is="qui-button(qui-arrow)"&gt;&lt;/component&gt; List页面12345678910111213141516171819202122&lt;!-- pageQuiList.vue --&gt;&lt;template&gt; &lt;div class="pageQuiList"&gt; &lt;qui-list tipsText = "自定义文案，默认右边是按钮" msg="弹层"&gt;&lt;/qui-list&gt; &lt;qui-list v-on:clickEvent = "test"&gt;&lt;/qui-list&gt; &lt;qui-list ref = "child1" tipsText = "最右边是箭头" currentView = "qui-arrow"&gt;&lt;/qui-list&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import quiList from "../components/quiList.vue"export default &#123; name:"pageQuiList", components:&#123; 'qui-list':quiList &#125;, methods: &#123; test: function()&#123; alert('自定义的测试事件'); &#125; &#125;&#125;&lt;/script&gt; 有一个bug调了一会儿，第二个按键没有触发test事件，原因是忘记在子组件quiList的方法clickEvent中emit，这样事件就不会上传至父组件，父组件就无法监听到这个事件并触发test 参考资料 https://cloud.tencent.com/developer/article/1020416]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode58_387]]></title>
    <url>%2F2018%2F12%2F06%2Fleetcode58-387%2F</url>
    <content type="text"><![CDATA[两道string的简单题:最后单词的长度&amp;第一个不重复的值 58. Length of Last Word python一句话就可以AC 1return len(s.strip().split(" ")[-1]) 不用内置函数的方法: 从后向前遍历，如果遇到空格则忽略并且继续，直到遇到第一个不是空格的停下来并且记录下这个值temp 然后继续遍历，直到遍历到第一个不是空格的值停下来并记录下这个值index 然后返回temp-index 1234567891011121314class Solution(object): def lengthOfLastWord(self, s): """ :type s: str :rtype: int """ l = len(s) index = l-1 while(index&gt;=0 and s[index]==" "): index-=1 temp = index while(index&gt;=0 and s[index]!=" "): index-=1 return temp - index 387. First Unique Character in a String 本来想着暴力求解，结果超时了 看的别人的解法，用hash表 1hash_table = &#123;e:index for e,index in enumerate(s)&#125; 然后遍历字符串，如果字符的索引跟hash表保存的索引一致则返回这个索引，不一致则把hash表保存的值改为-1继续遍历(因为不一致就肯定不是这个值，如果不改的话后面会出现一致的值，导致结果错误) 12345678910111213141516class Solution(object): def firstUniqChar(self, s): """ :type s: str :rtype: int """ hash_table = &#123;e:index for index, e in enumerate(s)&#125; flag=0 for index,item in enumerate(s): if(index==hash_table[item]): flag=1 return index else: hash_table[item]=-1 if(flag==0): return -1 python语法: enumerate可以用在任何可枚举的数据结构上，返回索引和值]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>hash</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件实例_一]]></title>
    <url>%2F2018%2F12%2F05%2Fvue%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[一个制作组件的vue实例 [TOC] 需求需求：组件库是做UI和前端日常需求中经常用到的，把一个按钮，导航，列表之类的元素封装起来，方便日常使用，调用方法只需直接写上或者这样的代码就可以 文件结构 ###main.js和App.vue main.js是入口文件，初始化vue实例 App.vue是主组件，所有页面都是在App.vue下进行的切换 路由 router &amp; 单页面 pages前端可以根据带锚点的方式实现简单路由 index.js 1234567891011121314151617181920212223242526Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', //http://localhost:8080/#/ name: 'index', component: index &#125;, &#123; path: '/btn', //http://localhost:8080/#/btn name: 'btn', component: pageQuiButton &#125;, &#123; path: '/list', //http://localhost:8080/#/list name: 'list', component: pageQuiList &#125;, &#123; path: '/nav', //http://localhost:8080/#/nav name: 'nav', component: pageQuiNav &#125; ]&#125;) 设置了路由之后就可以通过路由访问不同的页面 四个路由分别对应pages中的四个vue文件所展示的页面 组件 Conponents定义了三个组件，按键，列表和导航栏并且分别在pages的页面中得到使用 自定义组件整体代码（实现组件自定义属性，事件和其他内容） 123456789101112131415161718192021222324//quiButton.js&lt;template&gt; &lt;button class="qui-btn" v-on:click="btnClickEvent"&gt; &lt;slot name="icon"&gt;&lt;/slot&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; &lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; //pop是可以在组件上注册的自定义特性。当一个值传递给prop特性时他就变成了那个组件实例的一个属性。 props:&#123; msg:&#123; default:'下载' &#125; &#125;, methods:&#123; btnClickEvent:function()&#123; alert(this.msg); // emit将事件传递给组件外部或者上级，不然父组件无法监听到 this.$emit('btnClickEvent'); &#125; &#125; &#125; 123456789101112131415161718192021222324252627282930//pageQuiButton.js&lt;&lt;template&gt; &lt;div id='pageQuiButton'&gt; &lt;!--使用 --&gt; &lt;!--监听到子组件的btnClickEvent事件后就去触发父组件的doSth事件 --&gt; &lt;qui-btn msg="确定" class="small" v-on:btnClickEvent="doSth1"&gt;&lt;/qui-btn&gt; &lt;qui-btn msg="取消" class="small" v-on:btnClickEvent="doSth2"&gt; &lt;!-- 插槽slot="icon" 对应组件中的name='icon',渲染时会将img整个替换成组件中对应name的slot标签 --&gt; &lt;img slot="icon" class="ico" src="../assets/delete.png"style="width:25px"/&gt; &lt;/qui-btn&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import quiBtn from '../components/quiButton.vue' export default&#123; name:'pageQuiButton', components:&#123; 'qui-btn':quiBtn &#125;, methods:&#123; doSth1:function()&#123; alert('1'); &#125;, doSth2:function()&#123; alert('2') &#125; &#125; &#125;&lt;/script&gt; 自定义属性 props1234567//pop是可以在组件上注册的自定义特性。当一个值传递给prop特性时他就变成了那个组件实例的一个属性。 props:&#123; msg:&#123; default:'下载' &#125; &#125;//然后在使用对应的组件时直接写msg='想自定义的值'即可 自定义事件 on emit1234567891011//首先需要子组件将事件向上传递给父组件btnClickEvent:function()&#123; alert(this.msg); // emit将事件传递给组件外部或者上级，不然父组件无法监听到 this.$emit('btnClickEvent'); &#125;//随后父组件中对该事件进行监听，当该事件被触发时执行自定义的事件&lt;qui-btn msg="确定" class="small" v-on:btnClickEvent="doSth1"&gt;&lt;/qui-btn&gt;&lt;qui-btn msg="取消" class="small" v-on:btnClickEvent="doSth2"&gt;&lt;/qui-btn&gt; 自定义其他内容 slot12345678//在组件中使用插槽来占位&lt;slot name="icon"&gt;&lt;/slot&gt;//使用时用自定义的内容去替换插槽&lt;qui-btn msg="取消" class="small" v-on:btnClickEvent="doSth2"&gt; &lt;!-- 插槽slot="icon" 对应组件中的name='icon',渲染时会将img整个替换成组件中对应name的slot标签 --&gt; &lt;img slot="icon" class="ico" src="../assets/delete.png"style="width:25px"/&gt; &lt;/qui-btn&gt; 参考资料 https://cloud.tencent.com/developer/article/1020338?fromSource=waitui]]></content>
      <categories>
        <category>vue</category>
        <category>自定义组件</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode14_Longest_Common_Prefix]]></title>
    <url>%2F2018%2F12%2F04%2Fleetcode14-Longest-Common-Prefix%2F</url>
    <content type="text"><![CDATA[寻找字符串的共同前缀 已二刷 leetcode14_Longest_Common_Prefix 题目要求必须是所有字符串的共同前缀，所以可以保留第一个字符串作为比较值，一个指针记录当前相同的长度 然后遍历所有的字符串，如果当前指针上的值都相等则后移，否则就结束并输出结果 前两次没有AC有两个问题 没有判断当输入的字符串数组为空的时候（leetcode的题基本都要这一步 第一个字符串不一定是最长的，也就是说以第一个为参考字符串会导致越界，所以要判断一句是否越界，如果越界则结束并输出结果 123456789101112131415161718192021222324class Solution(object): def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ if(strs==[]): return "" first = strs[0] l=0 flag=0 while(l&lt;len(first)): for item in strs: if(l&gt;=len(item)): flag=1 break if(item[l]!=first[l]): flag=1 break if(flag==0): l+=1 else: break return first[:l] 二刷二刷竟然竟然还没能不看思路写出来..也不知道脑袋里装了什么奇怪的东西 但好在写出来的代码好看了很多,这样看之前写的代码还真的跟emmm一样，各种if疯狂break 12345678910111213141516class Solution(object): def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ if(strs==[]): return "" item = strs[0] pos = 0 while(pos&lt;len(item)): for string in strs: if(pos&gt;=len(string) or string[pos]!=item[pos]): return item[0:pos] pos+=1 return item[0:pos]]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>前缀</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Delaunay Triangulation&Voronoi Diagram]]></title>
    <url>%2F2018%2F12%2F04%2F%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[Delaunay Triangulation&amp;Voronoi Diagram 三角剖分(Delaunay Triangulation)定义以一个二维空间为例，把一个二维空间剖开成一块块的碎片，满足以下两个条件: （1）每块碎片都是曲边三角形； （2）曲面上任何两个这样的曲边三角形，要么不相交，要么恰好相交于一条公共边（不能同时交两条或两条以上的边） 应用 更快计算最小生成树（平面图o(nlogn)) Voronoi Diagram定义沃洛诺伊图（Voronoi Diagram）解决了这样一个问题：如何根据已知点划分平面，使得格子与点一一对应，并使平面上任取一点都与最近的已知点围在一起。做法也很简单，把这些点连接成三角形网络，然后作每一条边的中垂线，这些中垂线形成的划分就是所求。 参考资料 https://blog.csdn.net/shenziheng1/article/details/54865138 https://www.zhihu.com/question/20317274]]></content>
      <tags>
        <tag>拓扑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode26_remove-duplicates-from-sorted-array]]></title>
    <url>%2F2018%2F11%2F29%2Fleetcode26-remove-duplicates-from-sorted-array%2F</url>
    <content type="text"><![CDATA[双指针的题目 26. Remove Duplicates from Sorted Array 题意很简单，去除数组中重复的数，返回剩余数组的长度l 注意：只能在原始数组上修改，原始数组的前l项是去重后的数组 思路: 双指针 保存一个low指针始终指向确认被加入去重后数组的元素 一个i指针顺序遍历数组 如果i和low相等，则不作操作，继续遍历 如果i和low不相等，则让low+1,并且把i的值赋给low然后继续遍历 (不相等就添加新值) 1234567891011class Solution(object): def removeDuplicates(self, nums): if nums==[]: return 0 else: low = 0 for i in range(len(nums)): if(nums[low]!=nums[i]): low+=1 nums[low] = nums[i] return low+1]]></content>
      <categories>
        <category>leetcode</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cnn&capsule]]></title>
    <url>%2F2018%2F11%2F29%2FCNN%2F</url>
    <content type="text"><![CDATA[cnn和capsule的学习笔记 CNN为什么使用CNN Some patterns are much smaller than the whole image The same patterns appear in different regions Subsampling pixels will not change the Objetc 卷积层卷积层的参数是由一些可学习的滤波器集合构成的 这些滤波器用作检测图像不同的特征 卷积层的作用例1 ：灰度图 如滤波器1，检测的就是存在右对角线全为正数这个特征，这个特征出现在原图像的左上角和左下角，体现在结果中就是左上和左下的值最大。 例2 RGB图 滤波器也是三维，每一个滤波器会考虑三种颜色，而不是分开计算 卷积层和全连接层的关系其实卷积层的每一个滤波器操作就是一个全连接层拿掉部分权重之后的运算结果 在全连接层中，每一个神经元都有自己的权重， 但是卷积得到的的神经元共享同一组权重（filter) 输出数据体在空间上的尺寸可以通过输入数据体尺寸（W），卷积层中神经元的感受野尺寸（F），步长（S）和零填充的数量（P）的函数来计算。（注：这里假设输入数组的空间形状是正方形，即高度和宽度相等）输出数据体的空间尺寸为(W-F +2P)/S+1。 池化层它的作用是逐渐降低数据体的空间尺寸，这样的话就能减少网络中参数的数量，使得计算资源耗费变少，也能有效控制过拟合。 使用MAX操作，对输入数据体的每一个深度切片独立进行操作，改变它的空间尺寸。最常见的形式是汇聚层使用尺寸2x2的滤波器，以步长为2来对每个深度切片进行降采样，将其中75%的激活信息都丢掉。每个MAX操作是从4个数字中取最大值（也就是在深度切片中某个2x2的区域）。深度保持不变。 只保留每个框中最大的值（也可以取平均值） 经过卷积层运算后，图像比原图像要小，图像channel的数量等于滤波器的数量 全连接层最后把所有的特征图（feature map）L拉直，然后进行全连接 CNN in Keras 第二次做卷积时，虽然滤波器的长宽仍然是3*3，但是必须考虑到前面卷积得到的结果是一个深度为25的特征图，所以参数数量：$25 \times 3 \times 3 = 225$ Capsule net一个胶囊网络基本上是一个试图执行反向图形解析的神经网络。 Geoffrey Hinton 介绍 Capsule 为：「Capsule 是一组神经元，其输入输出向量表示特定实体类型的实例化参数（即特定物体、概念实体等出现的概率与某些属性）。我们使用输入输出向量的长度表征实体存在的概率，向量的方向表示实例化参数（即实体的某些图形属性）。同一层级的 capsule 通过变换矩阵对更高级别的 capsule 的实例化参数进行预测。当多个预测一致时（本论文使用动态路由使预测一致），更高级别的 capsule 将变得活跃。」 A capsule is any function that tries to predict the presence and the instantiation parameters of a particular object at a given location. 胶囊是用来预测给定位置某个特定对象的出现以及对象内部参数的方法。 CNN的缺陷&amp;&amp;胶囊的改进CNN缺陷组成高层特征的低层特征之间并不存在位姿（平移和旋转）关系。CNN解决这个问题的方法是使用最大池化或后续卷积层来减少通过网络的数据的空间大小，从而增加了上层网络神经元的“视野”，因此它们得以检测输入图像较大区域的高阶特征。 卷积神经网络的内部数据表示没有考虑简单和复杂对象之间的重要空间层级。 CapsuleNet改进Hinton主张，为了正确地分类和辨识对象，保留对象部件间的分层位姿关系很重要。胶囊结合了对象之间的相对关系，在数值上表示为4维位姿矩阵。 益处： 增加了对于三维空间的理解，提高了识别不同角度相同物体的准确度 相比CNN需要的数据，它只需要学习一小部分数据，就能达到最先进的效果 想法很早就提出，但是没有一种算法可以实现并成功学习胶囊网络。 新算法“囊间动态路由”的提出，允许胶囊之间相互通信，并创建类似计算机图形中场景图的表示 Capsule 工作机制所有胶囊检测中的特征的状态的重要信息，都将以向量的形式被胶囊封装。 胶囊将检测某个特征值的概率作为向量的长度，特征的状态被编码成向量的方向。 因此，当图像中某个特征发生位姿变化时，向量的长度不限（概率不变），方向改变（状态改变） 这就是Hinton所说的活动等变形：神经活动随着物体在图像中的“外观流形上的移动”而改变，改变的同时检测概率保持恒定。 工作步骤 人造神经元可以用3个步骤来表示： 输入标量的标量加权 加权输入标量之和 标量到标量的非线性变换 胶囊具有上面3个步骤的向量版，并且新增了输入的防射变换这一步骤： 输入向量的矩阵乘法 输入向量的标量加权 加权输入向量之和 向量到向量的非线性变换 输入向量的矩阵乘法输入的向量来自上一层胶囊的输出。 向量的长度代表上一层胶囊检测到的对应对象的概率，向量的方向编码了检测到的对象的内部信息（位姿信息） 这些向量和权重矩阵W相乘，W中编码了一些高层特征和底层特征之间的关系，如空间关系。 输入向量的标量加权在神经网络中，通过反向传播来实现权重的学习 在胶囊网络中，使用“动态路由”来决定胶囊输出的去向(囊间动态路由算法) 动态路由算法的精髓就是：底层胶囊的输出应该被送往哪一个高层胶囊 低层胶囊具备测量哪个高层胶囊更能接受其输出的机制，并据此自动调整权重，使对应胶囊K的权重C变高，对应胶囊J的权重C变低。 加权输入向量之和和神经网络中的求和过程相同，只不过是向量的求和，而不是标量 向量到向量的非线性变化CapsNet的另一大创新是新颖的非线性激活函数，这个函数接受一个向量，然后在不改变方向的前提下，压缩它的长度到1以下。 公式右边的蓝色矩形缩放输入向量至单位长度，左边的红色矩形进行一些额外的缩放。 输出向量的长度代表胶囊检测的给定特征的概率。 视频笔记地址：https://www.youtube.com/watch?v=pPN8d0E3900 图中表示该网络中有50个capsule，箭头代表capsule输出的向量 黑色箭头检测矩形，蓝色箭头三角形 使用卷积层将图像变成若干个feature map，然后reshape这些数组，得到向量，这些向量就是第一层胶囊的输入。(we runa couple convolutional layers, we reshape the output to get vectors, and we squash them.This gives us the output of the primary capsules.) 每一个胶囊都试图预测下一层胶囊的输出 (Every capsule in the first layer tries to predict the output of every capsule in the next layer.) routing by agreement 举例： 第一层胶囊有两个，矩形胶囊和三角形胶囊 第二层胶囊有两个，房子胶囊和船胶囊 当第一层的矩形胶囊检测到一个旋转了16°的矩形时，他会预测房子胶囊会检测到一个旋转了16°的房子，船胶囊会检测到一个旋转了16°的船。这和矩形的方向一致。 当第一层的三角形胶囊检测到了一个旋转了如上图所示的三角形，他会预测房子胶囊会检测到一个倒着的房子，船胶囊会检测到一个旋转了16°的船。这与三角形的方向一致。 这两个胶囊在预测船胶囊的结果上相同，但是在预测房子胶囊的结果上面不相同。这时候，假定这个组合是一个船是非常合理的。 因此，第一层胶囊的输出结果将只送往船胶囊，房子胶囊不会收到前面两个胶囊的输出。 这种路径选择方法被称为routing by agreement，他有三个优点 上一层的胶囊输出只会传给合适的下层胶囊，使得下层胶囊可以得到一个简洁的输入，并且能提高检测物体姿势的精度 通过查看激活路径，可以清楚地得到零件的层次结构，并且准确知道哪一个零件属于哪一个物体 有助于解析具有重叠对象的拥堵场景 选择方法：不断求平均值，把离群点的权重变小，然后迭代3-5次（K-MEANS?)]]></content>
      <categories>
        <category>cnn</category>
        <category>capsule</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三周总结_全排列链表]]></title>
    <url>%2F2018%2F11%2F25%2F%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93-%E5%85%A8%E6%8E%92%E5%88%97%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[考试周题目做的有点杂，主要类型是全排列和总结 Sum周一是一道sum的题目，leetcode上面还有2sum,3sum等相同类型的题 给定一个数组和一个目标值，判断数组中是否有两个（或三个）数加起来等于目标值 这个题目要求的是输出索引，所以需要建立一个字典来保存 步骤： 遍历数组 如果t-n[i]不在字典中则把n[i]放入字段 key=n[i] value=i+1，然后继续遍历 如果t-n[i]在字典中，则输出[d[t-n[i]],i+1] 全排列全排列的题目做了两道，都是用的DFS的思想去解。跟之前做过的递归题相比，这次处理的不是构造好的树，而是数组。 46_Permutations 步骤: 如果深度等于想要的排列长度就把当前cur添加进结果数组 如果不等于则继续遍历 如果遍历的值被用过则下一个值 没有被用过则添加进cur然后继续递归下一个值 cur添加进结果数组后得到返回值回溯到上一个调用的函数中，把最后加入cur的值pop掉，并改成未被使用，然后继续向后搜索 47_Permutations_II跟46是一个类型的题，唯一的区别是要求输出的全排列给出的数组有重复的数，就导致结果需要去重 一句去重的代码 12if(used[i]==1 or i&gt;0 and used[i-1]==used[i] and used[i-1]==0): continue 如果两个相邻的数相等并且前面的数没有被用过，则说明前面的数刚刚被移出cur，再加入一个相同的数会产生重复，因此需要跳过 链表206_Reverse_Linked_List链表的反转 最简单的思路：遍历链表，入栈，然后出栈并返回一个新链表 递归的思路: next=None时return，然后依次加入到新链表并返回 三个指针 三个指针的思路: 一个pre指针指向前一个节点，一个cur指针指向当前节点，一个temp指针保存当前节点的下一个节点 12345while(cur!=None): temp = cur.next #保存下当前节点的下一个节点 cur.next = pre #当前节点指向前一个节点 pre = cur #前一个节点后移 cur = temp #当前节点后移]]></content>
      <categories>
        <category>总结</category>
        <category>链表</category>
        <category>全排列</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode234_Palindrome_Linked_List]]></title>
    <url>%2F2018%2F11%2F23%2Fleetcode234-Palindrome-Linked-List%2F</url>
    <content type="text"><![CDATA[判断链表是否是回文链表 234. Palindrome Linked List 链表跟数组比就是不能直接下标访问，所以要麻烦点 首先要找到链表的中点，快慢指针，慢指针一次一步，快指针一次两步，当快指针到头的时候慢指针指向的就是链表的中点 然后把后半部分保存进栈，再出栈跟前半部分作比较，不一样的话就返回False 123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def isPalindrome(self, head): """ :type head: ListNode :rtype: bool """ f=s=head isP=[] if(head==None or head.next==None): return True while(f!=None and f.next!=None): f=f.next.next s=s.next while(s!=None): isP.append(s.val) s=s.next while(len(isP)): if(isP.pop()!=head.val): return False head = head.next return True]]></content>
      <categories>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode206_Reverse_Linked_List]]></title>
    <url>%2F2018%2F11%2F22%2Fleetcode206-Reverse-Linked-List%2F</url>
    <content type="text"><![CDATA[链表的反转问题 206. Reverse Linked List最先想到的就是用栈保存，然后再出栈返回一个新的链表 1234567891011121314151617181920class Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ l = [] while(head!=None): l.append(head.val) head = head.next if(len(l)): r = ListNode(l.pop()) p = r else: return head while(len(l)): n = ListNode(l.pop()) p.next = n p = p.next return r 三个指针的方法 四行代码分为四步: 保存当前节点的下一个节点 当前节点的下一个节点指向前一个节点 把当前节点设为前一个节点 当前节点后移 12345678910111213class Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ pre = None while(head): temp = head.next # 保存下一个节点 head.next = pre # 当前节点指向前一个节点(实现反转) pre = head # 前一个节点设为当前节点 head = temp # 当前节点后移 return pre 递归的方法 就判断一下递归结束的条件，然后创建一个新的链表返回即可 123456789101112131415161718192021222324class Solution(object): p = None r = None def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ if(head==None): return head self.reverse(head) return self.r def reverse(self,n): if(n.next==None): self.p = ListNode(n.val) self.r = self.p return else: self.reverseList(n.next) temp = ListNode(n.val) self.p.next =temp self.p = self.p.next 参考资料]]></content>
      <categories>
        <category>leetcode</category>
        <category>list</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode47_Permutations_II]]></title>
    <url>%2F2018%2F11%2F21%2Fleetcode47-Permutations-II%2F</url>
    <content type="text"><![CDATA[还是全排列问题 47. Permutations II跟昨天那道题唯一的区别是输入的数组中有重复的值，也就导致结果会出现重复 可以使用排序去重的方法 跟昨天代码唯一不同的地方在于 1if(zero[i]==1 or i&gt;0 and nums[i-1] == nums[i] and zero[i-1]==0 ): 如果满足当前遍历的值跟前面的值相等，并且前面的值未被使用的条件 则说明，前面的数刚刚被移除出cur，如果再加入一个相同的数则会产生重复，所以跳过这个值继续搜索。 123456789101112131415161718192021222324class Solution(object): def permuteUnique(self, nums): result = [] zero = [] cur = [] nums.sort() for i in range(len(nums)): zero.append(0) def DFS(self,nums,n,d,cur): if(d == n): result.append(cur[:]) return else: for i in range(len(nums)): if(zero[i]==1 or i&gt;0 and nums[i-1] == nums[i] and zero[i-1]==0 ): continue else: zero[i]=1 cur.append(nums[i]) DFS(self,nums,n,d+1,cur) cur.pop() zero[i]=0 DFS(self,nums,len(nums),0,cur) return result 参考资料]]></content>
      <categories>
        <category>leetcode</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode46_Permutations]]></title>
    <url>%2F2018%2F11%2F20%2Fleetcode46-Permutations%2F</url>
    <content type="text"><![CDATA[DFS搜索的问题 本来是想做39，结果发现要用到全排列的知识，就先把排列的四个题做了吧 46. Permutations 就是DFS的思想，之前是在树的结构上，这次是数组的搜索，也是一样的 如果深度等于想要的排列长度就把当前cur添加进结果数组 如果不等于则继续遍历 如果遍历的值被用过则下一个值 没有被用过则添加进cur然后继续递归下一个值 cur添加进结果数组后得到返回值回溯到上一个调用的函数中，把最后加入cur的值pop掉，并改成未被使用，然后继续向后搜索 1234567891011121314151617181920212223class Solution(object): def permute(self, nums): cur = [] used = [] result = [] for i in range(len(nums)): used.append(0) def DFS(nums,n,d,cur,used): if(n==d): result.append(cur[:]) #必须是添加cur[:]是数组的复制，否则添加的是数组的引用，会出现问题 return else: for i in range(len(nums)): if(used[i]==1): continue else: used[i]=1 cur.append(nums[i]) DFS(nums,n,d+1,cur,used) cur.pop() used[i]=0 DFS(nums,len(nums),0,cur,used) return result 参考资料]]></content>
      <categories>
        <category>leetcode</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interpretable_Machine_Learning]]></title>
    <url>%2F2018%2F11%2F19%2FInterpretable-Machine-Learning%2F</url>
    <content type="text"><![CDATA[机器学习的可解释性 [TOC] 2. Interpretable2.1 ImportanceA correct prediction only partially solves your original problem. The following reasons(Why) drive the demand for interpretability and explanations To facilitate learning and satisfy curiosity as to why certain predictions or behaviors are created by machines, interpretability and explanations are crucial. The more a machine’s decision affects a person’s life, the more important it will be for the machine to explain its behavior. Interpretability makes it possible to extract this additional knowledge captured by the model. Machine learning models take on real-world tasks that require safety measures and testing. Interpretability is a useful debugging tool for detecting bias in machine learning models. The process of integrating machines and algorithms into our daily lives requires interpretability to increase social acceptance. Machine learning models can only be debugged and audited when they can be interpreted. 2.2 Taxonomy of Interpretability MethodsIntrinsic &amp;&amp; Post hocIntrinsic interpretability refers to machine learning models that are considered interpretable due to their simple structure, such as short decision trees or sparse linear models. Post hoc interpretability refers to the application of interpretability methods after model training. ResultThe various interpretability methods can be roughly differentiated according to their results. Feature summary statistic Feature summary visualization Model internals(e.g.:learned weight) Data point（for images and text) Intrinsically interpertable model Model-specific &amp;&amp; model-agnosticModel-specific interpretation tools are limited to specific model classes.(e.g.:intrinsic) Model-agnostic tools can be used on any machine learning model (e.g.:post hoc) Local or GlobalDoes the interpretation method explain an individual prediction or the entire model behavior? Or is the scope somewhere in between? 2.3 Scope of InterpretabilityAlgorithm TransparencyHow does the algorithm create the model? Algorithm transparency only requires knowledge of the algorithm and not of the data or learned models Global,Holistic Model InterpretablityHow does the trained model make predictions? To explain the global model output, you need the trained model, knowledge of the algorithm and the data. Global is very difficulit to achieve in practice Global Model Interpretability on a Modular LevelHow do parts of the model affect predictions? Local Interpretability for a Single PredictionWhy did the model make a certain prediction for an instance? You can zoom in on a single instance and examine what kind of prediction the model makes for this input, and explain why it made this decision. Local Interpretability for a Group of PredictionsWhy did the model make specific predictions for a group of instances? 2.4 Evaluating InterpretabilityDoshi-Velez and Kim (2017) propose three main levels for the evaluation of interpretability: Application level evaluation(real task)Put the explanation into the product and have it tested by the end user. Human level evaluation(simple task) A simplified application level evaluation. The difference is that these experiments are not carried out with the domain experts, but with laypersons. Function level evaluation (proxy task)Does not require humans. 2.5 Properties of ExplanationsThese properties can be used to judge how good an explanation (method) is. It’s not clear for all these properties how to measure them correctly, so one of the challenges is to formalize how they could be calculated. Properties of Explanation Methods Express power is the “language” or structure of the explanations the method is able to generate. Translucency describes how much the explanation method relies on looking into the machine learning model, like its parameters. Portability describes the range of machine learning models with which the explanation method can be used. Algorithmic Complexity describes the computational complexity of the method that generates the explanation. Properties of Individual Explanations Accuracy: How well does an explanation predict unseen data? Fidelity: How well does the explanation approximate the prediction of the black box model? Consistency: How much does an explanation differ between models that have been trained on the same task and that produce similar predictions? Stability: How similar are the explanations for similar instances? Comprehensibility: How well do humans understand the explanations? Certainty: Does the explanation reflect the certainty of the machine learning model? Degree of Importance: How well does the explanation reflect the importance of features or parts of the explanation? Novelty: Does the explanation reflect whether a data instance to be explained comes from a “new” region far removed from the distribution of training data? Representativeness: How many instances does an explanation cover? 2.6 Human-friendly ExplanationsWhat is a good explanation Explanations are contrastive: Humans usually don’t ask why a certain prediction was made, but rather why this prediction was made instead of another prediction. Explanations are selected :What it means for interpretable machine learning: Make the explanation very short, give only 1 to 3 reasons, even if the world is more complex. Explanations are social: Be mindful of the social setting of your machine learning application and of the target audience. Explanations focus on the abnormal. If one of the input features for a prediction was abnormal in any sense (like a rare category of a categorical feature) and the feature influenced the prediction, it should be included in an explanation, even if other ‘normal’ features have the same influence on the prediction as the abnormal one. Explanations are truthful. The explanation should predict the event as truthfully as possible, which is sometimes called fidelity in the context of machine learning. Good explanations are coherent with prior beliefs of the explainee. Good explanations are general and probable. 3. Datasets Bike sharing counts(Regression) YouTube Spam Comments(Text Classification) Risk Factors For Cervical Cancer(Classfication) 4. Interpretable Models 4.1 Linear Regression ModelInterpretation $R^{2}$ measurement. $R^{2}$ tells you how much of the total variance of your target outcome is explained by the model. The higher $R^{2}$ the better your model explains the data. $R^{2} = 1 - SSE/SST$ There is a catch, because R2R2 increases with the number of features in the model, even if they carry no information about the target value at all. So it is better to use the adjusted R-squared, which accounts for the number of features used in the model. while p is the number of feature and n the number of instances. The importance of a feature in a linear regression model can be measured by the absolute value of its t-statistic. The t-statistic is the estimated weight scaled with it’s standard error. 4.2 Decision TreeInterpretation Starting from the root node you go to the next nodes and the edges tell you which subsets you are looking at. Once you reach the leaf node, the node tells you the predicted outcome. All the edges are connected by ‘AND’. Feature importanceTree DecompositionDisadvantages so a few changes in the training dataset might create a completely different tree. 5. Model-Agnostic Methods5.1 Partial Dependence Plot(PDP)The partial dependence plot (PDP or PD plot) shows the marginal effect of a feature on the predicted outcome of a previously fit model. For classification, where the machine model outputs probabilities, the partial dependence function displays the probability for a certain class given different values for features xSxS. A straightforward way to handle multi-class problems is to plot one line or one plot per class. ExamplesIn practice, the set of features xSxS usually only contains one feature or a maximum of two, because one feature produces 2D plots and two features produce 3D plots. The influence of the weather features on the predicted bike counts: Advantages &amp; DisadvantagesAdvantages The computation of partial dependence plots is intuitive: If the feature for which you computed the PDP is uncorrelated with the other model features, then the PDPs are perfectly representing how the feature influences the target on average. Partial dependence plots are simple to implement. Causal interpretation Disadvantages The maximum number of features you can look at jointly is realistically two or three Some PD plots don’t include the feature distribution. The assumption of independence poses the biggest issue of PD plots. Heterogeneous effects might be hidden 5.2 Individual Conditional ExpectationFor a chosen feature, Individual Conditional Expectation (ICE) plots draw one line per instance, representing how the instance’s prediction changes when the feature changes. ICE is the equivalent to a PDP for local expectations. An ICE plot visualizes the dependence of the predicted response on a feature for EACH instance separately, resulting in multiple lines, one for each instance, compared to one line in partial dependence plots. A PDP is the average of the lines of an ICE plot. Advantages &amp; DisadvantagesAdvantages more intuitive to understand In contrast to partial dependence plots they can uncover heterogeneous relationships. Disadvantages can only display one feature meaningfully the plot can become overcrowded When the feature of interest is correlated with the other features, then not all points in the lines might be valid data points according to the joint feature distribution. In ICE plots it might not be easy to see the average. 5.3 Accumulated Local Effects (ALE) PlotALE plots are a faster and unbiased alternative to partial dependence plots Advantages &amp; DisadvantagesAdvantages ALE plots are unbiased, which means they still work when features are correlated. ALE plots are faster to compute than PDPs The interpretation of ALE plots is clear Use accumulated local effect plots, dump partial dependence plots. 5.4 Feature InteractionOne way to estimate the interaction strength is to measure how much of the variation of the predicted outcome depends on the interaction of the features. H-statistics 5.5 Feature ImportanceA feature’s importance is the increase in the model’s prediction error after we permuted the feature’s values。 A feature is “important” if permuting its values increases the model error, because the model relied on the feature for the prediction. A feature is “unimportant” if permuting its values keeps the model error unchanged, because the model ignored the feature for the prediction. Advantages &amp; DisadvantagesAdvantages Nice interpretation Feature importance provides a highly compressed, global insight into the model’s behavior. The importance measure automatically takes into account all interactions with other features. Permutation feature importance doesn’t require retraining the model like. Disadvantages It’s very unclear whether you should use training or test data for computing the feature importance. The feature importance measure is tied to the error of the model. You need access to the actual outcome target. 5.6 Global Surrogate ModelsA global surrogate model is an interpretable model that is trained to approximate the predictions of a black box model. Theory there is actually not much theory needed to understand surrogate models. We want to approximate our black box prediction function $\mathop f (x)\ $as closely as possible with the surrogate model prediction function $g(x)$, under the constraint that gg is interpretable. Any interpretable model - for example from the interpretable models chapter - can be used for the function $g(x)$ (linear model,decision tree) Fitting a surrogate model only needs the relation of input and predicted output. Perform the following steps to get a surrogate model: Choose a dataset $X$. This could be the same dataset that was used for training the black box model or a new dataset from the same distribution. You could even choose a subset of the data or a grid of points, depending on your application. For the chosen dataset $X$, get the predictions $Y$ of the black box model. Choose an interpretable model (linear model, decision tree, …). Train the interpretable model on the dataset $X$ and its predictions $Y$. Congratulations! You now have a surrogate model. Measure how well the surrogate model replicates the prediction of the black box model. Interpret / visualize the surrogate model. A way to measure how well the surrogate replicates the black box model is the R squared measure. If the black box model sucks,the interpretation of the surrogate model is still valid,because it makes statements about the model and not about the real world. Exampledata: daliy numbers of rented bikes(weather,calendrical information) f(x):SVM g(x):decision tree The surrogate model has an R squared (variance explained) of 0.77 which means it approximates the underlying black box behavior quite well, but not perfectly. data: cervical cancer f(x): random forest g(x): decision tree The surrogate model has an R squared (variance explained) of 0.2 which means it doesn’t approximate the random forest well and we should not over-interpret the tree, when drawing conclusions about the complex model. Advantages &amp; DisadvantagesAdvantages The surrogate model method is flexible I’d argue that the approach is very intuitive and straightforward. With the R squard measure, we can easily measure how good our surrogate models are in terms of approximation of the black box predictions. Disadvantages Be careful to draw conclusions about the model, not the data, since the surrogate model never sees the real outcome. It’s not clear what the best cut-off for R squared is in order to be confident that the surrogate model is close enough to the black box model. 80% of variance explained? 50%? 99%? It could happen that the interpretable model is very close for a subset of the dataset, but wildly diverges for another subset. In this case the interpretation for the simple model would not be equally good for all data points. The interpretable model you choose as a surrogate comes with all its advantages and disadvantages. 5.7 Local Surrogate ModelsLocal surrogate models are interpretable models used to explain individual predictions of black box machine learning models. Instead of trying to fit a global surrogate model, LIME focuses on fitting local surrogate models to explain why single predictions were made. data:consisting of perturbed samples and the associated black box model’s predictions. On this dataset LIME then trains an interpretable model weighted by the proximity of the sampled instances to the instance of interest. Mathematically, local surrogate models with interpretability constraint can be expressed as follows: ​ $\text{explanation}(x)=\arg\min_{g\in{}G}L(f,g,\pi_x)+\Omega(g)$ The recipe for fitting local surrogate models: Choose your instance of interest for which you want to have an explanation of its black box prediction. Perturb your dataset and get the black box predictions for these new points. Weight the new samples by their proximity to the instance of interest. Fit a weighted, interpretable model on the dataset with the variations. Explain prediction by interpreting the local model. How to get the variations of the data: This differs depending on the type of data, which can be either text, an image or tabular data. LIME for tabular DataTabular data means any data that comes in tables, where each row represents an instance and each column a feature. LIME sampling is not done around the instance of interest, but from the training data’s mass centre, which is problematic. But it increases the likelihood that the outcome for some of the sampled points predictions differ from the data point of interest and that LIME can learn at least some explanation. LIME for TextStarting from the original text, new texts are created by randomly removing words from it. The dataset is represented with binary features for each word. A feature is 1 if the respective word is included and 0 if it was removed. LIME for imagevariations of the samples (i.e. images) are created by performing superpixel segmentation and switching superpixels off. (Superpixels are connected pixels with similar colors and can be turned off by replacing each pixel by a user provided color) Advantages &amp; DisadvantagesAdvantages Even if you exchange the underlying machine learning model, you can still use the same local, interpretable model for explanation. Local surrogate models benefit from the literature and experience of training and interpreting interpretable models. When using LASSO or short trees, the resulting explanations are short (=selective) and possibly contrastive. LIME is one of the few methods that works for tabular data, texts and images. Disadvantages The correct definition of the neighbourhood is a very big, unsolved problem when using LIME with tabular data. Sampling could be improved in the current implementation of LIME. The complexity of the explanation model has to be defined in advance. The instability of the explanations. 5.8 Shapley Value Explanations参考资料 https://christophm.github.io/interpretable-ml-book/]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode167TwoSum]]></title>
    <url>%2F2018%2F11%2F19%2Fleetcode167TwoSum%2F</url>
    <content type="text"><![CDATA[群里今天的题是4sum，找出四个数的和是给定值 想了一下不知道咋搞，查的时候看到leetcode上有一堆类似的题，2sum,3sum 那就这周的五个题就做这个类型吧，也不知道算啥类型就写了个sum 167. Two Sum II - Input array is sorted这个题目也不是最原型的题目，这个是给了一个给定顺序的数组，要求返回索引值 最原型的题目是无序的数组，然后返回数组值，用一个map保存然后输出的时候判断一下大小即可。 这次要输出索引值，换成字典 每一次遍历时判断字典中是否已经有target-numbers[i],有的话直接返回[d[numbers[i]],i+1] 没有则把t-n[i]的值和i一起存入字典 12345678class Solution(object): def twoSum(self, numbers, target): d = dict() for i in range(len(numbers)): com = target - numbers[i] if(d.has_key(numbers[i])): return [d[numbers[i]],i+1] d.setdefault(com,i+1) 参考资料]]></content>
      <categories>
        <category>leetcode</category>
        <category>sum</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双指针总结]]></title>
    <url>%2F2018%2F11%2F18%2F%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[按照主题的第二周的刷题，这周都是双指针的题目 一共五道题 这五个题涉及到的双指针可以解决的类型有： 数组的原地排序（两个数905,三个数75） 回文序列 125 寻找环 287 后面遇到其他的类型再继续添加]]></content>
      <categories>
        <category>总结</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基础五]]></title>
    <url>%2F2018%2F11%2F16%2Fvue%E5%9F%BA%E7%A1%80%E4%BA%94%2F</url>
    <content type="text"><![CDATA[[TOC] vue组件基础 Vue基础(五) 组件基础组件是可以复用的vue实例，并且带有一个名字，我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用： 12345678910// 定义一个名为 button-counter 的新组件Vue.component('button-counter', &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;, template: '&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'&#125;)new Vue(&#123;el:"#components-demo"&#125;) 123&lt;div id="components-demo"&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; 因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el这样根实例特有的选项。 组件的复用可以将组件复用任意的次数，每个组件都会维护他自己的count。 因为每用一次组件，就会有一个新的实例被创建 12345&lt;div id="components-demo"&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; data必须是一个函数组件的data选项必须是函数，这样每个实例就可以维护一份被返回对象的独立的拷贝，否则他们会共享一个count值。 组件的组织通常一个应用会以一棵嵌套的组件树的形势来组织: 可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。 为了让Vue可以识别需要进行组件的注册Vue.component就是组件的全局注册 待续 通过Prop向子组件传递数据pop是可以在组件上注册的自定义特性。当一个值传递给prop特性时他就变成了那个组件实例的一个属性。 1234Vue.component('blog-post', &#123; props: ['title'], template: '&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;'&#125;) 上面代码中title就变成了blog-post这个组件实例的一个属性 1&lt;blog-post title="My journey With Vue"&gt;&lt;/blog-post&gt; 待续 单个根元素vue每个组件必须只有一个根元素 如果模板中包含更多的东西时不能直接写 12template:'&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt; &lt;div v-html="content"&gt;&lt;/div&gt;' 但是可以把他包含在一个父元素中 12345template:'&lt;div class="blog-post"&gt; &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt; &lt;div v-html="content"&gt;&lt;/div&gt;&lt;/div&gt;' 12345&lt;blog-post v-for="post in posts" v-bind:key="post.id" v-bind:post="post"&gt;&lt;/blog-post&gt; 12345678910111213141516171819Vue.component('blog-post', &#123; props: ['post'], template: ` &lt;div class="blog-post"&gt; &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt; &lt;div v-html="post.content"&gt;&lt;/div&gt; &lt;/div&gt; `&#125;)new Vue(&#123; el:'#blog-post-demo', data:&#123; posts:[ &#123;title:,content:&#125;, ... ] &#125;&#125;) 通过事件向父级组件发送消息子组件通过emit来触发事件，把消息传递出去 1234567891011121314151617181920Vue.component('blog-post', &#123; props: ['post'], template: ` &lt;div class="blog-post"&gt; &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt; &lt;button v-on:click="emit('enlarge-text')"&gt; Enlarge text &lt;/button&gt; &lt;div v-html="post.content"&gt;&lt;/div&gt; &lt;/div&gt; `&#125;)new Vue(&#123; el: '#blog-posts-events-demo', data: &#123; posts: [/* ... */], postFontSize: 1 &#125;&#125;) 123&lt;div id='blog-post-event-demo'&gt; &lt;blog-post v-on:energe-text:"postFontSize+=0.1"&gt;&lt;/blog-post&gt;&lt;/div&gt; 也可以使用emit的第二个参数来抛出值，这个参数抛出的值在v-on中用$event来接收 如果事件处理函数是一个方法，那么这个值会被作为方法的第一个参数传入 123&lt;button v-on:click="$emit('enlarge-text', 0.1)"&gt; Enlarge text&lt;/button&gt; 用$event接收 1234&lt;blog-post ... v-on:enlarge-text="postFontSize += $event"&gt;&lt;/blog-post&gt; 方法 1234&lt;blog-post ... v-on:enlarge-text="onEnlargeText"&gt;&lt;/blog-post&gt; 在组件上使用v-model如果想让自定义输入组件支持v-model需要这样做 123456789Vue.component('custom-input', &#123; props: ['value'], template: ` &lt;input v-bind:value="value" v-on:input="$emit('input', $event.target.value)" &gt; `&#125;) 1&lt;custom-input v-model="searchText"&gt;&lt;/custom-input&gt; 参考资料]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode287Find_the_Duplicate_Number]]></title>
    <url>%2F2018%2F11%2F16%2Fleetcode287Find-the-Duplicate-Number%2F</url>
    <content type="text"><![CDATA[寻找数组中重复的数值 287. Find the Duplicate NumberGiven an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once. 难点在于时间复杂度和空间复杂度要求比较高，所以不能暴力解 注意题目给的两个条件: 只有一个重复的数值 数组中最大值不超过n-1 看到别人很巧妙的解法 思路: 利用条件2可以把数组转换为一个链表 由条件1可以知道这个链表是一个有环链表，并且入环点就是重复的值 如数组 [1,2,3,5,4,2]转换为链表 然后这个问题就转换成了寻找链表入环点的问题 就很自然想到了快慢指针，然后始终会在一个点相遇 最后要解决的问题就是相遇点和入环点之间的关系 先上结论： 相遇点到入环点的距离 = 链表头到入环点的距离 证明: 如图所示： S是起始点，O是入环点，x是相遇点 x是从o到X的距离 m是从x到o的距离 慢指针走过的路程：SO+x 快指针走过的路程: SO+x+m 相遇时满足条件：SO+x+m = 2(SO+x) 整理得到m = SO+x 有了这个结论后，我们让慢指针回到起始点，然后和快指针一起往前走，他们就一定会在入环点相遇 123456789101112class Solution(object): def findDuplicate(self, nums): s = nums[nums[0]] f = nums[nums[s]] while(s!=f): s = nums[s] f = nums[nums[f]] s = 0 while(s!=f): s = nums[s] f = nums[f] return s 参考资料]]></content>
      <categories>
        <category>leetcode</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基础四]]></title>
    <url>%2F2018%2F11%2F15%2Fvue%E5%9F%BA%E7%A1%80%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[[TOC] vue 事件、表单绑定 vue基础 事件，表单绑定事件处理v-on监听事件，并在触发时运行一些代码 1234&lt;div id="example-1"&gt; &lt;button v-on:click="counter += 1"&gt;Add 1&lt;/button&gt; &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;/p&gt;&lt;/div&gt; 123456var example1 = new Vue(&#123; el: '#example-1', data: &#123; counter: 0 &#125;&#125;) 事件处理方法v-on可以接受一个需要调用的方法 也可以在内联js语句中调用方法 也可以把特殊变量$event传入方法 123456&lt;div id="example-2"&gt; &lt;!-- `greet` 是在下面定义的方法名 --&gt; &lt;button v-on:click="greet"&gt;Greet&lt;/button&gt; &lt;button v-on:click="sayHi(‘hi’)"&gt;SayHi&lt;/button&gt; &lt;button v-on:click="warn(‘Warn’,$event)"&gt;Warn&lt;/button&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728var example2 = new Vue(&#123; el: '#example-2', data: &#123; name: 'Vue.js' &#125;, // 在 `methods` 对象中定义方法 methods: &#123; greet: function (event) &#123; // `this` 在方法里指向当前 Vue 实例 alert('Hello ' + this.name + '!') // `event` 是原生 DOM 事件 if (event) &#123; alert(event.target.tagName) &#125; &#125;, sayHi:function(message)&#123; alert(message) &#125; &#125;, warn:function(message,event)&#123; if(event) event.preventDefault() alert(message) &#125; &#125;)// 也可以用 JavaScript 直接调用方法example2.greet() // =&gt; 'Hello Vue.js!' 事件修饰符目的：让方法只有简单的数据逻辑，没有DOM事件细节 .stop .prevent .capture .self .once .passive 12345678910111213141516171819&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt; 按键修饰符系统修饰符表单输入绑定你可以用 v-model 指令在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。 基础用法文本12&lt;input v-model="message" placeholder="edit me"&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; 1234&lt;span&gt;Multiline message is:&lt;/span&gt;&lt;p style="white-space: pre-line;"&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;br&gt;&lt;textarea v-model="message" placeholder="add multiple lines"&gt;&lt;/textarea&gt; 复选框单个 12&lt;input type="checkbox" id="checkbox" v-model="checked"&gt;&lt;label for="checkbox"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; 多个 12345678910&lt;div id='example-3'&gt; &lt;input type="checkbox" id="jack" value="Jack" v-model="checkedNames"&gt; &lt;label for="jack"&gt;Jack&lt;/label&gt; &lt;input type="checkbox" id="john" value="John" v-model="checkedNames"&gt; &lt;label for="john"&gt;John&lt;/label&gt; &lt;input type="checkbox" id="mike" value="Mike" v-model="checkedNames"&gt; &lt;label for="mike"&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-3', data: &#123; checkedNames: [] &#125;&#125;) 单选框123456789&lt;div id="example-4"&gt; &lt;input type="radio" id="one" value="One" v-model="picked"&gt; &lt;label for="one"&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type="radio" id="two" value="Two" v-model="picked"&gt; &lt;label for="two"&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456var example4 = new Vue(&#123; el:'#example-4', data:&#123; picked:'' &#125;&#125;) 选择框单选 字符串 如果是多选用数组 12345678&lt;div id = 'example-5'&gt; &lt;select v-model="selected"&gt; &lt;option disabled value = ''&gt;请选择&lt;/option&gt; &lt;option value='A'&gt;A&lt;/option&gt; &lt;option value='B'&gt;B&lt;/option&gt; &lt;/select&gt; &lt;span&gt;&#123;&#123;selected&#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456var example5 = new Vue(&#123; el:'#example-5', data:&#123; selected:'' &#125;&#125;) 可以用v-for动态渲染 12345&lt;select v-model="options"&gt; &lt;option v-for='option in options' v-bind:value="option.value"&gt; &#123;&#123;option.text&#125;&#125; &lt;/option&gt;&lt;/select&gt; 1234567891011new Vue(&#123; el: '...', data: &#123; selected: 'A', options: [ &#123; text: 'One', value: 'A' &#125;, &#123; text: 'Two', value: 'B' &#125;, &#123; text: 'Three', value: 'C' &#125; ] &#125;&#125;) 值绑定把值绑定到 Vue 实例的一个动态属性上，这时可以用 v-bind 实现，并且这个属性的值可以不是字符串。 12&lt;input type="radio" v-model="pick" v-bind:value="a"&gt;&lt;!-- 当被选中 vm.pick = a --&gt; 123456&lt;select v-model="selected"&gt; &lt;!-- 内联对象字面量 --&gt; &lt;option v-bind:value="&#123; number: 123 &#125;"&gt;123&lt;/option&gt;&lt;/select&gt;&lt;!-- 当被选中 vm.selected = &#123;number:123&#125; --&gt; 修饰符.lazy 在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转变为使用 change事件进行同步： 12&lt;!-- 在“change”时而非“input”时更新 --&gt;&lt;input v-model.lazy="msg" &gt; .number 用户输入自动转成数值类型 1&lt;input v-model.number="age" type="number"&gt; .trim 1&lt;input v-model.trim = "msg"&gt; 参考资料 https://cn.vuejs.org/v2/guide/events.html]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode75_Sort_Colors]]></title>
    <url>%2F2018%2F11%2F15%2Fleetcode75-Sort-Colors%2F</url>
    <content type="text"><![CDATA[双指针三个元素的原地排序 Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library’s sort function for this problem. 12Input: [2,0,2,1,1,0]Output: [0,0,1,1,2,2] 还是双指针的题，自己只想到了暴力思路 先把0放在前面， 然后再遍历一次把1放在前面 12345678910111213class Solution(object): def sortColors(self, nums): l = len(nums) j = 0 k=l-1 for i in range(l): if(nums[i]==0): nums[i],num[j] = nums[j],nums[i] j+=1 for i in range(l): if(nums[i]==1): nums[i],num[j] = nums[j],nums[i] j+=1 看了别人提交的代码，三个指针 其实最开始也是想到了这个思路，就是什么时候i+=1混乱了，导致[1,2,0]的样例通不过。 如果是跟k交换，i不要加1，要等下一轮迭代再判断一次交换过来的值才可以。 123456789101112131415class Solution(object): def sortColors(self, nums): l = len(nums) i,j = 0,0 k=l-1 while(i&lt;=k): if(nums[i]==1): i+=1 elif(nums[i]==0): nums[i],nums[j] = nums[j],nums[i] j+=1 i+=1 else: nums[i],nums[k] = nums[k],nums[i] k-=1]]></content>
      <categories>
        <category>leetcode</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode27移除元素]]></title>
    <url>%2F2018%2F11%2F14%2Fleetcode27%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[双指针移除元素 leetcode27移除元素Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. 题目虽然要求的是返回移除后的数组长度l，但是最后的输出值是移除元素后的数组。（输出原数组的前l项） 所以不能只得到长度，要对数组进行操作，把数组的前l项变为移除val后的值。 因为还是特意找的双指针的题目，所以知道双指针的思路后发现跟之前做过的一个把所有的0移到后面的题目是一样的，把所有val值后移即可 思路： 两个指针i,j，j始终在后面 如果i指向不是val的值则交换并且j+1 如果指向的是val则j和数组不作操作,i+1。 1234567891011121314class Solution(object): def removeElement(self, nums, val): l = len(nums) result = l j=0 for i in range(l): if(val != nums[i]): temp = nums[i] nums[i] = nums[j] nums[j] = temp j+=1 else: result-=1 return result 二刷读完题知道应该是把要移除的值后移，最开始想的是判断如果是val则把这个值与最后面的交换，但是这样如果出现如果最后面的值也是val就会出错。 思路应该是反过来： 遍历判断当前值看是否不等于val 如果不等于则result+1,并把这个值前移 若等于则继续遍历 12345678class Solution(object): def removeElement(self, nums, val): result=0 for i in range(len(nums)): if(nums[i]!=val): nums[i],nums[result] = nums[result],nums[i] result+=1 return result 代码比第一次的时候思路要清晰多了]]></content>
      <categories>
        <category>leetcode</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode125Valid_Palindrome]]></title>
    <url>%2F2018%2F11%2F13%2Fleetcode125Valid-Palindrome%2F</url>
    <content type="text"><![CDATA[判断一个字符串是否是回文字符串 既然第一天做了双指针的问题，就干脆这周都做双指针的问题吧~应该相对比较好理解，考试压力大刷点简单的题目&gt;&lt; 125. Valid Palindrome 1234567891011class Solution(object): def isPalindrome(self, s): if(len(s)==0 or len(s)==1): return True ss = [ch for ch in s.lower() if ch.isalpha() or ch.isdigit()] l = len(ss) for i in range(l/2): print(i,l-i-1) if(ss[i]!=ss[l-i-1]): return False return True 就很简单的先把数组中非字母非数字的字符去掉，然后双指针比较，如果不相同则返回Flase Python列表的过滤 1234[expr for iter_val in iterable if cond_expr]#求奇数b = [val for val in a if val%2==1]]]></content>
      <categories>
        <category>leetcode</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine_Learning_Explanations_with_Topological_Data_Analysis]]></title>
    <url>%2F2018%2F11%2F12%2FMachine-Learning-Explanations-with-Topological-Data-Analysis%2F</url>
    <content type="text"><![CDATA[用拓扑数据分析来解释深度学习 [TOC] Machine Learning Explanations with Topological Data Analysis术语解释 simplicial complexes：单纯复形是拓扑学中的概念，指由点，线，三角形等单纯形“粘合”而得的拓扑对象。 cover of dataset:A cover of a data set is a collection of subsets of the data such that every data point is in at least one of the subsets. nerve:The nerve is a simplicial complex created from a cover by collapsing each cover element into vertices and connecting vertices when the cover elements had points in common. nerve of a cover : A construction of an abstract simplicial complex from an open covering.html)of a topological space X. lens: A secondary representation of the data that encodes some interested aspect or information about the data set. ?? pullback cover: IntroductionWe will demonstrate a novel application of Mapper to the domain of explanatory machine learning and show how Mapper can be used to understand not just the shape of data, but also understand a machine learning model. 提出了Mapper的一个新的应用来解释机器学习。 Topological Building BlocksBoth Mapper and Persistent Homology make use of simplicial complexes as the tool for understanding complicated shape. A simplicial complex is a generalization of a graph, with a few special features. simplicial complexes are built from the nerve of a cover Mapper constructs a single cover in a supervised manner and provides a representation suitable for exploratory data analysis. In this work, we will focus on understanding the exploratory power of Mapper and how we can apply it to understand a machine learning model. Mapper Mapper can be thought of as a method of estimating and capturing this essential high dimensional structure. Mapper是一个评价刻画高维数据的方法。 单纯复形在探索数据间的关系时美观实用 creating a lens computing the pullback cover of our constructed lens cover. compute the nerve of our constructed pullback cover. Data and Model A Logistic Regression model to 91.5% test set accuracy using Scikit-Learn Mapper for explaining machine learningDesigning a new type of cover specifically for machine learning classifiers. method: rank and threshold the predicted probabilities for each observation and generate a cover element for similarly ranked observations. new covering technique Instance Based ExplanationInstance based explanation is a particular type of explainable machine learning that focuses on explaining predictions through other observations. A Global ViewEach node represents a heterogenous set of leaves that are the model considers similar and each edge represents a relationship between nodes. 同一类的会较高概率聚在一起 Local Instances This particular Chestnut was chosen for demonstration because, while the classification was correct, the confidence in prediction was not very large. These three graphs show different levels of information about the instance. The first shows only the nodes that contain this particular Chestnut. The middle graph shows all nodes that contain any Chestnut leaves at all. The third graph shows the same region of Chestnut nodes, but also shows all of neighboring nodes, colored by their majority leaf type. The edges of the third graph are also colored based on the majority class comprising that edge. Escape Routes Scaling Up MNIST data set 跟人判断的边界一样，模型在一些相似的物体上的界限会比较模糊 边界点上的样子，可以看出是慢慢过渡的 ConclusionUsing this representation, we can extract insights into what the model is thinking, where it gets confused.By connecting and compressing the input and output spaces of the model, we gain a keen understanding of the data and how the model interprets the data. 参考资料 https://sauln.github.io/blog/tda_explanations/]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode905按照奇偶顺序排列数组]]></title>
    <url>%2F2018%2F11%2F12%2Fleetcode905%E6%8C%89%E7%85%A7%E5%A5%87%E5%81%B6%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[按照奇偶顺序排列数组 这周跟一下刷题群的进度，第一个题就很简单了，两个思路，一个是分配新的空间，一个是直接在数组上修改 1234567891011121314151617181920212223class Solution(object): # def sortArrayByParity(self, A): # a = [] # b = [] # for i in A: # if(i%2==0): # a.append(i) # else: # b.append(i) # return a+b def sortArrayByParity(self, A): i=0 j=len(A)-1 while(i&lt;j): if(A[i]%2==1 and A[j]%2==0): temp = A[i] A[i] = A[j] A[j] = temp elif(A[i]%2==0): i=i+1 elif(A[j]%2==1): j=j-1 return A]]></content>
      <categories>
        <category>leetcode</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一周简单递归总结]]></title>
    <url>%2F2018%2F11%2F11%2F%E7%AC%AC%E4%B8%80%E5%91%A8%E7%AE%80%E5%8D%95%E9%80%92%E5%BD%92%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[11.5-11.9第一周递归的刷题总结 这一周的一共做了五个题目都是可以用递归的思想去解答，也都是跟二叉树相关的题目 二叉树的合并 二叉树的反转 找出二叉树中最长的路径 按层次输出二叉树的节点 判断一棵树是不是另一颗树的子树 其中合并，反转都是简单的一个递归函数就可以解决 把问题分解成小的问题，然后每次解决掉这个小问题后继续递归左右子树 反转最简单的是反转： http://cuteanian.top/2018/11/06/leetcode226%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/ 问题分解成每一个节点的左右节点的反转，然后再去递归这个节点的左右子树 遇到空就返回，然后依次返回直到回到最开始调用reverse的根节点 123456def reverse(self,t): if(t!=None): t.left,t.right = t.right,t.left self.reverse(t.left) self.reverst(t.right) return t 合并http://cuteanian.top/2018/11/05/leetcode617%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/ 合并的问题稍微有些复杂，但也是一个递归函数就可以解决，复杂点在于每一个小任务需要做的事情比反转要多 需要新生成一颗树，因为要返回的是一个合并后的树 每一次递归都会给这个新树增加新的节点，递归的最后依然会回到最开始调用merge的那个函数，返回第一次创建的mergeT 123456789def merge(self,t1,t2): if(t1==None): return t2 if(t2==None): return t1 mergeT = TreeNone(t1.val+t2.val) mergeT.left = self.merge(t1.left,t2.left) mergeT.right = self.mergt(t1.right,t2.right) return mergeT 找出二叉树中最长的路径http://cuteanian.top/2018/11/07/leetcode543%E6%89%BE%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E8%B7%AF%E5%BE%84/ 首先可以考虑一个简单的题目，找出二叉树的深度 非常简单基础的递归思路 12345def findDeep(self,t): if(t==None): return t else: return 1+max(self.findDeep(t.left),self.findDeep(t.right)) 找出二叉树中最长的路径不是像深度一样可以简单的遍历，只需要判断单边的最大即可 通过观察可以发现，最长路径一定有一个转折点，最长路径=转折点左子树深度+转折点右子树深度 一个简单的想法就是递归每一个节点，计算他们作为转折点时的路径长度，然后返回最长的值 1234567891011121314class Solution(object): max = 0 def diameterOfBinaryTree(self, root): self.findMax(root) return self.max def findMax(self,node): if(node == None): return 0 else: l = self.findMax(node.left) r = self.findMax(node.right) if(l+r&gt;self.max): self.max = l+r return max(l,r)+1 为什么一个递归函数不能解决问题： 这个问题划分为小问题的时候有三步: 计算当前节点的左右子树的最大深度 判断左+右是否比当前保存的值要大，大的话更新 最后返回max 在第一步计算深度的时候，我们需要函数的返回值是该节点左右子树的深度，这与题目最后需要返回的max冲突，所以需要另外开辟一个递归函数，让这个函数去更新max的值，最后由主函数去返回max的值。 当然也可以在主函数中返回左右子树的深度，但是这样就没有地方去返回max，在函数中输出max可以看到最后max的值就是我们想要得到的结果，思想都是一样的 123456789def diameterOfBinaryTree(self, root): if(root==None): return 0 else: l = self.diameterOfBinaryTree(root.left) r = self.diameterOfBinaryTree(root.right) self.max = max(self.max,l+r) print(self.max) return max(l,r)+1 按层次输出二叉树的节点http://cuteanian.top/2018/11/08/leetcode102%E6%8C%89%E5%B1%82%E6%AC%A1%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9/ DFS这个题目第一感受是可以用BFS，但是问题在于用BFS反而难判断每一层的结束在哪儿 用DFS更容易去保存深度 如果当前结果数组的长度小于该节点的深度，则新加入一个数组并把当前值push进去 否则就可以直接把当前值push进去 12345678910111213141516class Solution(object): result=[] def levelOrder(self,root): self.result=[] if(root!=None): self.DFS(root,0) return self.result def DFS(self,node,depth): if(node!=None): print(node.val,depth) if(len(self.result)&lt;depth+1): # 如果result没有当前节点层次的数组就新建并且添加当前值 self.result.append([node.val]) else: #如果有就直接添加当前值 self.result[depth].append(node.val) self.DFS(node.left,depth+1) self.DFS(node.right,depth+1) BFSBFS需要保存两个队列，一个是传统用于BFS遍历的队列，当这个队列为空时遍历结束。 传统BFS更新时是每出队一个节点，就把该节点的左右孩子加入到队列中 这个题目更新时思路是： 每次出队的是一个层次的所有节点，然后把这一个层次的所有节点的左右孩子（下个层次的所有节点）加入到队列中。 用一个新的队列nextqueue来保存下个层次的所有节点，也用这个新的队列去更新queue queue中始终保存的是当前层次的所有节点 123456789101112131415161718192021class Solution(object): def levelOrder(self, root): queue = [] result = [] if(root!=None): queue.append(root) while(queue): #当总队列为空时结束 nextqueue = [] thislevelval = [] #遍历当前层次的所有节点，把当前层次的节点的值写入数组，把下一层次的所有节点加入到nextqueue中 for node in queue: thislevelval.append(node.val) if(node.left!=None): nextqueue.append(node.left) if(node.right!=None): nextqueue.append(node.right) # 用下一层次的节点替换当queue并继续遍历 queue = nextqueue # 当前层次值数组加入到结果数组中 result.append(thislevelval) return result 判断一颗树是不是另一颗树的子树http://cuteanian.top/2018/11/09/572%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%A6%E4%B8%80%E9%A2%97%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/ 子树的概念必须是从s的一个节点开始下面所有的节点都和t相等，也就是从s的这个节点开始和t完全一致 这样就可以借助判断两个二叉树是否相等的思想来解答了 依次判断s的节点，看从该节点开始是否和t相等 如果相等则返回true，不相等则继续递归s 直至返回true，或者s==None返回false。 1234567891011121314151617class Solution(Object): def isSubtree(self,s,t): if(s==None): return False if(self.isSametree(s,t)): return True else: return (self.isSubtree(s.left,t) or self.isSubstree(s.right,t)) def isSameTree(self,s,t): if(not s and not t): return True elif(not s or not t): return False elif(s.val!=t.val): return False else: return self.isSameTree(s.left,r.left) and self.isSametree(s.right,r.right) 参考资料]]></content>
      <categories>
        <category>总结</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode572判断一棵树是不是另一颗树的子树]]></title>
    <url>%2F2018%2F11%2F09%2F572%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%A6%E4%B8%80%E9%A2%97%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[判断一棵树是不是另一颗树的子树 572. Subtree of Another TreeGiven two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node’s descendants. The tree s could also be considered as a subtree of itself. 最开始的想法是先序后者其他序遍历然后保存字符串进行比较看t是否是s的子字符串，但是这种想法不符合示例2 子树的概念必须是从s的一个节点开始下面所有的节点都和t相等，也就是从s的这个节点开始和t完全一致 这样就可以借助判断两个二叉树是否相等的思想来解答了 依次判断s的节点，看从该节点开始是否和t相等 如果相等则返回true，不相等则继续递归s 直至返回true，或者s==None返回false。 123456789101112131415161718class Solution(object): def isSubtree(self, s, t): if(s==None): return False if(self.isSametree(s,t)): return True else: return(self.isSubtree(s.left,t) or self.isSubtree(s.right,t)) def isSametree(self,s,t): if(not s and not t): return True elif(not s or not t): return False elif(s.val!=t.val): return False else: return self.isSametree(s.left,t.left) and self.isSametree(s.right,t.right) 但是参考资料有一个字符串的解法，还没搞懂思路，周末回来再看一下~ 参考资料 http://www.cnblogs.com/grandyang/p/6828687.html]]></content>
      <categories>
        <category>leetcode</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基础二]]></title>
    <url>%2F2018%2F11%2F09%2Fvue%E5%9F%BA%E7%A1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Vue基础（二） 计算属性和侦听器、Class与Style绑定 计算属性和侦听器计算属性对于简单运算，可以使用模板内的表达式，但是对于复杂逻辑，应该使用计算属性 简单例子: 1234&lt;div id="example"&gt; &lt;p&gt;Original message: "&#123;&#123; message &#125;&#125;"&lt;/p&gt; &lt;p&gt;Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"&lt;/p&gt;&lt;/div&gt; 12345678910111213var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125; &#125;&#125;) 这里reversedMessage是一个计算属性。提供的函数被用作属性vm.reversedMessage的getter函数，每次使用reversedMessage函数时都会调用这个getter函数并得到返回值。 ### 计算属性缓存vs方法其实可以在表达式中来调用方法得到同样的效果 123&lt;p&gt; Reversed message:"&#123;&#123;reversedMessage()&#125;&#125;&lt;/p&gt; 12345methods:&#123; reversedMessage:function()&#123; return this.message.split('').reverse().join('') &#125;&#125; 就这个例子而言，两者的结果完全相同 不同的是，计算属性是基于他们的依赖来进行缓存，也就是说如果message没有发生改变，多次访问reversedMessage会立即返回之前计算的结果。 123456//这个计算属性并不会随时间更新computed:&#123; now:function()&#123; return Date.now() &#125;&#125; 相比之下，每次触发重新渲染时，调用的方法总会再次执行函数。 ### 计算属性vs侦听属性vue提供了一个侦听属性来观察并且响应vue实例上的数据变化。 但当有一些数据需要随着其他数据的变化而变化时，用计算属性会比用侦听属性要好 1&lt;div id="demo"&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt; watch: 12345678910111213141516var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + ' ' + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + ' ' + val &#125; &#125;&#125;) computed： 计算属性依赖于原数据，所以当原数据改变时，计算属性的绑定也会更新。 123456789101112var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar' &#125;, computed: &#123; fullName: function () &#123; return this.firstName + ' ' + this.lastName &#125; &#125;&#125;) 侦听器计算属性在大多数场合下都适用，但是当数据变化时执行异步或开销较大的操作时，还是需要用到更通用的侦听器 1234567&lt;div id="watch-example"&gt; &lt;p&gt; Ask a yes/no question: &lt;input v-model="question"&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"&gt;&lt;/script&gt;&lt;script&gt;var watchExampleVM = new Vue(&#123; el: '#watch-example', data: &#123; question: '', answer: 'I cannot give you an answer until you ask a question!' &#125;, watch: &#123; // 如果 `question` 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) &#123; this.answer = 'Waiting for you to stop typing...' this.debouncedGetAnswer() &#125; &#125;, created: function () &#123; // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。 // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率 // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于 // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识， // 请参考：https://lodash.com/docs#debounce this.debouncedGetAnswer = _.debounce(this.getAnswer, 500) &#125;, methods: &#123; getAnswer: function () &#123; if (this.question.indexOf('?') === -1) &#123; this.answer = 'Questions usually contain a question mark. ;-)' return &#125; this.answer = 'Thinking...' var vm = this axios.get('https://yesno.wtf/api') .then(function (response) &#123; vm.answer = _.capitalize(response.data.answer) &#125;) .catch(function (error) &#123; vm.answer = 'Error! Could not reach the API. ' + error &#125;) &#125; &#125;&#125;)&lt;/script&gt; Class与Style绑定class和内联样式都是属性，所以可以用v-bind来处理，只需要通过表达式计算出字符串结果即可。 但是字符串拼接麻烦而且容易出错，所以vue.js做了增强。表达式的结果除了是字符串以外，还可以是对象或者数组 绑定HTML CLASS对象语法可以给v-bind:class传递一个对象，动态切换class 1&lt;div v-bind:class="&#123;active:isActive&#125;"&gt;&lt;/div&gt; 表示active这个属性的存在由isActice的真假决定 v-bind:class指令可以与普通的class属性共存 123&lt;div class="static" v-bind:class="&#123; active: isActive, 'text-danger': hasError &#125;"&gt;&lt;/div&gt; 1234data: &#123; isActive: true, hasError: false&#125; 结果会被渲染为: 1&lt;div class="static,active"&gt;&lt;/div&gt; 当isActive或者hasError变化时，class列表也会相应地更新。 绑定的数据对象不必放在模板里，可以直接在模板中放入对象名称，然后定义在数据中 1&lt;div v-bind:class="classObject"&gt;&lt;/div&gt; 123456data: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125; 也可以使用计算属性模式 1&lt;div v-bind:class="classObject"&gt;&lt;/div&gt; 123456789101112data: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, 'text-danger': this.error &amp;&amp; this.error.type === 'fatal' &#125; &#125;&#125; 数组语法也可以把一个数组传给v-bind:class指令 1&lt;div v-bind:class="[activeClass, errorClass]"&gt;&lt;/div&gt; 1234data: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; 被渲染为: 1&lt;div class='active,text-danger'&gt;&lt;/div&gt; 也可以在数组语法中使用对象语法 1&lt;div v-bind:class="[&#123; active: isActive &#125;, errorClass]"&gt;&lt;/div&gt; 用在组件上(看完组件回来补充)绑定内联样式对象语法1&lt;div v-bind:style="styleObject"&gt;&lt;/div&gt; 123456data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;&#125; 数组语法数组语法可以将多个样式对象应用到同一个元素上: 1&lt;div v-bind:style="[baseStyles, overridingStyles]"&gt;&lt;/div&gt; 参考资料 https://cn.vuejs.org/v2/guide/computed.html]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode102按层次输出二叉树的节点]]></title>
    <url>%2F2018%2F11%2F08%2Fleetcode102%E6%8C%89%E5%B1%82%E6%AC%A1%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[按层次数出二叉树的节点 102. Binary Tree Level Order TraversalGiven a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 思路：二叉树的遍历问题，BFS和DFS都可以解决，直观感受好像是BFS更加符合要求，但是题目要求按层次输出，不是简单的直接输出层次遍历的结果，反而是DFS更加容易保留层次，然后根据层次进行判断并写入数组，时间复杂度都是o(n) DFS按照DFS进行二叉树的遍历，多传入一个参数用于保存当前节点的层次 12345678910111213141516class Solution(object): result=[] def levelOrder(self,root): self.result=[] if(root!=None): self.DFS(root,0) return self.result def DFS(self,node,depth): if(node!=None): print(node.val,depth) if(len(self.result)&lt;depth+1): # 如果result没有当前节点层次的数组就新建并且添加当前值 self.result.append([node.val]) else: #如果有就直接添加当前值 self.result[depth].append(node.val) self.DFS(node.left,depth+1) self.DFS(node.right,depth+1) BFSBFS需要保存两个队列，一个是传统用于BFS遍历的队列，当这个队列为空时遍历结束。 传统BFS更新时是每出队一个节点，就把该节点的左右孩子加入到队列中 这个题目更新时思路是： 每次出队的是一个层次的所有节点，然后把这一个层次的所有节点的左右孩子（下个层次的所有节点）加入到队列中。 用一个新的队列nextqueue来保存下个层次的所有节点，也用这个新的队列去更新queue queue中始终保存的是当前层次的所有节点 123456789101112131415161718192021class Solution(object): def levelOrder(self, root): queue = [] result = [] if(root!=None): queue.append(root) while(queue): #当总队列为空时结束 nextqueue = [] thislevelval = [] #遍历当前层次的所有节点，把当前层次的节点的值写入数组，把下一层次的所有节点加入到nextqueue中 for node in queue: thislevelval.append(node.val) if(node.left!=None): nextqueue.append(node.left) if(node.right!=None): nextqueue.append(node.right) # 用下一层次的节点替换当queue并继续遍历 queue = nextqueue # 当前层次值数组加入到结果数组中 result.append(thislevelval) return result]]></content>
      <categories>
        <category>leetcode</category>
        <category>BFS</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基础一]]></title>
    <url>%2F2018%2F11%2F08%2Fvue%E5%9F%BA%E7%A1%80%E4%B8%80%2F</url>
    <content type="text"><![CDATA[vue基础(一) 实例，语法 Vue实例创建一个实例123var vm = new Vue(&#123; //选项&#125;) 每个vue应用都是从一个vue实例开始 创建一个 Vue 实例时，传入一个**选项对象，使用这些选项来创建想要的行为。 一个 Vue 应用由一个通过 new Vue 创建的根 Vue 实例，以及可选的嵌套的、可复用的组件树组成。举个例子，一个 todo 应用的组件树可以是这样的： 12345678根实例└─ TodoList ├─ TodoItem │ ├─ DeleteTodoButton │ └─ EditTodoButton └─ TodoListFooter ├─ ClearTodosButton └─ TodoListStatistics 数据与方法当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。 MVVM中的双向数据绑定 注意： 只有当实例被创建时 data 中存在的属性才是响应式的，后面添加的新属性的改动并不能引起视图的更新 使用 Object.freeze()，这会阻止修改现有的属性，也意味着响应系统无法再追踪变化。 12345678910var obj = &#123; foo: 'bar'&#125;Object.freeze(obj)new Vue(&#123; el: '#app', data: obj&#125;) data是vue实例的一个数据属性，除此之外,vue实例还暴露了一些有用的实力属性和方法，他们都有前缀$，以便与用户定义的属性区分开。 查看API:vue实例&amp;属性 实例生命周期钩子每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 模板语法Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。 插值文本文本插值的绑定形势是用双大括号 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 双大括号便签会被替代为所绑定的数据对象上msg的值，如果绑定对象上的msg属性值发生了变化，插值处的内容也会更新 原始html双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令： 12&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive: &lt;span v-html="rawHtml"&gt;&lt;/span&gt;&lt;/p&gt; 特性双大括号语法不能用在html特性上，需要用到v-bind指令: 1&lt;div v-bind:id="dynamicId"&gt;&lt;/div&gt; 在布尔特性的情况下，它们的存在即暗示为 true，v-bind 工作起来略有不同，在这个例子中： 1&lt;button v-bind:disabled="isButtonDisabled"&gt;Button&lt;/button&gt; 如果 isButtonDisabled 的值是 null、undefined 或 false，则 disabled 特性甚至不会被包含在渲染出来的 &lt;button&gt; 元素中。 使用JS表达式对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。 每个绑定都只能包含单个表达式，流程控制（if）不会生效，需要使用三元表达式 1234567&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;div v-bind:id="'list-' + id"&gt;&lt;/div&gt; 指令指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的值是单个 JavaScript 表达式。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 1&lt;p v-if="seen"&gt;Now you see me&lt;/p&gt; 这里，v-if 指令将根据表达式 seen 的值的真假来插入/移除 &lt;p&gt; 元素。 参数一个指令可以接收一个”参数”，在指令名称之后以冒号表示。 v-bind指令可以用于响应式地更新HTML特性: 1&lt;a v-bind:href="url"&gt;...&lt;/a&gt; href是参数，告知v-bind指令把该元素的href特性与表达式的url的值绑定 v-on指令，用于监听DOM事件 1&lt;a v-on:click="doSomething"&gt;...&lt;/a&gt; click是参数，是监听的事件名（点击事件）,给点击事件绑定回调函数doSomething 修饰符修饰符 (Modifiers) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()： 1&lt;form v-on:submit.prevent="onSubmit"&gt;...&lt;/form&gt; 缩写v-bind的缩写： 12345&lt;!-- 完整语法 --&gt;&lt;a v-bind:href="url"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href="url"&gt;...&lt;/a&gt; v-on的缩写: 12345&lt;!-- 完整语法 --&gt;&lt;a v-on:click="doSomething"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click="doSomething"&gt;...&lt;/a&gt; 参考资料 https://cn.vuejs.org/v2/guide/instance.html]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode543找出二叉树中最长的路径]]></title>
    <url>%2F2018%2F11%2F07%2Fleetcode543%E6%89%BE%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[找出二叉树中最长的路径 是之前做过一个题的升级版，上次刷还没搭好博客笔记也不见了就重新整理一下 ###104题，找出二叉树的深度 12345678910111213# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): if(root == None): return 0 else: return 1 + max(self.maxDepth(root.left),self.maxDepth(root.right)) 思路：还是递归的想法，分别递归左子树和右子树然后返回两者的最大值 543. Diameter of Binary Tree找出二叉树中的最长路径，稍微复杂一点，不是单边的最大值，而是两者相加的最大值 1234567891011121314class Solution(object): max = 0 def diameterOfBinaryTree(self, root): self.findMax(root) return self.max def findMax(self,node): if(node == None): return 0 else: l = self.findMax(node.left) r = self.findMax(node.right) if(l+r&gt;self.max): self.max = l+r return max(l,r)+1 思路： 因为需要保存一个最大值用来返回，所以一个函数不能解决，需要写一个寻找最大值的递归函数findMax() 每递归一个节点，先判断他的左和右的和是否大于max，如果是则更新max，然后返回左右的最大值。 参考资料 https://kingsfish.github.io/2017/07/13/Leetcode-543-Diameter-of-Binary-Tree/]]></content>
      <categories>
        <category>leetcode</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[a_simple_and_accurate_method_to_fool_deep_neural_networks]]></title>
    <url>%2F2018%2F11%2F07%2Fa-simple-and-accurate-method-to-fool-deep-neural-networks%2F</url>
    <content type="text"><![CDATA[一种攻击深度神经网络的方法 Abstractmain idea:propose the DeepFool algorithm to efficiently compute perturbations that fool deep networks, and thus reliably quantify the robustness of these classifiers. IntroductionDefine an adversarial perturbation as the minimal perturbation r that is sufficient to change the estimated label $k(x)$: We call ∆(x; k) the robustness of k at point x. The robustness of classifier k is then defined as: The study of adversarial perturbations helps us understand what features are used by a classifier. DeepFoolthe algorithm perturbs the image by a small vector that is computed to take the resulting image to the boundary of the polyhydron that is obtained by linearizing the boundaries of the region within which the image resides. The perturbations added to the image in each iteration are accumulated to compute the final perturbation once the perturbed image changes its label according to the original decision boundaries of the network. Conclusion DeepFool is based on an iterative linearization of the classifier to generate minimal perturbations that are sufficient to change classification labels. 参考资料 DeepFool: a simple and accurate method to fool deep neural networks]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode226反转二叉树]]></title>
    <url>%2F2018%2F11%2F06%2Fleetcode226%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Invert Binary Tree 思路： 跟昨天的题一样都是很简单的递归思路，有进步的地方就是这次没有去看别人的代码啦hhhh 1234567891011121314# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def invertTree(self, root): if(root!=None): root.left,root.right = root.right,root.left self.invertTree(root.left) self.invertTree(root.right) return root 代码是很简洁的三行，如果节点不为空先交换，然后再依次递归左子树和右子树 但是在写的过程中对于递归返回值理解不对，以为返回了这个函数就结束了，不知道该在哪里返回root，摸索中AC了。 递归的返回值应该是依次往上返回，最后一个返回空之后会回到上一个调用他的函数体中，然后返回这个节点，依次往上返回，最后回到最初调用的函数中，然后返回根节点root。]]></content>
      <categories>
        <category>leetcode</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue基础(三) 条件渲染、列表渲染]]></title>
    <url>%2F2018%2F11%2F05%2Fvue%E5%9F%BA%E7%A1%80%E4%B8%89%2F</url>
    <content type="text"><![CDATA[vue基础(三) 条件渲染、列表渲染 [TOC] 条件渲染v-if 指令1&lt;h1 v-if="ok"&gt;Yes&lt;/h1&gt; 12&lt;h1 v-if="ok"&gt;Yes&lt;/h1&gt;&lt;h1 v-else&gt;No&lt;/h1&gt; 123456new Vue(&#123; el:"#app", data:&#123; ok:true &#125; &#125;) 会根据vue模板中ok的真假来决定是否渲染 如果想控制多个元素，可以把一个template元素当做不可见的包裹元素，并在上面使用v-if 最终这个template元素不会被渲染 12345&lt;template v-if='ok'&gt; &lt;h1&gt;&lt;/h1&gt; &lt;h2&gt;&lt;/h2&gt; ...&lt;/template&gt; v-else v-else-if123456&lt;div v-if="Math.random() &gt; 0.5"&gt; Now you see me&lt;/div&gt;&lt;div v-else&gt; Now you don't&lt;/div&gt; 123456789101112&lt;div v-if="type === 'A'"&gt; A&lt;/div&gt;&lt;div v-else-if="type === 'B'"&gt; B&lt;/div&gt;&lt;div v-else-if="type === 'C'"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; v-else必须紧跟v-if v-else-if必须紧跟v-if或者v-if-else key管理可复用的元素Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。 12345678&lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder="Enter your username"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder="Enter your email address"&gt;&lt;/template&gt; 上面代码中的两个input，第二个不会被替换，而是复用上面的input 这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key 属性即可： 12345678&lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder="Enter your username" key="username-input"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder="Enter your email address" key="email-input"&gt;&lt;/template&gt; v-show指令v-show只是简单地切换元素的css属性display，元素会被渲染并始终留在dom中 v-if只有在值为真时才会渲染 因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 列表渲染v-for指令把一个数组对应成一组元素12345&lt;ul id="example-1"&gt; &lt;li v-for="item in items"&gt; &#123;&#123;item.message&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 123456789var example1 = new Vue(&#123; el:'#example-1', data:&#123; item[ &#123;message:'Foo'&#125;, &#123;message:'Bar'&#125; ] &#125;&#125;) 结果: v-for的两点性质 v-for块中对父作用域属性有完全访问权限 v-for支持一个可选的参数作为当前项的索引 12345&lt;ul id="example-2"&gt; &lt;li v-for="item,index in items"&gt; &#123;&#123;parentMessage&#125;&#125; - &#123;&#123;index&#125;&#125; - &#123;&#123;item.message&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345678910var example2 = new Vue(&#123; el:'#example-2', data:&#123; parentMessage:'Parent', item:[ &#123;message:'Foo'&#125;, &#123;message:'Bar'&#125; ] &#125;&#125;) 结果 v-for迭代对象12345&lt;ul id="example-3"&gt; &lt;li v-for='(value,key,index) in object'&gt; &#123;&#123;index&#125;&#125;. &#123;&#123;key&#125;&#125; : &#123;&#123;value&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345678910var example3 = new Vue(&#123; el:"#example-3", data:&#123; object:&#123; firstName:'John', lastName:'Doe', age:30 &#125; &#125;&#125;) result: 数组更新检测变异方法Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下： push() pop() shift() unshift() splice() sort() reverse() 替换数组可以用新数组去替换旧数组 1234//filter方法会返回一个符合条件的新数组example1.items = example1.items.filter(function (item) &#123; return item.message.match(/Foo/)&#125;) 注意事项由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 如果要实现vm.items[indexOfItem] = newValue的效果并且触发状态更新，可以使用： 1Vue.set(vm.items,indexOfItem,newValue) 或者 1Vue.items.splice(indexOfItem,1,newValue) 实现vm.items.length = newLength并触发更新: 1vm.items.splice(newLength) 由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除 123456789var vm = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)// `vm.a` 现在是响应式的vm.b = 2// `vm.b` 不是响应式的 对于已经创建的实例，vue不能添加根级别的响应性属性，但是可以使用Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。 123456789var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: 'Anika' &#125; &#125;&#125;)Vue.set(vm.userProfile,'age',27) 如果需要为已有属性赋予多个属性，使用Object.assign()，应该用两个对象的属性去创建一个新的对象。 1234vm.userProfile = Object.assign(&#123;&#125;,vm.userProfile,&#123; age:27, favoriteColor:'Vue Green'&#125;) 显示过滤/排序结果显示数组的某些结果但是不想改变原数组，有两种方法 计算属性 123&lt;li v-for="n in evenNumbers"&gt; &#123;&#123;n&#125;&#125;&lt;/li&gt; 12345678910111213var example = new Vue(&#123; el:'#id', data:&#123; numbers:[1,2,3,4,5] &#125;, computed:&#123; evenNumbers:function()&#123; return this.numbers.fliter(function(number)&#123; return number%2 === 0 &#125;) &#125; &#125;&#125;) method方法 123&lt;li v-for="n in even(numbers)"&gt; &#123;&#123;n&#125;&#125;&lt;/li&gt; 1234567891011var example = new Vue(&#123; el:'#id', data:&#123; numbers:[1,2,3,4,5] &#125;, method:function(numbers)&#123; return numbers.filter(function(number)&#123; return number%2===0 &#125;) &#125;&#125;) 利用v-for template一次渲染多个元素1234&lt;template v-for='item in items'&gt; &lt;li&gt;&#123;&#123;item.message&#125;&#125;&lt;/li&gt; &lt;li class='divider' role='presentation'&gt;&lt;/li&gt;&lt;/template&gt; v-for v-if同用如果他们位于同一个节点中，v-for比v-if有更高的优先级，也就是说v-if会在每一个循环中运行 12&lt;li v-for="item in items" v-if="item.isTrue"&gt;&lt;!-- 会渲染所有item.isTrue为真的元素 --&gt; 如果只是想有条件的跳过循环，需要将v-if放在外层元素上面 123456&lt;ul v-if="todos.length"&gt; &lt;li v-for="todo in todos"&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No todos left!&lt;/p&gt; 组件的v-for （看完组件后更新）参考资料 https://cn.vuejs.org/v2/guide/conditional.html]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode617合并二叉树]]></title>
    <url>%2F2018%2F11%2F05%2Fleetcode617%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[617 合并二叉树 Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. 解法就是用到了递归的思想，感觉还是搞不懂递归怎么用，这周多做几个递归的题目这周末整理一下 1234567891011121314151617# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def mergeTrees(self, t1, t2): if(t1==None): return t2 if(t2==None): return t1 mergeT = TreeNode(t1.val+t2.val) mergeT.left = self.mergeTrees(t1.left,t2.left) mergeT.right = self.mergeTrees(t1.right,t2.right) return mergeT 代码很简单，根据t1和t2的根节点创建新的二叉树的根节点 然后去分别合并左子树和右子树，最后返回 参考资料 https://www.youtube.com/watch?v=EmVsf2sMNiU]]></content>
      <categories>
        <category>leetcode</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode438找出同字母异序词]]></title>
    <url>%2F2018%2F11%2F02%2Fleetcode438%E6%89%BE%E5%87%BA%E5%90%8C%E5%AD%97%E6%AF%8D%E5%BC%82%E5%BA%8F%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[找出一个字符串中另一个字符串的同字母异序词 Given a string s and a non-empty string p, find all the start indices of p‘s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. 123456789Input:s: &quot;cbaebabacd&quot; p: &quot;abc&quot;Output:[0, 6]Explanation:The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;. 思路暴力 ($(o(n^2))$)能想到的就是最简单的思路，字符串转list，然后切片，排序，比较 但是超时了，先把代码贴上 但是也不知道是不是自己哪里写的不对&gt;&lt; 1234567891011121314class Solution(object): def findAnagrams(self, s, p): s=list(s) p=list(p) p.sort() result=[] for i in range(len(s)): print(i) if(s[i] in p and i+len(p)&lt;=len(s)): c = s[i:i+len(p)] c.sort() if(c == p): result.append(i) return result 他人的思路 (o(n))把p压缩成一个hash表，然后遍历s，也保存一个hash表 当s表的值的总和小于lp时继续添加，等于时判断两个hash表是否相等 要注意，遍历s时的i始终比cs快了一步，也就是i始终指向cs保存的元素的下一个元素。 例 输入 “abab” “ab” i=0 c={} i=1 c={a:1} (i指向b) i=2 c={a:1,b:1} (i指向a) 所以要在循环结束后判断结束后的cs是否和cp相等，如果相等的话还要添加一个值。 代码 12345678910111213141516171819202122232425262728293031class Solution(object): def findAnagrams(self, s, p): ls, lp = len(s), len(p) cp = dict() for i in range(lp): if(cp.has_key(p[i])): cp[p[i]] += 1 else: cp[p[i]] = 1 cs = dict(); ans = [] for i in range(ls): l = sum(cs.values()) if(l&lt;lp): if(cs.has_key(s[i])): cs[s[i]] += 1 else: cs[s[i]] = 1 else: if(cp == cs): ans.append(i-lp) cs[s[i-lp]] -= 1 if(cs[s[i-lp]] == 0): del cs[s[i-lp]] if(cs.has_key(s[i])): cs[s[i]] += 1 else: cs[s[i]] = 1 if(cs==cp): //i比hash表保存的值走的快了一步，最后一组没有进行比较 ans.append(ls-lp) return ans 参考资料 https://www.youtube.com/watch?v=86fQQ7rVGxA]]></content>
      <categories>
        <category>leetcode</category>
        <category>sliding_window</category>
        <category>hash</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode283移动零]]></title>
    <url>%2F2018%2F11%2F01%2Fleetcode283%E7%A7%BB%E5%8A%A8%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[把数组中所有的零都移动到末尾，不改变其他元素的顺序，不用新的空间，尽可能的减少操作步骤 Given an array nums, write a function to move all 0‘s to the end of it while maintaining the relative order of the non-zero elements. Example: 12Input: [0,1,0,3,12]Output: [1,3,12,0,0] Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. 思路： 交换 保存两个指针，一个指针j指向前面，另一个指针i向后遍历 当遍历到不为0的数时同前面指针所指的数据交换，然后j++ 例子： 数据 1,3,0,2,0 step1: i,j都指向1,1不为0，j++ [1,3,0,2,0] setp2:i,j都指向3，3不为0，j++ [1,3,0,2,0] step3:i,j都指向0，j不变 [1,3,0,2,0] step4:i指向2，j指向第一个0，交换，并且j++ [1,3,2,0,0] step5:i指向0，不变 得到最后结果[1,3,2,0,0] 代码 12345678910class Solution(object): def moveZeroes(self, nums): j=0 for i in range(len(nums)): if(nums[i]!=0): temp = nums[j] nums[j] = nums[i] nums[i] = temp j=j+1 print(nums) 参考资料]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mvvm]]></title>
    <url>%2F2018%2F10%2F31%2Fmvvm%2F</url>
    <content type="text"><![CDATA[软件体系结构MVVM #背景 mvc(model,view,controller)基本元素 视图：管理作为位图展示到屏幕上的图形和文字输出； 控制器：翻译用户的输入并依照用户的输入操作模型和视图； 模型：管理应用的行为和数据，响应数据请求（经常来自视图）和更新状态的指令（经常来自控制器）； 所有的通信都是单向的 View传送指令到Controller，Controller完成业务逻辑后要求Moder改变状态，Model将新的数据发送给View，用户得到反馈 依赖关系在 MVC 中，模型层可以单独工作，而视图层和控制器层都依赖与模型层中的数据。 核心问题分离展示层 GUI 应用程序由于其需要展示内容的特点，分为两个部分：一部分是用于展示内容的展示层（Presentation Layer），另一部分包含领域和数据逻辑的领域层（Domain Layer）。 MVC 最重要的目的并不是规定各个模块应该如何交互和联系，而是将原有的混乱的应用程序划分出合理的层级，把一团混乱的代码，按照展示层和领域层分成两个部分； 展示层对应MVC中的View(视图)和controller(控制器)，领域层对应模型层 主导位置控制层。在MVC中，控制层占据主导地位，他决定用户的输入时如何被处理的。 模型层。模型都是被动的，只存储整个应用中的数据，信息的获取和更新都是由控制器来驱动 实际应用的模型 MVPMVP是MVC的一个变种。 两者之间最大的区别就是 MVP 中使用 Presenter 对视图和模型进行了解耦，它们彼此都对对方一无所知，沟通都通过 Presenter 进行。 在 MVP 中，Presenter 可以理解为松散的控制器，其中包含了视图的 UI 业务逻辑，所有从视图发出的事件，都会通过代理给 Presenter 进行处理；同时，Presenter 也通过视图暴露的接口与其进行通信。 所有的通信都是双向的，View和Moder之间不发生联系，都通过Presenter来传递 被动视图在该变种的架构模式中，视图层是被动的，它本身不会改变自己的任何的状态，所有的状态都是通过 Presenter 来间接改变的。 被动的视图层就像前端中的 HTML 和 CSS 代码，只负责展示视图的结构和内容，本身不具有任何的逻辑 依赖关系视图层对于模型层没有任何的依赖 通信方式 当视图接收到来自用户的事件时，会将事件转交给 Presenter 进行处理； 被动的视图向外界暴露接口，当需要更新视图时 Presenter 通过视图暴露的接口更新视图的内容； Presenter 负责对模型进行操作和更新，在需要时取出其中存储的信息； 当模型层改变时，可以将改变的信息发送给观察者 Presenter 监督控制器 与被动视图中状态同步都需要显式的操作不同，监督控制器（Supervising Controller）就将部分需要显式同步的操作变成了隐式的 视图层接管了一部分的视图逻辑，同步简单的视图和模型的状态。 监督控制器只负责响应用户的输入以及一部分更加复杂的视图，模型状态同步工作 但是对于视图、模型的同步工作，监督控制器会尽可能地将所有简单的属性以数据绑定的形式声明在视图层中，类似于 Vue 中双向绑定的简化版本。 1&lt;a v-bind:href="url"&gt;&lt;/a&gt; 对于用户输入的处理，监督控制器的做法与标准 MVP 中的 Presenter 完全相同 通信方式监督控制器中的视图和模型层之间增加了两者之间的耦合 监管器与视图和模型之间的关系没有发生改变，增加了模型和视图之间的依赖，通过数据绑定来实现。 主导地位在MVP架构模式中，视图层在整个架构中都是占据主导地位的。 MVVMMVVM将presenter改名为ViewModel,基本上与MVP一致 唯一的区别是采用双向绑定，View的变动自动反应在ViewModel中，反之亦然。 前端开发的问题1、开发者在代码中大量调用相同的 DOM API, 处理繁琐 ，操作冗余，使得代码难以维护。 2、大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。 3、当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 View 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。 早期jquery 的出现就是为了前端能更简洁的操作DOM 而设计的，但它只解决了第一个问题，另外两个问题始终伴随着前端一直存在。 MVVM基本概念MVVM 由 Model,View,ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。 ViewModel通过双向绑定把View层和Model层连接起来，使得View和Model之间的同步工作是完全自动的。开发者只需要关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由MVVM来统一管理。 Vue.jsMVVM中的核心问题就是ViewModel和和View的双向数据绑定 Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分 而 Model 层的数据模型是只包含状态的 在ViewModel层，开发者对来自后端的数据进行二次封装。View展示的数据是来自ViewModel而不是Model。完全解耦了View和Model。 Vue.js 的双向数据绑定 Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 Observer 数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现。 Compile 指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。 Watcher 订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。 Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。 双向数据绑定的原理使用到的方法：对象的访问器属性（get,set)，事件监听（观察者模式） 极简的实现： 12345678910111213141516&lt;input type="text" id="a"&gt;&lt;span id="b"&gt;&lt;/span&gt;&lt;script&gt; var obj = &#123;&#125;;Object.defineProperty(obj,'hello',&#123; set:function(newVal)&#123; //事件绑定的回调函数 document.getElementById('a').value = newVal; document.getElementById('b').innerHTML = newVal; &#125;&#125;)document.addEventListener('keyup',function(e)&#123; //事件监听器 obj.hello = e.target.value;&#125;)&lt;/script&gt; 文本框输入文字变化，span会同步显示相同的文字内容 参考资料 https://draveness.me/mvx]]></content>
      <categories>
        <category>体系结构</category>
      </categories>
      <tags>
        <tag>体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1031Adversarial_Attacks]]></title>
    <url>%2F2018%2F10%2F31%2F1031Adversarial-Attacks%2F</url>
    <content type="text"><![CDATA[计算机视觉领域的深度神经网络攻击综述 Threat of Adversarial Attacks on Deep Learning in Computer Vision: A SurveyAbstractDeep neural networks are vulnerable to adversarial attacks in the form of subtle perturbations to inputs that lead a model to predict incorrect outputs. This article presents the first comprehensive survey on adversarial attacks on deep learning in Computer Vision. We review the works that design adversarial attacks, analyze the existence of such attacks and propose defenses against them. Introduction Review the adversarial attacks for the task of image classification and beyond. Approaches that deal with adversarial attacks in the real-world conditions. Adversarial attacksAttacks for classification 参考资料 1]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode169寻找出现次数最多的数]]></title>
    <url>%2F2018%2F10%2F31%2Fleetcode169MajorityElement%2F</url>
    <content type="text"><![CDATA[在一个长度为n的数组中，寻找出现次数大于n/2的数 169. Majority ElementGiven an array of size n, find the majority element. The majority element is the element that appears more thann/2times. You may assume that the array is non-empty and the majority element always exist in the array. 最直接的思路，用一个字典保存所有数出现的次数，当出现大于n/2的直接返回 1234567891011class Solution(object): def majorityElement(self, nums): d = dict() l = len(nums) for i in range(l): if(d.has_key(nums[i])): d[nums[i]] = d[nums[i]]+1 else: d[nums[i]] = 0 if(d[nums[i]]&gt;=l/2): return nums[i] 看到别人的思路，把数组排序，中间的值一定是出现次数大于等于2的值 1234class Solution(object): def majorityElement(self, nums): nums.sort() return nums[len(nums)/2]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode160寻找链表交叉点]]></title>
    <url>%2F2018%2F10%2F30%2Fleetcode160%E5%AF%BB%E6%89%BE%E9%93%BE%E8%A1%A8%E4%BA%A4%E5%8F%89%E7%82%B9%2F</url>
    <content type="text"><![CDATA[160寻找链表交叉点 题目： Intersection of Two Linked Lists寻找两个链表相交的节点 提示： If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. 思路如果两个链表有交点，那么从交点开始算起他们的长度一定是相等的。 先得到两个链表的长度，然后把长的那个链表的前半部分截去（如果有交点一定不可能发生在长的这一段） 然后再一起遍历，如果有相同的节点则相交，否则没有 代码123456789101112131415161718192021222324252627282930313233343536# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def getIntersectionNode(self, headA, headB): a = headA b = headB alen=0 blen=0 while(a!=None): alen=alen+1 a=a.next while(b!=None): blen=blen+1 b=b.next print(alen,blen) a = headA b = headB if(alen&gt;blen): i=0 while(i&lt;alen-blen): a = a.next i=i+1 print(i) elif(blen&gt;alen): j=0 while(j&lt;blen-alen): b = b.next j=j+1 print(j) while a != b: a, b = a.next, b.next return a]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask前后端数据传递]]></title>
    <url>%2F2018%2F10%2F29%2Fflask%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[flask前后端数据传递的问题 基础知识POST GET AJAX前端传送和接收123456789$.ajax(&#123; url: &quot;/new&quot;, //对应flask中的路由 type: &quot;POST&quot;, //请求方法 data: &apos;hello&apos;, //传送的数据 dataType: &quot;json&quot;, //传送的数据类型 success: function (data) &#123; //成功得到返回数据后回调的函数 console.log(data) &#125; &#125;) Flask后端接收处理和返回123456@app.route(&apos;/new&apos;,methods=[&apos;POST&apos;]) //第一个参数是路由，第二个是请求方法def new(): recv_data = request.get_data() //得到前端传送的数据 print(recv_data) data = somefunction() //对数据做某些处理 return data //返回数据]]></content>
      <categories>
        <category>Flask</category>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据转换]]></title>
    <url>%2F2018%2F10%2F29%2Fpython%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[简单介绍了python中的数据转换问题 强制类型转换int 函数 把符合数学格式的数字型字符串转换成整数 把浮点数转换成整数，但是只是简单的取整，而非四舍五入。float函数将整数和字符串转换为浮点数str 函数将数字转换为字符list 和 tupletuple转list list(tup)list转tuple tuple(list)String转list简单转换 list函数list(str)将字符串中的每一个字母作为列表中的一个元素，空格也算一个元素123hi = &quot;hi world&quot;list(hi)[&apos;h&apos;,&apos;i&apos;,&apos; &apos;,&apos;w&apos;,&apos;o&apos;,&apos;r,&apos;,&apos;l&apos;,&apos;d&apos;] 指定分隔符split123s = &quot;hello,world&quot;slist = s.split(&quot;,&quot;)//[&apos;hello&apos;,&apos;world&apos;]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据转换]]></title>
    <url>%2F2018%2F10%2F29%2Fjs%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[最近第一次写前后端数据的互传，遇到了很多数据类型的转换，每次都记不住然后再查，先总结一下JS的转换问题，Python的转换问题后面补上 查看数据类型 typeof()JS中一共有5种简单的数据类型：Undifined,Null,Boolean,Number,String其他引用类型：Object(Array,Date,RegExp,Function)123typeof //在js中用于检查数据类型var message = &apos;hello world&apos;;console.log(typeof(message)); 字符串 转数字 转数组 其他类型转字符串 parseInt(str) 转整数 str.split(“,”) toString() parseFloat(str) 转浮点数 数组数组转字符串 arr.join(“ “)1arr.join(&quot;-&quot;) //引号内是分隔符]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML笔记]]></title>
    <url>%2F2018%2F10%2F29%2FHTML%2F</url>
    <content type="text"><![CDATA[很少的一些html中的笔记 文本标签\&lt;p/>p标签内的文字自动换行设置: 123word-break:normal;white-space:pre-warp;word-wrapL:break-word; word-break属性： 在恰当的断字点进行换行。有三个值：normal(使用浏览器默认的换行规则)、break-all(允许单词内换行)、keep-all(只能在半角空格或连字符处换行) white-space属性： white-space属性设置如何处理元素内的空白。 这个属性声明建立布局中如何处理元素中的空白字符，有六个值：normal(默认。空白会被忽略)、pre(空白会被浏览器保留。其行为方式类似HTML代码中的标签)、 nowrap（文本不会换行，文本会在同一行上继续，直到遇到标签为止）、pre-wrap（保留空白符序列，但是正常的换行）、pre-line（合并空白符序列，但是保留空白 符）、inherit（规定应该从父元素继承white-space属性的值）; word-wrap属性： 允许长单词换行到下一行；有两个值：normal（只允许在断字点换行）、break-word(在长单词或者URL地址内部进行换行)]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS笔记]]></title>
    <url>%2F2018%2F10%2F29%2FJS%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[全部都是看红宝书时候记得笔记，十分杂乱 第六章 面向对象的程序设计6.1 对象6.1.1 理解对象无序属性的集合，其属性可以包含基本值，对象或者函数 两种创建方法： 12345678/*第一种 创建Object实例*/var person = new Object();person.name = &quot;Tom&quot;;person.age = 29;person.sayName = function()&#123; alert(person.name);&#125;; 12345678910/* 第二种 对象字面量*/var person = &#123; name:&quot;Tom&quot;, age:29, sayName:function()&#123; alert(this.name); &#125;&#125;; 对象的属性类型 数据属性 数据属性可以读取或者写入值，有四个可以描述属性行为的特性： [[configurable]][[Enumerable]][[Writable]][[Value]] 访问器属性 不包含数据值，包含一对getter和setter函数 读取属性调用getter函数，写入属性调用setter函数 访问器属性不能直接定义，必须使用Object.defineProperty()来定义。 12345678910111213141516171819var book = &#123; _year:2004, edition:1&#125;;Object.defineProperty(book,&quot;year&quot;,&#123; get:function()&#123; return this._year; &#125; set:function(newValue)&#123; if(newValue&gt;2004)&#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); //2 6.1.2 创建对象 工厂模式 用函数来封装以特定接口创建对象的细节 优点：抽象了具体过程缺点：无法识别对象的类型 123456789function createPerson(name,age,job)&#123; var o = new Object; o.name = name; o.job = job; o.sayName = function()&#123; alert(o.name); &#125;; return o;&#125; 构造函数模式 创建自定义的构造函数，从而定义自定义对象类型的属性和方法 优点：可以识别对象的类型 缺点:每个方法都要在每个实例上重新创建一遍 1234567891011function Person(name,age)&#123; this.name = name; this.age = age; this.sayName = function()&#123; alert(this.name); &#125;&#125;var person = new Person(Tom,29)alert(person instanceof Person) //true 解释构造函数： 同其他函数的唯一区别：调用方式不同 任何函数通过new操作符来调用都可以作为构造函数 123456789101112131415161718var person = new Person(&quot;Tom&quot;,29)person.sayName(); //Tom// 全局作用域中调用函数,this对象总指向global对象（在浏览器中就是window对象）Person(&quot;Ford&quot;,29)window.sayName();//Ford// 在另一个对象的作用域中调用 o和前面的person的属性是相同的var o = new Object();Person.call(o,&quot;Jack&quot;,29);o.sayName(); //Jack// o和person虽然有相同的属性，但是对象类型不同alert(o instanceof Person); //falsealert(person instanceof Person); //true//想要尝试修改o的构造函数，这是错误的。因为构造函数是由原型指定的，如果试图修改o的原型也就是Object的原型，会导致所有的对象发生错误，因此js不允许做这样的修改。 2. 原型模型 每一个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，这个对象包含可以由特性类型的所有实例共享的属性和方法。 prototype指向通过构造函数创建的对象实例的原型对象。 优点：所有对象实例都可以共享它所包含的属性和方法 缺点： 忽略了构造函数传参，所有实例共享相同的默认值 对于引用值属性，修改一个实例所有实例都将被修改 12345678910111213function Person()&#123; person.prototype.name = &quot;Tom&quot;; person.prototype.age = 29; person.prototype.sayName=function()&#123; alert(this.name); &#125;&#125;var person1 = new Person();person.sayName();//Tomvar person2 = new Person();alert(person1.sayName == person2.sayName) //true 理解原型对象 创建新函数就会根据一组特定的规则为该函数创建一个prototype属性，指向函数的原型对象。 函数的原型对象中有一个constructor属性，指向创建的自定义函数。 构造函数的实例中也有一个prototype属性，指向函数的原型对象。 关系如图所示: 注意：可以通过对象实例来访问保存在原型中的值，但是不能通过对象实例重写原型中的值。 如果在实例中添加一个跟原型对象中同名的属性值，那么该属性值会屏蔽掉原型中的属性。 123person1.name = &quot;Jack&quot;;person1.sayName();//Jack 屏蔽掉了原型中的值person2.sayName();//Tom 原型中的值 原型的动态性 对原型所做的任何修改都可以在实例上体现出来因为实例和原型的连接是一个指针,实例可以通过该指针在原型中找到新的属性。 1234567891011function Person()&#123; &#125;var person = new Person();Person.prototype.sayName=function()&#123; alert(&quot;Tom&quot;);&#125;person.sayName();//Tom 但是如果重写整个prototype对象，则相当于切断了实例与原型对象的联系，因为实例仍然指向最初的原型对象 12345678910111213141516function Person()&#123; Person.prototype.name=&quot;tom&quot;;&#125;var person = new Person();Person.prototype = &#123; sayHello : function()&#123; console.log(&quot;Hello&quot;); &#125;&#125;//person只能访问到旧原型中的属性，重写的原型无法访问console.log(person.name); //tomperson.sayHello(); //error 3. 组合使用构造函数模式和原型模式 构造函数模式用于定义不共享的实例属性，原型模式用于定义方法和共享的属性。 优点： 每个实例都会有自己的一份实力属性的副本，同时又共享者对方法的引用，节省了内存。 1234567891011121314151617181920212223function Person(name,age)&#123; this.name = name; this.age = age; this.friends = [&quot;Shelby&quot;,&quot;Court&quot;] &#125;Person.prototype = &#123; constructor:Person, sayName:function()&#123; console.log(this.name); &#125;&#125;;var person1 = new Person(&quot;Tom&quot;,29);var person2 = new Person(&quot;Jack&quot;,29);//对一个实例的引用属性的修改不会影响其他实例person1.friends.push(&quot;Mary&quot;);console.log(person1.friends); //[&quot;Shelby&quot;,&quot;Court&quot;,&quot;Mary&quot;]console.log(person2.friends);//[&quot;Shelby&quot;,&quot;Court&quot;]//共享方法console.log(person1.sayName==person2.sayName) //true 6.2 继承ECMAScript只支持实现继承，依靠原型链来实现 6.2.1 原型链继承基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。 实现的本质：用一个新类型的实例来重写并且代替原型对象。 缺点： 如果作为子类型原型对象的超类型实例中有引用类型，那么修改某一个对象的引用类型时所有对象的引用类型都将被修改。 创建子类型的实例时，不能像超类型的构造函数传参。 123456789101112131415161718192021222324252627function SuperType()&#123; this.property = true; this.color = [&quot;red&quot;];&#125;SuperType.prototype.getSuperValue=function()&#123; return this.property;&#125;function subType()&#123; this.subProperty = false;&#125;subType.prototype = new SuperType();subType.prototype.getSubValue = function()&#123; return this.subProperty;&#125;var instance1 = new subType();var instance2 = new subType();console.log(instance1.getSuperValue); //true//缺点：修改1的color,2的color也会改变instance1.color.push(&quot;black&quot;);console.log(instance1.color);//[&quot;red&quot;,&quot;black&quot;]console.log(instance2.color);//[&quot;red&quot;,&quot;black&quot;] 注意：使用原型链继承时不能用对象字面量来创建原型方法，这样会重写原型链，切断与超类的联系。 6.2.2 借用构造函数基本思想:在子类型构造函数的内部调用超类型构造函数。 优点：解决了原型中包含引用类型值带来的问题缺点: 无法实现函数复用 12345678910111213141516171819202122232425262728function SuperType(name)&#123; this.property = true; this.name=name; this.color = [&quot;red&quot;];&#125;SuperType.prototype.getSuperValue = function()&#123; return this.property;&#125;function SubType()&#123; this.subProperty = false; //可以传参 SuperType.call(this,&quot;Tom&quot;);&#125;var instance1 = new SubType();var instance2 = new SubType();instance1.color.push(&quot;black&quot;);console.log(instance1.color); //[&quot;red&quot;,&quot;black&quot;]console.log(instance2.color); //[&quot;red&quot;]//只继承了构造函数中的属性和方法，没有继承原型中的方法console.log(instance1.getSuperValue()) //errorconsole.log(instance1 instanceof SuperType)//false 6.2.3组合继承基本思路：原型链实现对原型属性和方法的继承构造函数实现对实力属性的继承。 优点:实现了函数复用，又保证每个实例都有自己的属性 缺点:创建子类型时，会调用两次超类型的构造函数 1234567891011121314151617181920212223242526272829function SuperType(name)&#123; this.name = name; this.color=[&quot;red&quot;];&#125;SuperType.prototype=&#123; sayName:function()&#123; return this.name; &#125;&#125;;function SubType(name,age)&#123; SuperType.call(this,name); this.age = age;&#125;SubType.prototype = new SuperType();SubType.prototype.constructor = SubType();var instance1 = new SubType(&quot;Tom&quot;,&quot;29&quot;);var instance2 = new SubType(&quot;Jack&quot;,&quot;21&quot;);//修改引用类型属性不会影响其他实例instance1.color.push(&quot;black&quot;); console.log(instance1.color,instance2.color);//[&quot;red&quot;,&quot;black&quot;],[&quot;red&quot;]// 继承了超类型的原型方法,并且实现了复用console.log(instance1.sayName()); //Tomconsole.log(instance1.sayName==instance2.sayName); //True 6.2.4 原型式继承想法：不必创建自定义类型，借助原型可以基于已有的对象创建新对象。 给出如下函数：12345678910111213function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;//本质是 object()对传入的对象执行了一次浅复制var person()&#123; name:&quot;Tom&quot;, friends:[&quot;Jack&quot;]&#125;;var anotherPerson = object(person); 在ECMAsript 5新增了Object.create()方法来规范原型式继承。接受两个参数（第二个可选):第一个参数是作为新对象原型的对象，第二个是为新对象额外定义属性的对象。 123456789var person = &#123; name:&quot;Tom&quot;, frineds:[&quot;Jack&quot;]&#125;;var anotherPerson = Object.create(person,&#123;name&#123; value:&quot;Jack&quot;&#125;&#125;); 使用场景：只想让一个对象与另一个对象保持类似的情况，没必要创建构造函数。 6.3.5 寄生式继承思想:创建一个仅用于封装继承过程的函数，该函数内部以某种方式来增强对象，然后再返回对象。 缺点： 代码示范: 123456789function createAnother(original)&#123; var clone = Object.create(original); clone.sayHi = function()&#123; alert(&quot;HI&quot;); &#125; return clone;&#125;//不一定是Object.create 任何可以返回同original相同的新对象的函数都可以 6.3.6 寄生组合式继承(最理想)解决了组合式继承调用两次超类型构造函数的问题 基本模式如下： 123456789101112131415161718192021222324252627282930313233function inheritPrototype(SubType,SuperType)&#123; var prototype = Object.create(SuperType.prototype); prototype.constructor = SubType; SubType.prototype = prototype;&#125;//修改前面组合继承的例子function SuperType(name)&#123; this.name = name; this.colors = [&quot;Red&quot;];&#125;SuperType.prototype = &#123; sayName:function()&#123; return this.name; &#125;&#125;;function SubType(name,age)&#123; SuperType.call(this,name); this.age = age;&#125;inheritPrototype(SubType,SuperType);var subtype =new SubType(&quot;Tom&quot;,21)//成功继承超类型原型对象中的方法console.log(subtype.sayName());//Tom 第七章 函数第八章 迭代器和生成器 ES68.1 迭代器&amp;&amp;生成器迭代器是一种特殊对象，具有一些专门为迭代过程设计的专有接口。 next() 每次调用返回一个结果对象{value,done} value表示下一个将要返回的值，done在没有更多数据返回时为true。 一个内部指针 用来指向当前集合中值的位置 生成器生成器是一种返回迭代器的函数，通过function关键字后的星号（*）来表示，会用到新的关键字yield。 12345678910function *createIterator()&#123; yield 1; yield 2; yield 3;&#125;let iterator = createIterator();console.log(iterator.next().value); //1console.log(iterator.next().value); //2console.log(iterator.next().value); //3 在上述示例中，createIterator()前面的星号表明他是一个生成器，yield可以用来指定调用迭代器的next方法时返回值及返回顺序。 每当执行完一条yield语句后函数就会自动停止执行，直到再次调用迭代器的next()方法才会继续执行。 yield只能在生成器内部使用，在其他地方使用会导致程序抛出错误，生成器内部的函数也不行。 其他创建方式 函数表达式 let createIterator = function *(items){} 生成器对象 let o ={ *createIterator(item){}} let iterator = o.createIterator([1,2,3]); 8.2 可迭代对象和for-of循环可迭代对象具有symbol.iterator属性，是一种与迭代器密切相关的对象。 symbol.iterator通过指定的函数可以返回一个作用于附属对象的迭代器。 for-of循环每执行一次都会调用可迭代对象的next()方法，并将迭代器返回的结果对象的value属性存储在一个变量中，循环将持续执行这一过程直到返回对象的done属性的值为true。 12345let values = [1,2,3];for(let num of values)&#123; console.log(num);&#125;//依次输出1，2，3 如果只需迭代数组或者集合中的值，用for-of循环代替for循环是个不错的选择。 访问默认迭代器12let values = [1,2,3];let iterator = values[Symbol.iterator](); 由于具有symbol.iterator属性的对象都有默认的迭代器，因此可以用他来检测对象是否为可迭代对象 123function isIterable(object)&#123; return typeof object[Symbol.iterator] == "function";&#125; 创建可迭代对象默认情况下，开发者定义的对象都是不可迭代对象，但可以通过给Symbol.iterator属性添加一个生成器，则可以将其变为可迭代对象 12345678910111213let collection = &#123; items:[1,2,3], *[Symbol.iterator]()&#123; for(let item of this.items)&#123; yield item; &#125; &#125;&#125;;for(let x of collection)&#123; console.log(x);&#125;//1,2,3 8.3 内建迭代器集合对象迭代器ES6中有三种类型的集合对象：数组，Map集合，Set集合 这三种对象都内建了三种迭代器： entries() 返回一个迭代器，其值为多个键值对。 values() 返回一个迭代器，其值为集合的值。 keys() 返回一个迭代器，其值为集合中的所有键名 entries()迭代器每次调用next方法，entries()迭代器都会返回一个数组，数组中的两个元素分别表示每个元素的键和值。 数组：第一个元素是数字类型的索引，第二哥元素是数组值 set集合：第一个和第二个元素都是值 map集合，第一个元素为键名，第二个元素为键值。 123456789101112131415161718let color = ["red","green","blue"];let tracking = new Set([1234,5678,9012]);let data = new Map();data.set("title","ES6");data.set("format","ebook");for(let entry of color.entries())&#123; console.log(entrt); //[0,"red"] [1,"green"] [2,"blue"]&#125;for(let entry of tracking.entried())&#123; console.log(entrt); //[1234,1234] [5678,5678] [9012,9012]&#125;for(let entry of data.entried())&#123; console.log(entry); //["title","ES6"] ["format","ebook"]&#125; values()迭代器调用value()迭代器会返回集合中所存的所有值 123456789101112131415161718let color = ["red","green","blue"];let tracking = new Set([1234,5678,9012]);let data = new Map();data.set("title","ES6");data.set("format","ebook");for(let value of color.values())&#123; console.log(value); //"red" "green" "blue"&#125;for(let value of tracking.values())&#123; console.log(value); //1234 5678 9012&#125;for(let value of data.values())&#123; console.log(value); //"ES6" "ebook"&#125; keys迭代器keys迭代器会返回集合中存在的每一个键 数组：返回数字类型的键，数组本身的其他属性不会被返回 set集合：键与值相同，返回和values相同的迭代器 map集合：返回每个独立的键 123456789101112131415161718let color = ["red","green","blue"];let tracking = new Set([1234,5678,9012]);let data = new Map();data.set("title","ES6");data.set("format","ebook");for(key of colors.keys())&#123; console.log(key); //0 1 2&#125;for(key of tracking.keys())&#123; console.log(key); //1234,5678,9012&#125;for(key of data.keys())&#123; console.log(key); //"title" "format"&#125; 不同集合类型的默认迭代器每个集合类型都有一个默认的迭代器，在for-of循环中，如果没有显示指定则使用默认的迭代器。 数组和set组合的默认迭代器是values()方法，Map集合的默认迭代器是entries()方法。 123456789101112131415161718192021222324let color = ["red","green","blue"];let tracking = new Set([1234,5678,9012]);let data = new Map();data.set("title","ES6");data.set("format","ebook");for(let value of color)&#123; console.log(value); //"red" "green" "blue"&#125;for(let value of tracking)&#123; console.log(value); //1234 5678 9012&#125;for(let entry of data)&#123; console.log(entry); //["title","ES6] ["format","ebook"]&#125;//解构语法使map访问更简单for(let [value,key] of data)&#123; console.log(value+","+key) //"title,ES6" "format,ebook"&#125; 字符串迭代器解决双字节字符问题 12345678910var message = "A 𠮷 B";for (let c of message)&#123; console.log(c);&#125;//A//(空)//𠮷//(空)//B NodeList迭代器12345var divs = document.getElementsByTagName("div");for(let div of divs)&#123; console.log(div.id);&#125; 展开运算符与非数组可迭代对象展开运算符可以操作所有可迭代对象，并根据默认迭代器来选取要引用的值，从迭代器读取所有值，然后按照返回顺序将他们依次插入到数组中。 12345678910111213141516let set = new Set([1,2,3,3,3,4,5]), array = [...Set];console.log(array); //[1,2,3,4,5]let map = new Map([["name","Nicholas"],["ages",25]]), array = [...map];console.log(array); //[["name","Nicholas"],["ages",25]]//在数组字面量中可以多次使用展开运算符，将可迭代对象中的多个元素依次插入新数组中，替换原来展开运算符所在的位置let smallNumber = [1,2,3], bigNumber = [100,101,102], allNumber = [0,...smallNumber,...bigNumber];console.log(allNumber.length); //7console.log(allNumber); //[0,1,2,3,100,101,102] 将可迭代对象转换为数组，最简单的方法就是使用展开运算符。可以将字符串中的每一个字符存入新数组中，可以刻将nodeList对象中的每一个节点存入新数组中。 8.4 高级迭代器功能给迭代器传递参数如果给迭代器的next()方法传递参数，则这个参数的值就会替代生成器内部上一条yield语句的返回值。 123456789101112function *createIterator()&#123; let first = yield 1; let second = yield first + 2; //4+2 yield second+3; //5+3&#125;let iterator = createIterator();console.log(iterator.next()); //&#123;value:1,done:false&#125;console.log(iterator.next(4)); //&#123;value:6,done:false&#125;console.log(iterator.next(5)); //&#123;value:8,done:false&#125;console.log(iterator.next()); //&#123;value:undefined,done:true&#125; 生成器返回语句生成器也是函数，因此可以通过return语句提前退出函数执行。 在生成器中，return表示所有操作已经完成，属性done被设置为true 12345678910function *createIterator()&#123; yield 1; return 42; yield 2; yield 3;&#125;let iterator = createIterator();console.log(iterator.next()); //&#123;value:1,done:false&#125;console.log(iterator.next()); //&#123;value:42,done:true&#125; 展开运算符与for-of循环语句会直接忽略通过return语句指定的任何返回值，因为只要done一变成true就立即停止读取其他的值。 委托生成器将两个迭代器合二为一，创建一个生成器，再给yield语句添加星号，就可以将生成数据的过程委托给其他迭代器 123456789101112131415161718192021function *createNumberItetator()&#123; yield 1; yield 2;&#125;function *createColorIterator()&#123; yield "red"; yield "green";&#125;function *createCombinedIterator()&#123; yield *createNumberIterator(); yield *createColorIterator(); yield true;&#125;var iterator = createCombinedIterator();console.log(iterator.next()) //&#123;value:1,done:false&#125;console.log(iterator.next()) //&#123;value:2,done:false&#125;console.log(iterator.next()) //&#123;value:"red",done:false&#125;console.log(iterator.next()) //&#123;value:"green",done:false&#125;console.log(iterator.next()) //&#123;value:true,done:false&#125; 每一次调用next方法就会委托相应的迭代器生成相应的值，直到迭代器无法返回更多的值，此时执行最后一条yield语句并返回true。 8.5 异步任务执行8.5.1 简单任务执行器yield语句会暂停当前函数的执行过程并等待下一次调用next()方法。因此可以创建一个函数，在函数中调用生成器生成相应的迭代器，从而可以不用回调函数实现异步调用next()。 123456789101112131415161718192021222324function run(taskDef)&#123; let task = taskDef(); let result = task.next(); //循环调用next()的函数 function step()&#123; //如果任务未完成则继续执行 if(!result.done)&#123; result = task.next(); step(); &#125; &#125; step();&#125;run(function *()&#123; console.log(1); yield; console.log(2); yield; console.log(3); yield;&#125;)// 1 2 3 8.5.2 像任务执行器传递数据传递数据最简单的方法是，把yield返回的值传入下一次next()方法的调用 123456789//上述代码中修改传入的生成器函数run(function *()&#123; let value = yield 1; console.log(yield); //1 value = yield value+3; console.log(value); //4&#125;) 8.5.3 异步任务执行器等待异步过程时，任务执行器需要知晓回调函数是什么以及如何使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 function fetchData() &#123; //返回一个异步函数 return function (callback) &#123; setTimeout(() =&gt; &#123; callback(null, "Hello"); &#125;, 1000); &#125;; &#125; function run(taskDef) &#123; let task = taskDef(); let result = task.next(); function step() &#123; if (!result.done) &#123; //如果result.value是一个函数，则传入一个回调函数作为参数来调用 if (typeof result.value === "function") &#123; result.value(function (err, data) &#123; if (err) &#123; result = task.throw(err); return; &#125; result = task.next(data); step(); &#125;) //如果不是函数则直接把值传入next方法 &#125; else &#123; result = task.next(result.value); step(); &#125; &#125; &#125; step(); &#125; run(function *() &#123; value = yield fetchData(); console.log(value); console.log("world"); &#125;);//输出 一秒钟后连续输出hello world//也可以和循环配合，循环输出 run(function *() &#123; for(let i=0;i&lt;5;i++)&#123; yield fetchData("hello"+i); &#125; &#125;); 第十章 DOMDOM(文档对象模型)是针对HTML和XML文档的一个API（应用程序编程接口） 10.1 节点层次DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构 10.1.1 Node类型每个节点都有一个nodeType属性，用于表明节点的类型 nodeName和nodeValue属性这两个属性的值完全取决于节点的类型 节点关系节点间的各种关系可以用传统的家族关系来描述：在html中，可以将body看成是html的子元素，html是body的父元素；body是head的同胞元素。 每个节点都有一个childNodes属性，其中保存着一个NodeList对象（NodeList是一个类数组对象，并不是Array的实例，独特之处在于他是基于DOM结构动态执行查询的结果，能够自动反应DOM结构的变化） 访问方式： 123var firstChild = someNode.childNodes[0];var secondChild = someNode.childNodes.item(1);var count = someNode.childNodes.length;//表示的是访问这一刻NodeList包含的节点数量 可以通过Aarray.prototype.slice()方法将NodeList转化为数组（IE8以下不支持) 1234567891011function covertToArray(nodes)&#123; var array = null; try&#123; array = Array.prototype.slice.call(nodes); &#125;catch(ex)&#123; array = new Array(); for(var i=0;i&lt;nodes.length;i++)&#123; array.push(nodes[i]); &#125; &#125;&#125; 每个节点都有一个parent属性，指向文档树中的父节点 包含在childerNodes列表中的每个节点之间都是同袍节点，可以用previousSibling和nextSlibing来访问邻近的节点。 父节点的firstChild和lastChild属性分别指向childNodes列表中的第一个和最后一个子节点 hasChildNodes() 这个方法在包含一个或多个子节点的情况下返回true ownerDocument属性指向表示整个文档的文档节点，可以不用层层回溯直接访问文档节点 操作节点 appendChild() 向childNodes列表的末尾添加一个节点，返回值是新增的节点 参数：要添加的节点 返回：添加的新节点 注意：任何DOM节点不能同时出现在文档的多个位置 12345678var returnedNode = someNode.appendChild(newNode);alert(returnedNode == newNode); //truealert(someNode.lastChild == newNode); //true//如果appendChild()传入了父节点的第一个节点，那么这个节点就会成为父节点的最后一个节点var resurnedNode = someNode.appendChild(someNode.firstChild);alert(returnedNode == someNode.firstChild); //falsealert(returnedNode == someNode.lastChild); //true insertBefore() 把节点放入childNodes列表中某个特定的位置上 参数:要插入的节点，参照节点 返回：要插入的节点 插入节点后，要插入的节点会成为参照节点的previousSibling 123//插入后成为第一个节点returnedNode = someNode.insertBefore(node,someNode.firstNode);alert(returnedNode == someNode.firstNode) //true replaceChild 替换节点 参数：要插入的节点，被替换的节点 返回：被替换的节点 要替换的节点被从文档树中移除，被要插入的节点替换 12//替换第一个节点returnedNode = someNode.replaceChild(newNode,someNode.firstChild); removeChild 移除节点 参数：要移除的节点 返回：被移除的节点 12//移除最后一个节点returnedNode = someNode.removeChild(someNode.lastChild) 一些其他方法 cloneNode 创建调用这个方法的节点的一个完全相同的副本 参数：一个布尔值参数 true:执行深复制，复制节点及其整个子节点树 false:执行浅复制，只复制节点本身 返回：复制好的副本 注意：这个方法不会复制添加到DOM节点的js属性，如时间处理程序等 1234567891011121314&lt;ul&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;li&gt;item 3&lt;/li&gt;&lt;/ul&gt;&lt;!--假设已经将ul元素的引用保存在了变量myList中--&gt;&lt;script&gt; var deepList = myList.cloneNode(true); alert(deepList.childNodes.length); //3 var shallowList = myList.cloneNode(false); alert(shallowList.childNodes.length); //0&lt;/script&gt; normalize() 处理文档树中的文本节点（后面补充） 10.1.2 Document类型JS通过Document类型表示文档。 document对象是HTMLDocument的一个实例，表示整个HTML界面。 document对象是window对象的一个属性，可以作为全局对象来访问 Document节点具有以下特征： nodeType的值为9 nodeName的值为”#document“ nodeValue的值为null parentNode的值为null owenerDocument的值为null document的子节点 documentElement 属性 始终指向html页面中的html元素 document的documentElement属性，firstChild属性，以及childNodes[0]都指向html body 属性 指向body元素 doctype 属性 指向&lt;!DOCTYPE&gt;标签 document的属性 title属性：包含着元素中的文本 可以获得当前页面的标题，也可以修改 12var originalTitle = document.title;document.title = "New page title"; URL domain referrer URL:保存页面完整的URL domain:只包含页面的域名 referrer:链接到当前页面的页面的URL（没有来源页面的情况下，可能包含空字符串） 查找元素 document.getElementById() 参数：要取得的元素的ID 返回：返回要取得的元素，如果没有该元素则返回NULL document.getElementsByTagName() 参数：要取得元素的标签名 返回：HTML文档中返回一个HTMLCollection对象，对象中的元素数量可以通过length属性取得 1234567891011var images = ducoment.getElementsByTagName("img");alert(images.length);alert(images[0].src);alert(images.item(0).src);// HTMLCollection对象方法:namedItem() 可以通过name特性取得集合中的项//假设页面中包含如下img元素&lt;img src="myImage.gif" name="myImage"&gt; var myImage = images.namedItem("myImage");var myImage = images[myImage] //也支持按名称访问 getElementsByName() 参数：name值 返回：带有给定name特性的所有元素 特殊集合 document对象还有一些特殊的集合，这些特殊的集合都是HTMLCollection对象，为访问文档常用的部分提供了快捷方式 document.anchors 包含文档中所有带name特性的元素 document.forms 包含文档中所有的form元素 document.images 包含文档中所有的Image元素 document.links 包含文档中所有带href的a元素 一致性检测文档写入10.1.3 Element类型Element类型用于表现XML或HTML元素，提供了对元素标签名，子节点以及特性的访问。 具有以下特性： nodeType的值为1 nodeName的值为元素的标签名 nodeValue的值为null parentNode可能是Document或Element 其子节点可能是Element,Text,Comment,ProcessingInstruction,CDATASection或EntityReference nodeName和tagName都会返回元素的标签名 HTML元素所有的HTML元素都由HTMLElement类型的子类型来表示。该类型直接继承Element并添加了一下属性。 添加的这些属性分别对应于每个HTML元素中都存在的标准特性： id 元素在文档中的唯一标识符 title 有关元素的附加信息 lang 元素内容的语言代码 dir 语言的方向（ltr rtl) className 对应元素的class属性 取得特性操作特性的三个主要方法:getAttribute()、setAttribute()、removeAttribute() 这三个方法可以针对任何特性使用，包括自定义特性。 取得特性是：getAttribute() 参数：特性名称（id,class,title,lang或自定义特性） 返回：特性值 有两类特殊的特性，属性的值与通过getAttribute返回的值不相同：style,onclick 设置特性&amp;&amp;删除特性setAttribute() 参数：要设置的特性名，特性值 如果特性已经存在会用特性值替换已有的值，如果不存在就创建特性并设定相应的值 所有的特性都是属性，也可以直接给属性赋值 123456div.id = "someOtherId"div.align = "left"//但是通过赋值添加新的自定义属性,属性不会成为元素的特性div.mycolor = "red"alert(div.getAttribute("mycolor")) //null removeAttribute() 不仅会清除特性的值，也会从元素中完全删除特性。 arrtibute属性Element类型是使用attribute属性的唯一一个DOM节点类型。 attribute属性中包含一个NameNodeMap,与NodeList类似，也是一个动态的集合。元素中的每一个特性都由一个Arrt节点表示，每个节点的nodeName就是特性的名称，而节点的nodeValue就是特性的值。每个节点都保存在NameNodeMap对象中。该对象拥有下列方法： getNamedItem(name):返回nodeName属性等于name的节点 removeNamedItem(name):从列表中移除nodeName属性等于name的节点 setNamedItem(node):像列表中添加节点，以节点的nodeName属性为索引 item(pos)：返回位于数字pos位置的节点 取得元素的id特性： 12var id = element.attributes.getNamedItem("id").nodeValue;var id =element.attributes["id"].nodeValue; 给id特性设置新值： 1element.attributes["id"].nodeValue = "someOtherId"; 删除特性 调用removeNamedItem()和在元素上调用removeAttribute()的效果相同，直接删除具有给定名称的特性。 但是removeNamedItem()会返回表示被删除特性的Attr节点。 一般来说，操作element特性时更多的使用getAttribute(),removeAttribute(),setAttribute()这三个方法 但是遍历元素特性时，attributes属性就会比较有用 123for(i=0,ien = element.attributes.length;i&lt;len;i++)&#123; &#125; 创建元素方法：document.createElement() 参数：要创建元素的标签名 123456789//创建一个div元素var div = document.createElement("div");//可以操作新创建的元素，为他添加更多的子节点div.id = "myNewDiv";div.className = "box";//在新元素上设置特性只是赋予相应的信息，还未添加到文档树中，要显示在浏览器中，必须要添加到文档树中document.body.appendChild(div);//或者使用insertBefore,replaceChild 元素的子节点元素可以有任意数目的子节点和后代节点，因为元素可以是其他元素的子节点。 元素的childNodes属性包含了它的所有子节点，这些子节点有可能是元素，文本节点，注释或者处理指令。 不同的浏览器看待节点方面存在着显著的不同。 12345&lt;ul id="myList"&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;/ul&gt; 上述代码在IE中，元素会有3个子节点，分别是3个元素。 在其他浏览器中，元素有7个子节点，分别是3个元素，以及和之间的2个空白符,之间的2个空白符。 所以如果需要在元素类型的子节点上进行某些操作，要先检查一下nodeType属性 12345for(var i=0,len = element.childrenNodes.length;i&lt;len;i++)&#123; if(element.childrenNodes[i].nodeType == 1)&#123; //需要执行的操作 &#125;&#125; 也可以通过特定的标签名来取得子节点或者后代节点，使用getElementsByTagName() 除了搜索节点是当前元素外，其他都跟通过document调用相同。因此也会只返回符合条件的当前元素的后代。 123//取得ul元素包含的所有li元素var ul = document.getElementById("myList");var li = ul.getElementsByTagName("li"); 10.1.4 Text类型包含可以按照字面解释的纯文本内容，可以包含转义后的HTML字符，但是不能包含HTML代码 text节点具有以下特征： nodeType的值为3 nodeName的值为”#text“ nodeValue的值为节点所包含的文本 parentNode是一个Element 不支持没有子节点 nodeValue和data属性都可以访问文本节点中的文本 节点操作方法 appendValue(text):将text添加到节点末尾 deleteDate(offset,count) ：从offset指定的位置开始删除count个字符 insertData(offset,text)：在offset指定的位置插入text replaceData(offset,count,text)：用text替换从offset指定的位置开始到offset+count为止处的文本 splitText(offset)：从offset指定的位置将当前文本分成两个文本节点 substringData(offset,count)：提取从offset指定的位置开始到offset+count为止处的字符串 文本节点还有一个length属性，保存着节点中字符的数目 nodeValue.length和data.length中也保存着相同的值。 创建文本节点方法：document.createTextNode() 参数：要插入节点中的文本（按照HTML或XML的格式进行编码） 1var textNode = document.createTextNode("&lt;strong&gt;Hello&lt;/strong&gt; world"); 要将新节点添加到文档树中已经存在的节点中才能使新节点在浏览器中展示 1234567var element = document.createElement("div");element.className = "message";var textNode = document.createTextNode("Hello world");element.appendChild(textNode);document.body.appendChild(element); 规范化文本节点DOM文档中存在相邻的同胞文本节点很容易导致混乱，因此产生了一个能够将相邻文本节点合并的方法。 这个方法是：normalize() ，由Node类型定义，因此所有节点类型都存在该方法 如果在含有一个或多个文本节点的父元素上调用这个方法，则会将所有的文本节点合并成一个节点，节点的nodeValue等于将合并前每个文本节点的nodeValue值拼接起来的值。 浏览器在解析文档时永远不会创建相邻的文本节点，只有在执行DOM操作时会出现 分割文本节点Text类型提供了一个作用跟normalize()相反的方法：splitText() 这个方法会将一个文本节点分成两个文本节点 原来的节点包含从开始到指定位置之前的内容，新文本节点包含剩下的文本，返回新文本节点。新文本节点个原节点的parentNode相同 123456789101112var element = document.createElement("div");element.className = "message";var textNode = document.createTextNode("Hello World");element.appendChild(textNode);document.body.appendChild(element);var newNode = element.firstChild.splitText(5);alert(element.firstChild.nodeValue); //Helloalert(newNode.nodeValue); //Worldalert(element.childrenNodes.length);//2 10.1.5 Attr类型区分特性（attribute）和属性（property）： 元素的特性在DOM中以attr来表示，从技术角度讲，特性就是存在于元素的attributes属性中的节点。 特性用来描述属性 Attr对象有3个属性：name,value,specified name：特性名称（与nodeName的值相同） value: 特性的值 (与nodeValue的值相同) specified：一个布尔值，用以区别特性是在代码中指定的还是默认的。 10.2 DOM操作技术10.2.1 动态脚本动态脚本指的是：在页面加载时不存在，但将来的某一时刻通过修改DOM动态添加的脚本 10.2.2 动态样式10.2.3 操作表格10.2.4 使用nodeList第十一章 DOM扩展两个主要的扩展是：Selectors API 和 HTML5 11.1 选择符APISelectors API是由W3C发起指定的标准，致力于让浏览器原生支持CSS查询。这样一来，解析和树查询操作可以在浏览器内部通过编译后的代码来完成，极大地改善了性能。(jquery就是通过css选择符查询DOM获得文档的应用) 两个核心方法：querySelector()和querySelectorAll()。在兼容的浏览器中，可以通过Document及Element类型的实例来调用。 11.1.1 querySelector()方法：document(element).querySelector() 参数：css选择符 返回：与该模式匹配的第一个元素，没有找到则返回null 1234var body = document.querySelector("body");//取得body元素var myDiv = document.querySelector("#myDiv);//取得ID为myDiv的元素var select = document.querySelector(".selected")//取得class为selected的第一个元素var img = myDiv.querySelector("img.button") //取得myDiv子代中第一个class为button的img元素 11.1.2 querySelectorAll()方法：document(element).querySelectorAll() 参数：css选择符 返回：返回一个nodeList对象，包含匹配的元素 123456789var ems = document.querySelector("myDiv").querySelectorAll("em") //取得myDiv中的所有em元素var selecteds = document.querySelectorALL(".selected") //取得所有class为selected的元素var strongs = document.querySelectorAll("p strong") //取得所有p元素的strong元素//取得返回nodeList中的每一个元素for(i=0,len = strongs.length;i&lt;len;i++)&#123; strong = strongs[i] //或者strong.item(i) //执行某些操作&#125; 11.1.3 matchedSelector()为Element类型新增的方法 方法：element.matchedSelector() 参数：css选择符 返回：ture,flase; 如果调用元素与选择符匹配则返回ture，否则返回fasle 11.2 元素遍历（不包含空白文本节点）对于元素空格，IE9及之前不会返回文本节点，其他浏览器都会。为了弥补这一差异，E定义了一组新的属性。 添加了以下五个属性： childElementCount:返回子元素（不包括文本节点和注释）的个数 firstElementChild:指向第一个元素 lastElementChild:指向最后一个元素 previousElementSibling:指向前一个同胞元素 nextElementSibling:指向后一个同胞元素 这些属性返回的元素都不包含空白文本节点 遍历所有子元素 12345var i,len,child = element.firstElementChild;while(child!=element.lastElementChild)&#123; //某些操作 child = child.nextElementSibling;&#125; 11.3 HTML511.3.1 与类相关的扩充新增了很多致力于简化CSS类的用法 getElementsByClassName() 方法方法：getElementsByClassName() 参数：一个包含一或多个类名的字符串 返回：带有指定类的所有元素的NodeList 1234//取得所有类中包含“username"和”current"的元素var allCurrentUsernames = document.getElementsByClassName("username current");//取得ID为"myDiv"的元素中带有类名"selectd"的所有元素var selectd = document.getElementById("myDiv").getElementsByClassName("selected"); classList 属性操作类名时，通过className属性添加，删除和替换类名。但是因为className是一个字符串，所以即使只是修改字符串一部分也必须都设置整个字符串的值。 12//这个div元素一共有三个类名，要从中删除一个类名需要把三个类名拆开，然后删除再拼接&lt;div class="bd user disabled"&gt;....&lt;/div&gt; HTML5为所有元素添加classList属性以便操作类名。有包含多少元素的length属性，取得每个元素可以使用item()方法，也可以使用方括号[]。 新类型定义的方法如下： add(value):将给定的字符串添加到列表中 contains(value):表示列表中是否存在给定的值，如果存在则返回true，否则返回false remove(value)：从列表中删除给定的字符 toggle(value)：如果列表中存在给定的值，删除它；如果列表中没有给定的值，添加它 比如从上面的div元素中删除user类 1div.classList.remove("user"); 11.3.2 焦点管理新增document.activeElement属性，这个属性始终会引用DOM中当前获得了焦点的元素（页面加载，用户输入，代码调用focus）。 默认情况下，文档刚加载完这个属性保存的是document.body元素，加载期间，这个属性的值为null。 新增方法：document.hasFocus()，用于确定文档是否获得了焦点。 11.3.3 HEMLDocument的变化readyState属性两个可能的值： loading:正在加载文档 complete:已经加载完文档 应用：实现一个指定文档已经加载完的指示器。 在这个属性之前，必须借助onload时间处理程序设置一个标签来表明文档已经加载完毕。 123if(document.readyState == "complete")&#123; //执行操作&#125; 11.3.4 自定义数据属性HTML5规定可以为元素添加非标准的属性，但是要添加前缀data-。目的是为元素提供与渲染无关的信息，或者提供语义信息。 1&lt;div id="myDiv" data-appID="12345" data-mynane="Jack"&gt;&lt;/div&gt; 可以通过元素的dataset属性来访问自定义数据属性。dataset属性的值是DOMStringMap的一个实例，是一个名值对的映射。 1234567var div = document.getElementById("myDiv");var appId = div.dataset.appID;var myname = div.dataset.myname;alert("hello,"+appid+myname);//hello,12345Jack也可以修改值div.dataset.appID=123; 11.4 一些专有扩展第十二章 DOM2和DOM312.1 DOM变化12.2 DOM操作样式DOM级样式提供了一套API来操作样式。 12.2.1 访问元素的样式任何支持style特性的HTML元素在javascript中都有一个对应的style属性。在style特性中指定的任何CSS属性都将表现为这个style对象的相应属性。 style对象不包含与外部样式表或嵌入样式表经层叠而来的样式。 js访问时，对于使用短划线的css属性，必须将其转换为驼峰大小写形势 CSS属性 JavaScript属性 background-imgae style.backgroundImage color style.color display style.display font-family style.fontFamily 多数情况下都可以通过转换属性名的格式来实现转换，但是css属性float不能，因为float是javascript的保留字，不能用作属性名。DOM2规范规定相应属性名为cssFloat，大部分浏览器都支持，但是IE支持的是styleFloat。 12345678var div = document.getElementById("myDiv");//设置样式myDiv.style.backgroundColor = "red";myDiv.style.border="1px solid red";//获取样式alert(myDiv.style.background) //red; DOM样式属性和方法为style对象定义了一些方法和属性： cssText:访问到style特性中的css代码 length:应用给元素的css属性的数量 parentRule:表示css信息的CSSRule对象 getPropertyCSSValue(propertyName):返回包含给定属性值的CSSValue对象（CSSValue对象包含两个属性：cssText,cssValueType。cssText属性的值和getPropertyValue()返回的值相同；cssValueType属性的值是一个数据常量，表示值的类型：0表示继承的值，1表示基本的值，2表示值列表，3表示自定义的值） getPropertyPriority(propertyName):如果给定的属性使用了!important设置，返回”important”，否则返回空字符串 getPropertyValue(propertyName):返回给定属性的字符串值 item(index):返回给定位置的css属性的名称 removeProperty(propertyName):从样式中删除给定属性 setProperty(propertyName,value,priority):将给定属性设置为相应的值，并加上优先权标志(important或空字符串） 计算的样式document.defaultView提供了getComputedStyle()方法 方法：getComputedStyle() 参数：要计算样式的元素，一个伪元素字符串（不选为null） 返回：一个CSSStyleDeclaration对象（与style属性的类型相同），包含当前元素的所有计算的样式 12345678910111213141516171819202122232425&lt;style type = "text/css"&gt; .myDiv&#123; background-color:blue; width:100px; height:200px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id="myDiv1" class="myDiv"&gt;&lt;/div&gt; &lt;div id="myDiv2" class="myDiv" style="background-color:red"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;var myDiv1 = document.getElementById("myDiv1"); console.log(myDiv1.style.width) //"" undifined 无法访问到嵌入样式表的样式var computedStyle = document.defaultView.getComputedStyle(myDiv1,null);console.log(computedStyle.width); //100px var myDiv2 = document.getElementById("myDiv2"); console.log(myDiv1.style.backgroundColor); //redconsole.log(myDiv1.style.width); //undefined &lt;/script&gt; 12.2.2 操作样式表12.2.3 元素大小12.3 遍历NodeIterator和TreeWalker 深度优先的遍历 12.4 范围##第十三章 事件 JavaScript与HTML之间的交互式通过事件来实现的。 13.1 事件流事件流描述的是从页面中接收事件的顺序。 13.1.1 事件冒泡IE的事件流叫做事件冒泡，事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接受，然后逐级向上传播到较为不具体的节点（文档） 13.1.2 事件捕获不太具体的节点应该更早接收到事件，最具体的节点应该最后接收到事件 13.1.3 DOM事件流DOM2级事件规定的事件流包括三个阶段：事件捕获阶段，处于目标阶段和事件冒泡阶段 事件捕获阶段：从Document查找到最具体元素之前的阶段 处于目标阶段：最具体元素 事件冒泡阶段：从最具体元素冒泡到Document 13.2 事件处理程序响应某个事件的函数叫做事件处理程序（或事件监听器） 事件处理程序的名字以“on”开头，如：click事件的时间处理程序就是onclick，load事件的时间处理程序就是onload。为事件指定处理程序的方式有很多 12.2.1 HTML事件处理程序这个操作是通过指定onclick特性并将一些JavaScript代码作为它的值来定义的。因此不能使用未转义的HTML语法字符。 HTML时间处理程序可以包含要执行的具体动作，也可以调用在页面其他地方定义的脚本 12345678910//具体动作&lt;input type = "button" value = "click Me" onclick="alert('clicked')"/&gt;//其他地方定义的脚本&lt;script&gt; function showMessage()&#123; alert("Hello world!"); &#125;&lt;/script&gt;&lt;input type="button" value="click Me" onclick="showMessage()"/&gt; 12.2.2 DOM0级事件处理程序传统方式：将一个函数赋值给一个事件处理程序属性 1234var btn = document.getElementById("myBtn");btn.onclick = function()&#123; alert("Clicked");&#125; 使用DOM0级方法指定的时间处理程序被认为是元素的方法，因此这时的时间处理程序是在元素的作用域中运行 1234var btn = document.getElementById("myBtn");btn.onclick = function()&#123; alert(this.id); //"myBtn"&#125; 以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。 也可以删除事件处理程序 1btn.onclick=null 13.2.3 DOM2级事件处理程序处理指定事件处理程序：addEventListener() 删除指定事件处理程序：removeEventListener() 都接受3个参数：要处理的事件名，作为事件处理程序的函数，一个布尔值（true捕获阶段调用，false冒泡阶段调用） 1234567var btn = document.getElementById("myBtn");btn.addEventListener("click",function()&#123; alert(this.id);&#125;,false);btn.addEventListener("click",function()&#123; //可以添加多个事件处理程序 alert("Hello world!");&#125;,false); 通过addEventListener添加的事件处理程序只能通过removeEventListener()来移除，移除时传入的参数与添加时相同，但像上面代码中的匿名函数无法被删除。 大多数情况下都是将事件处理程序添加到事件流的冒泡阶段 13.2.4 IE事件处理程序两个类似的方法：attachEvent(),detachEvent() 主要区别在于这两个方法的事件处理程序会在全局作用域中运行，this等于window 13.3 事件对象在触发DOM上的某个对象时，会产生一个事件对象event，这个对象包含着所有与事件有关的信息，包括事件的元素，事件的类型以及其他与特性时间相关的信息。 13.3.1 DOM中的事件对象兼容DOM的浏览器会将一个event对象传入到事件处理程序中。 12345678var btn = document.getElementById("myBtn");btn.onclick = function(event)&#123; alert(event.type); //"click"&#125;btn.addEventListener("click",function(event)&#123; alert(event.type); //"click"&#125;,false) target currentTarget在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标。如果直接将事件处理程序指定了目标元素，则三个值相同。如果把事件处理程序指定了目标元素的父节点中，则this,currentTarget指的是父节点，而target指的是目标元素。 1234567891011var btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function(event)&#123; alert(this == event.currentTarget); //true alert(this == event.target); //true&#125;document.body.onclick = function(event)&#123; alert(event.currentTarget == document.body);//true alert(event.currentTarget == this); //true alert(event.target == myBtn); //true&#125; Type通过一个函数处理多个事件可以用type 1234567891011121314151617var btn = document.getElementById("myBtn");var handler = function(event)&#123; switch(event.type)&#123; case "click": alert("Clicked"); break; case "mouseover": event.target.style.backgroundColor = "red"; break; case "mouseout": event.target.style.backgroundColor = ""; break; &#125;&#125;;btn.onclick = handler;btn.onmouseover = handler;btn.onmouseout = handler; 13.4 事件类型13.5 内存性能&amp;&amp;模拟事件13.5.1 事件委托事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的事情。不需要给每个可单击的元素分别添加事件处理程序。 12345678910111213141516171819202122 &lt;ul class="palette"&gt; &lt;li style="background-color:crimson"&gt;&lt;/li&gt; &lt;li style="background-color:bisque"&gt;&lt;/li&gt; &lt;li style="background-color:blueviolet"&gt;&lt;/li&gt; &lt;li style="background-color:coral"&gt;&lt;/li&gt; &lt;li style="background-color:chartreuse"&gt;&lt;/li&gt; &lt;li style="background-color:darkolivegreen"&gt;&lt;/li&gt; &lt;li style="background-color:cyan"&gt;&lt;/li&gt; &lt;li style="background-color:#194738"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;script&gt; var uList = document.querySelector("ul");uList.addEventListener("click",function(event)&#123; thisLi = event.target; //获得用户实际点击的li console.log(thisLi); //执行某些操作 &#125;)&lt;/script&gt; 第十四章 表单脚本JavaScript最初的一个应用就是分担服务器处理表单的责任，打破处处依赖服务器的局面 14.1 表单的基础知识在HTML中，表单元素，在javascript中，表单对应的则是HTMLFormElement类型。 一些除默认属性外的独特的属性和方法： acceptCharset:服务器能够处理的字符集，等价于HTML中的accept-charset特性 action 接受请求的URL，等价于HTML中的action特性 elements:表单中所有控件的集合 enctype:请求编码的类型 length:表单中控件的数量 method：要发送的HTTP请求类型（get,post) name:表单的名称 reset():将所有表单域重置为默认值 submin():提交表单 target():用于发送请求和接受响应的窗口名称 取得form元素引用的方式： 将他看成和其他元素一样，添加id特性，然后使用getElementById() 1var form = document.getElementById("form1"); 通过document.forms可以取得页面中所有表单，在这个集合中可以通过数组索引或name值来取得特定的表单 12var firstForm = document.forms[0]; //取得页面中第一个表单var myForm = document.forms["form2"]; //取得页面中名称为"form2"的表单 14.1.1 提交表单提交方法 使用或都可以定义提交按钮，只要将type特性设置为”submit”即可，而图像按钮则是通过将的type特性设置为image来定义的 123&lt;input type="submit" value="Submit Form"&lt;button type="submit" value="Submit Form"&gt;&lt;/button&gt;&lt;input type="image" src="graphic.gif"&gt; 只要表单中存在上面列出的任何一种按钮，那么在相应表单空间拥有焦点的情况下，按回车键就可以提交该表 单。 以这种方式提交表单，浏览器会在将请求发送给服务期之前触发submit事件。这样就有机会验证表单数据，并以此决定是否允许表单提交。 1234567var form = document.getElementById("myForm");EventUtil.addHandler(form,"submit",function(event)&#123; event = EventUtil.getEvent(event); //阻止默认事件 EventUtil.preventDefault(event);&#125;) 也可以在js中以编程方式调用submit方法来提交 12var form = document.getElementById("myForm");form.submit(); 以这种方式调用submit的方式提交表单不会触发submit事件，因此要先验证表单数据。 解决出现的问题可能出现的最大问题就是重复提交表单：如果服务器长时间没反应用户可能会反复单击提交按钮会造成错误 解决方法： 在第一次提交表单后就禁用提交按钮 123456789EventUtil.addHandler(form,"submit",function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var btn = target.element["submit-btn"]; btn.disabled = ture; &#125;)//不能使用onclick来实现这个功能，因为无法确定submit和禁用事件的执行顺序。因此最好通过监听submit事件来实现。 利用onsubmit事件处理程序取消后续的表单提交操作 14.1.2 重置表单在用户单击重置按钮时，表单会被重置。使用type特性值为“reset”的input或button都可以创建重置按钮。 12&lt;input type="reset" value="Reset Form"&gt;&lt;button type="reset"&gt;Reset Form&lt;/button&gt; 重置表单时，所有表单字段都会恢复到页面刚加载完毕的初始值。 用户单击重置按钮重置表单时，会触发reset事件，利用这个机会，可以在必要时取消重置操作 1234567var form = document.getElementById(&quot;myForm&quot;);EventUtil.addHandler(form,&quot;reset&quot;,function(event)&#123; event = EventUtil.getEvent(event); //阻止默认事件 EventUtil.preventDefault(event);&#125;) 与提交表单一样，重置也可以使用js,form.reset()即可 不一样的是，使用js调用也会像单击重置按钮一样触发reset事件。 14.1.3 表单字段每个表单都有elements属性，该属性是表单中所有表单字段的集合。elements集合是一个有序列表，其中包含着表单中的所有字段，例如input textarea button filedset。表单字段在集合中的顺序，与他们出现在标记中的顺序相同，可以按照位置和name特性来访问他们。 12345var form = document.getElementById("myForm");var field1 = form.elements[0]; //取得表单中第一个字段var field2 = form.elements["textbox1"] //去的表单中名为”textbox1"的字段var fieldCout = form.elements.length; //取得表单中包含的字段数量 如果有多个表单控件都在使用一个name(如单选按钮)，那么就会返回一个以该name命名的一个NodeList。 共用的表单字段属性除了fieldset元素之外，所有表单字段都拥有相同的一组属性。表单字段共有的属性如下： disabled:布尔值，表示当前字段是否被禁用 form:指向当前字段所属表单的指针（只读） name:当前字段的名称 readOnly:布尔值，表示当前字段是否只读 tabIndex:表示当前字段的切换序号 type:当前字段的类型（checkbox,radio) value:当前字段将被提交给服务器的值，对于文件字段来说这个属性只读，包含文件在计算机中的路径。 除了form属性，可以通过JS来修改其他任何属性 1234567var form = document.getElementById("myForm");var field = form.elements[0];field.value="Another value";alert(field.form === form) //truefield.disabled=ture;//禁用当前字段 共有的表单字段方法每个表单字段都有两个方法：focus()和blur()。 focus：将浏览器的焦点设置到表单字段，即激活表单字段。 例如，可以在页面加载完毕后，将焦点转移到表单的第一个字段。（监听load事件，并在事件发生时在表单的第一个字段上调用focus方法） 12345EventUtil.addHandler(window,"load",function(event)&#123; document.forms[0].elements[0].focus();&#125;);//如果上述表单中第一个表单字段是input,并且type特性的值为hidden，则上述代码会导致错误。css的display和visibility属性也会导致错误 HTML5新增autofocus属性。不用js也能自动移动焦点 input type=”text” autofocus blur: 从元素中移走焦点 调用blur()方法时，并不会把焦点转移到某个特定的元素上，仅仅是将焦点从调用这个方法的元素上面移走。 共用的表单字段事件除了支持鼠标，键盘，更改和HTML时间之外，所有的表单都支持下列三个事件： blur:当前字段失去焦点时触发 change:对于input和textarea元素，失去焦点且value值改变时触发；对于select元素，在选项值改变时触发 focus：当前字段获得焦点时触发 14.2 文本框脚本input 单行文本框 表现文本框必须将input元素的type特性设置为text size：指定文本框中能够显示的字符数 value:设置文本框的初始值 maxlength：指定文本框个可以接受的最大字符数 1&lt;input type="text" size="25" maxlength="50" value="initial value"&gt; 多行文本框 rows：指定文本框的字符行数 cols：指定文本框的字符列数 1&lt;textarea rows="25" cols="5"&gt;inital value&lt;/textarea&gt; 两种文本框都会将用户输入的内容保存在value属性中，可以通过这个属性来读取和设置文本框的值。 14.2.1 选择文本上述两种文本框都支持select()方法，这个方法用于选择文本框中的所有文本。调用select()方法是，大多数浏览器会将焦点设置到文本框中。 在文本获得焦点是选择所有文本。 123456EventUtil.addHandler(textbox,"focus",function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); target.select();&#125;); 选择事件在选择了文本框的文本后，就会触发select事件。用户选择了文本或者调用select方法都会触发select事件。 123456EventUtil.addHandler(textbox,"select",function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); alert(target.value);&#125;) 取得选择的文本HTML通过扩展方案以便顺利取得选择的文本。 添加两个属性：selectionStart selectionEnd 123function getSelectedText(textbox)&#123; return textbox.value.substring(textbox.selectionStart,textbox.selectionEnd);&#125; 选择部分文本方法：setSelectionRange() 参数：要选择的第一个字符的索引和最后一个字符之后的字符的索引 1234textbox.value = "Hello world";textbox.setSelectionRange(0,textbox.value.length);//Hello worldtextbox.setSelectionRange(0,3) //Hel 要见到选择的文本必须在调用该方法之前或者之后立即将焦点设置到文本框 14.2.2 过滤输入屏蔽字符屏蔽所有按键操作 1234EventUtil.addHandler(textbox,"keypress",function(event)&#123; event = EventUtil.getEvent(event); EventUtil.preventDefault(event); &#125;); 屏蔽特定的字符：检测keypress事件对应的字符编码 1234567891011121314//只允许用户输入数值//正则表达式判断不是数字(\d)的字符要屏蔽同时这个字符编码大于9(不屏蔽非字符键)//复制粘贴等组合需要用到ctrl键，需要确保用户没有按下ctrl键 !event.ctrlKeyEventUtil.addHandler(text,"keypress",function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); var charCode = EventUtil.getCharCode(event); if(!/\d/.text(String.fromCharCode(charcode))&amp;&amp;charCode&gt;9&amp;&amp;!event.ctrlKey)&#123; //fromCharCode()将字符编码转换为字符串 EventUtil.preventDefault(event); &#125;&#125;) 操作剪贴板 42414.2.3 自动切换焦点 P42614.2.4 HTML5约束验证API P42714.3 选择框脚本选择框脚本是通过和元素创建的。 HTMLSelectElement类型特有的属性和方法： add(newOption,relOption):向控件插入新元素，位置在相关项(relOption)之前 multiple:布尔值，是否允许多项选择；允许：type:select-multiple; 不允许：type:select-one; options:控件中所有元素的HTMLCollection remove(index):移除给定位置的选项 selectedIndex:基于0的选中项的索引，如果没有则为1.多选空间只保存选中项中第一项的索引 size:选择框中可见的行数 type属性由multiple决定 value属性由当前选择项决定（1.没有选中项为空字符串 2.有选中项等于其value值 3.选中项没有value值等于文本值 4.有多个选中项根据2.3取第一个选中项的值） 每个元素都有一个HTMLOptionElement对象。属性如下： index:当前选项在options集合中的索引 label:当前选项的标签 selected:布尔值，表示当前选项是否被选中 text:选项的文本 value:选项的值 14.3.1 选择选项对于只允许选择一项的选择框，访问选择项的最简单方式，就是使用选择框的selectedIndex属性： 1var selectedOption = selectbox.options[selectbox.selectedIndex]; 对于多选的选择框，可以循环遍历选项集合，测试每个选项的selected属性： 123456789101112function getSelectedOptions(selectbox)&#123; var result = new Array(); var option = null; for(var i=0,len=selectbox.options.length;i&lt;len;i++)&#123; option = selectbox.options[i]; if(option.selected == true)&#123; result.push(option[i]); &#125; &#125; return result;&#125; 14.3.2 添加选项 使用DOM方法 12345var newOption = document.createElement("option");newOption.appendChild(document.createTextNode("Option text"));newOption.setAttribute("value","Option value");selectbox.appendChild(newOption); 使用option构造函数，兼容DOM的浏览器会返回一个元素。接受两个参数，文本和值，值可选。 12var newOption = new Option("Option text","Option Value");selectbox.appendChild(newOption); //IE8之前有问题 使用选择框的add方法。接受两个参数：要添加的项和位于新项之后的选项。 12var newOption = new Option("Option text","Option Value");selectbox.add(newOption,undefined); //最佳方案 undefined会让新选项位于列表最后 14.3.3 移除选项三种方法 123selectbox.removeChild(selectbox.options[0]);selectbox.remove(0);//接受一个参数，被移除项的索引selecrbox.options[0]=null; 14.3.4 移动和重排序移动:appendChild()传入一个已有的元素，会先从该元素的父节点中移除它，再把它添加到指定的位置。 1234var selectbox1 = document.getElementById("selLocations1");var selectbox2 = document.getElementById("selLocations2");selectbox2.appendChild(selectbox1.options[0]); 重排序：insertBefore() 123var optionToMove = selectbox.options[1];selectbox.insertBefore(optionToMove,selectbox.options[optionToMove.index-1]);//前移一个selectbox.insertBefore(optionToMove,selectbox.options[optionToMove.index+2]);//后移一个 14.4 表单序列化 P43614.5 富文本编辑本质：在页面中嵌入一个包含HTML页面的iframe。通过设置designMode属性，这个空白的HTML可以被编辑，编辑的对象则是该页面元素的HTML代码。 design属性有两个可能的值：off on 当设置为on时，整个文档都会变得可以编辑。 design属性只有在页面加载完才能被设定，因此需要使用onload事件处理程序来设置。 12345678&lt;iframe name="richedit" style="height:100px;width:100px;" src="blank.htm"&gt;&lt;/iframe&gt; &lt;script type = "text/javascript"&gt; EventUtil.addHandler(window,"load",function()&#123; frames["richedit"].document.designMode = "on"; &#125;);&lt;/script&gt; 14.5.1 使用contenteditable属性把contenteditable属性应用给页面中的任何元素，然后用户就可以立即编辑该元素。 123456&lt;div class="editable" id="richedit" contenteditable&gt;&lt;/div&gt;//js方法var div = document.getElementById("richedit");div.contenteditable = true; //true表示打开，false表示关闭，inherit表示从父元素继承 14.5.2 操作富文本主要方式：document.execCommand() 参数：要执行的命令名称，浏览器是否为当前命令提供用户界面的一个布尔值，执行命令必须的值 12frames["richedit"].document.execCommand("bold",false,null);frames["richedit"].document.execCommand("createlink",false,"http//www.wrox.com"); 14.5.3 富文本选区使用frame的getSelection()方法，可以确定实际选择的文本。返回一个表示当前选择文本的selection对象。 提供了一些方法，支持对选取的操作 P442 14.5.4 表单与富文本富文本中的HTML不会被自动提交给服务器，需要手动来提取并提交。 通常添加一个隐藏表单字段，在提交表单之前，从iframe中提取出HTML，并插入隐藏的字段中 123456789EventUtil.addHandler(form,"submit",function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); target.elements["comments"].value = frames["richedit"].document.body.innerHTML;//frame元素 target.elements["comments"].value = document.getElementById("richedit").innerHTML //contentditable元素 &#125;)]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
