<!DOCTYPE html>
<html lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <link rel="stylesheet" href="/style/style.css">
<script>
  var nlviconfig = {
    title: "CuteNian",
    author: "Nian",
    baseUrl: "/",
    theme: {
      scheme: "banderole",
      lightbox: true,
      animate: true,
      search: true,
      friends: false,
      reward: false,
      lazy: false
    }
  }
</script>




    <link rel="stylesheet" href="/script/lib/lightbox/css/lightbox.min.css">




    <link rel="stylesheet" href="/syuanpi/syuanpi.min.css">











<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="browsermode" content="application">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="CuteNian">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="msapplication-navbutton-color" content="#666666">
<meta name="format-detection" content="telephone=no">
<meta name="keywords" content="nlvi, Nlvi">





  <meta name="keywords" content="前端, JS, Nlvi">

  <title> JS笔记 · CuteNian </title>
</head>
<body>
  <div class="progress">
  <div class="progress-inner"></div>
</div>

  
    <div class="tagcloud-mask"></div>  
<div class="tagcloud" id="tagcloud">
  <div class="tagcloud-inner">
    <a href="/tags/Ajax/" style="font-size: 14px;">Ajax</a> <a href="/tags/DP/" style="font-size: 14px;">DP</a> <a href="/tags/Flask/" style="font-size: 14px;">Flask</a> <a href="/tags/HTML/" style="font-size: 14px;">HTML</a> <a href="/tags/JS/" style="font-size: 14px;">JS</a> <a href="/tags/paper/" style="font-size: 14px;">paper</a> <a href="/tags/python/" style="font-size: 14px;">python</a> <a href="/tags/体系结构/" style="font-size: 14px;">体系结构</a> <a href="/tags/刷题/" style="font-size: 14px;">刷题</a> <a href="/tags/前端/" style="font-size: 14px;">前端</a>
  </div>
</div>
  

  <div class="container" style="display:none;">

    <header class="header" id="header">
  <div class="header-wrapper">
    <div class="logo">
  <div class="logo-inner syuanpi tvIn">
    <span><a href="/">CuteNian</a></span>
    
  </div>
</div>
    <nav class="main-nav">
  
  <ul class="main-nav-list syuanpi tvIn">
  
    <li class="menu-item">
      <a href="javascript:;" id="search">
        <span>Search</span>
        
          <span class="menu-item-label">search</span>
        
      </a>
    </li>
  
  
    
      
    
    <li class="menu-item">
      <a href="/" id="article">
        <span class="base-name">Articles</span>
        
          <span class="menu-item-label">article</span>
        
      </a>
    </li>
  
    
      
    
    <li class="menu-item">
      <a href="/archives" id="archives">
        <span class="base-name">Archives</span>
        
          <span class="menu-item-label">archives</span>
        
      </a>
    </li>
  
    
      
    
    <li class="menu-item">
      <a href="javascript:;" id="tags">
        <span class="base-name">Tags</span>
        
          <span class="menu-item-label">tags</span>
        
      </a>
    </li>
  
    
      
    
    <li class="menu-item">
      <a href="/about" id="about">
        <span class="base-name">About</span>
        
          <span class="menu-item-label">about</span>
        
      </a>
    </li>
  
  </ul>
  
</nav>

    
    
  </div>
</header>
<div class="mobile-header">
  <div class="mobile-header-body">
    <div class="mobile-header-list">
      
        
            <div class="mobile-nav-item">
                <a href="/">
                    <span>Articles</span>
                    
                    
                </a>
            </div>
        
      
        
            <div class="mobile-nav-item">
                <a href="/archives">
                    <span>Archives</span>
                    
                    
                </a>
            </div>
        
      
        
          <div class="mobile-nav-item inner-cloud">
            <div class="mobile-nav-tag">
              <a href="javascript:;" id="mobile-tags">
                <span>Tags</span>
                
                
              </a>
            </div>
            <div class="mobile-nav-tagcloud">
              <div class="mobile-tagcloud-inner">
                <a href="/tags/Ajax/" style="font-size: 14px;">Ajax</a> <a href="/tags/DP/" style="font-size: 14px;">DP</a> <a href="/tags/Flask/" style="font-size: 14px;">Flask</a> <a href="/tags/HTML/" style="font-size: 14px;">HTML</a> <a href="/tags/JS/" style="font-size: 14px;">JS</a> <a href="/tags/paper/" style="font-size: 14px;">paper</a> <a href="/tags/python/" style="font-size: 14px;">python</a> <a href="/tags/体系结构/" style="font-size: 14px;">体系结构</a> <a href="/tags/刷题/" style="font-size: 14px;">刷题</a> <a href="/tags/前端/" style="font-size: 14px;">前端</a>
              </div>
            </div>
          </div>
        
      
        
            <div class="mobile-nav-item">
                <a href="/about">
                    <span>About</span>
                    
                    
                </a>
            </div>
        
      
    </div>
  </div>
  <div class="mobile-header-nav">
    <div class="mobile-header-item" id="mobile-left">
      <div class="header-menu-item">
        <span class="header-menu-line"></span>
      </div>
    </div>
    <h1 class="mobile-header-title">
      <a href="/">CuteNian</a>
    </h1>
    <div class="mobile-header-item"></div>
  </div>
</div>
    <div class="container-inner">
      <main class="main" id="main">
        <div class="main-wrapper">
          
    
  
  <article class="
  post
   is_post 
  ">
    <header class="post-header">
      <div class="post-time syuanpi fadeInUpShort back-1">
        <div class="post-time-wrapper">
          <span>2018-10-29</span>
          
            
              <span class="post-category"><a href="/categories/前端/">前端</a></span>
            
              <span class="post-category"><a href="/categories/前端/JS/">JS</a></span>
            
          
          
            
              <aside class="post-tags syuanpi fadeInUpShort back-3">
              
                <a href="/tags/前端/">前端</a>
              
                <a href="/tags/JS/">JS</a>
              
              </aside>
            
          
        </div>
      </div>
      <h1 class="post-title syuanpi fadeInUpShort back-2">
        
          JS笔记
        
      </h1>
    </header>
    <div class="post-content syuanpi fadeInUpShort back-3">
      
        <p>全部都是看红宝书时候记得笔记，十分杂乱<br><a id="more"></a></p>
<h2 id="第六章-面向对象的程序设计"><a href="#第六章-面向对象的程序设计" class="headerlink" title="第六章 面向对象的程序设计"></a>第六章 面向对象的程序设计</h2><h4 id="6-1-对象"><a href="#6-1-对象" class="headerlink" title="6.1 对象"></a>6.1 对象</h4><h5 id="6-1-1-理解对象"><a href="#6-1-1-理解对象" class="headerlink" title="6.1.1 理解对象"></a>6.1.1 理解对象</h5><p>无序属性的集合，其属性可以包含基本值，对象或者函数</p>
<ol>
<li>两种创建方法：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*第一种 创建Object实例*/</span><br><span class="line">var person = new Object();</span><br><span class="line">person.name = &quot;Tom&quot;;</span><br><span class="line">person.age = 29;</span><br><span class="line"></span><br><span class="line">person.sayName = function()&#123;</span><br><span class="line">    alert(person.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* 第二种 对象字面量*/</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">    name:&quot;Tom&quot;,</span><br><span class="line">    age:29,</span><br><span class="line">    </span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>对象的属性类型</li>
</ol>
<ul>
<li><p>数据属性</p>
<p>数据属性可以读取或者写入值，有四个可以描述属性行为的特性：</p>
<p>[[configurable]]<br>[[Enumerable]]<br>[[Writable]]<br>[[Value]]</p>
</li>
<li><p>访问器属性</p>
<p>不包含数据值，包含一对getter和setter函数</p>
<p>读取属性调用getter函数，写入属性调用setter函数</p>
<p>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">    _year:2004,</span><br><span class="line">    edition:1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(book,&quot;year&quot;,&#123;</span><br><span class="line">    get:function()&#123;</span><br><span class="line">        return this._year;</span><br><span class="line">    &#125;</span><br><span class="line">    set:function(newValue)&#123;</span><br><span class="line">        if(newValue&gt;2004)&#123;</span><br><span class="line">            this._year = newValue;</span><br><span class="line">            this.edition += newValue - 2004;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.year = 2005;</span><br><span class="line">alert(book.edition); //2</span><br></pre></td></tr></table></figure>
<h5 id="6-1-2-创建对象"><a href="#6-1-2-创建对象" class="headerlink" title="6.1.2 创建对象"></a>6.1.2 创建对象</h5><ol>
<li><p>工厂模式</p>
<p>用函数来封装以特定接口创建对象的细节</p>
<p>优点：抽象了具体过程<br><br>缺点：无法识别对象的类型</p>
</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age,job)&#123;</span><br><span class="line">    var o = new Object;</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = function()&#123;</span><br><span class="line">        alert(o.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>构造函数模式</p>
<p> 创建自定义的构造函数，从而定义自定义对象类型的属性和方法 <br><br> 优点：可以识别对象的类型<br><br> 缺点:每个方法都要在每个实例上重新创建一遍</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(Tom,29)</span><br><span class="line"></span><br><span class="line">alert(person instanceof Person) //true</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   解释构造函数：</p>
<p>   同其他函数的唯一区别：调用方式不同<br><br>   任何函数通过new操作符来调用都可以作为构造函数</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var person = new Person(&quot;Tom&quot;,29)</span><br><span class="line">person.sayName(); //Tom</span><br><span class="line"></span><br><span class="line">// 全局作用域中调用函数,this对象总指向global对象（在浏览器中就是window对象）</span><br><span class="line">Person(&quot;Ford&quot;,29)</span><br><span class="line">window.sayName();//Ford</span><br><span class="line"></span><br><span class="line">// 在另一个对象的作用域中调用 o和前面的person的属性是相同的</span><br><span class="line"></span><br><span class="line">var o = new Object();</span><br><span class="line">Person.call(o,&quot;Jack&quot;,29);</span><br><span class="line">o.sayName(); //Jack</span><br><span class="line"></span><br><span class="line">// o和person虽然有相同的属性，但是对象类型不同</span><br><span class="line">alert(o instanceof Person); //false</span><br><span class="line">alert(person instanceof Person); //true</span><br><span class="line"></span><br><span class="line">//想要尝试修改o的构造函数，这是错误的。因为构造函数是由原型指定的，如果试图修改o的原型也就是Object的原型，会导致所有的对象发生错误，因此js不允许做这样的修改。</span><br></pre></td></tr></table></figure>
<p><strong>2. 原型模型</strong></p>
<p>   每一个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，这个对象包含可以由特性类型的所有实例共享的属性和方法。</p>
<p>   prototype指向通过构造函数创建的对象实例的原型对象。</p>
<p>   优点：所有对象实例都可以共享它所包含的属性和方法<br></p>
<p>   缺点：</p>
<ol>
<li>忽略了构造函数传参，所有实例共享相同的默认值</li>
<li>对于引用值属性，修改一个实例所有实例都将被修改</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    person.prototype.name = &quot;Tom&quot;;</span><br><span class="line">    person.prototype.age = 29;</span><br><span class="line">    person.prototype.sayName=function()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line">person.sayName();//Tom</span><br><span class="line">var person2 = new Person();</span><br><span class="line"></span><br><span class="line">alert(person1.sayName == person2.sayName) //true</span><br></pre></td></tr></table></figure>
<p><strong>理解原型对象</strong></p>
<p>创建新函数就会根据一组特定的规则为该函数创建一个prototype属性，指向函数的原型对象。</p>
<p>函数的原型对象中有一个constructor属性，指向创建的自定义函数。</p>
<p>构造函数的实例中也有一个prototype属性，指向函数的原型对象。</p>
<p>关系如图所示:</p>
<p><img src="http://o7cqr8cfk.bkt.clouddn.com/public/16-11-10/6663492.jpg" alt="image"></p>
<p>注意：可以通过对象实例来访问保存在原型中的值，但是不能通过对象实例重写原型中的值。</p>
<p>如果在实例中添加一个跟原型对象中同名的属性值，那么该属性值会屏蔽掉原型中的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person1.name = &quot;Jack&quot;;</span><br><span class="line">person1.sayName();//Jack 屏蔽掉了原型中的值</span><br><span class="line">person2.sayName();//Tom 原型中的值</span><br></pre></td></tr></table></figure>
<p><strong>原型的动态性</strong></p>
<p>对原型所做的任何修改都可以在实例上体现出来<br><br>因为实例和原型的连接是一个指针,实例可以通过该指针在原型中找到新的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName=function()&#123;</span><br><span class="line">    alert(&quot;Tom&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.sayName();//Tom</span><br></pre></td></tr></table></figure>
<p>但是如果重写整个prototype对象，则相当于切断了实例与原型对象的联系，因为实例仍然指向最初的原型对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    Person.prototype.name=&quot;tom&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    sayHello : function()&#123;</span><br><span class="line">        console.log(&quot;Hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//person只能访问到旧原型中的属性，重写的原型无法访问</span><br><span class="line">console.log(person.name); //tom</span><br><span class="line">person.sayHello();        //error</span><br></pre></td></tr></table></figure>
<p><strong>3. 组合使用构造函数模式和原型模式</strong></p>
<p>构造函数模式用于定义不共享的实例属性，原型模式用于定义方法和共享的属性。</p>
<p>优点： 每个实例都会有自己的一份实力属性的副本，同时又共享者对方法的引用，节省了内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.friends = [&quot;Shelby&quot;,&quot;Court&quot;] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor:Person,</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&quot;Tom&quot;,29);</span><br><span class="line">var person2 = new Person(&quot;Jack&quot;,29);</span><br><span class="line"></span><br><span class="line">//对一个实例的引用属性的修改不会影响其他实例</span><br><span class="line">person1.friends.push(&quot;Mary&quot;);</span><br><span class="line">console.log(person1.friends); //[&quot;Shelby&quot;,&quot;Court&quot;,&quot;Mary&quot;]</span><br><span class="line">console.log(person2.friends);//[&quot;Shelby&quot;,&quot;Court&quot;]</span><br><span class="line"></span><br><span class="line">//共享方法</span><br><span class="line">console.log(person1.sayName==person2.sayName) //true</span><br></pre></td></tr></table></figure>
<h4 id="6-2-继承"><a href="#6-2-继承" class="headerlink" title="6.2 继承"></a>6.2 继承</h4><p>ECMAScript只支持实现继承，依靠原型链来实现</p>
<h5 id="6-2-1-原型链继承"><a href="#6-2-1-原型链继承" class="headerlink" title="6.2.1 原型链继承"></a>6.2.1 原型链继承</h5><p>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<p>实现的本质：用一个新类型的实例来重写并且代替原型对象。</p>
<p>缺点：</p>
<ol>
<li>如果作为子类型原型对象的超类型实例中有引用类型，那么修改某一个对象的引用类型时所有对象的引用类型都将被修改。</li>
<li>创建子类型的实例时，不能像超类型的构造函数传参。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">    this.color = [&quot;red&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue=function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function subType()&#123;</span><br><span class="line">    this.subProperty = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line">subType.prototype.getSubValue = function()&#123;</span><br><span class="line">    return this.subProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new subType();</span><br><span class="line">var instance2 = new subType();</span><br><span class="line">console.log(instance1.getSuperValue); //true</span><br><span class="line"></span><br><span class="line">//缺点：修改1的color,2的color也会改变</span><br><span class="line">instance1.color.push(&quot;black&quot;);</span><br><span class="line">console.log(instance1.color);//[&quot;red&quot;,&quot;black&quot;]</span><br><span class="line">console.log(instance2.color);//[&quot;red&quot;,&quot;black&quot;]</span><br></pre></td></tr></table></figure>
<p>注意：使用原型链继承时不能用对象字面量来创建原型方法，这样会重写原型链，切断与超类的联系。</p>
<h5 id="6-2-2-借用构造函数"><a href="#6-2-2-借用构造函数" class="headerlink" title="6.2.2 借用构造函数"></a>6.2.2 借用构造函数</h5><p>基本思想:在子类型构造函数的内部调用超类型构造函数。</p>
<p>优点：解决了原型中包含引用类型值带来的问题<br><br>缺点: 无法实现函数复用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.color = [&quot;red&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subProperty = false;</span><br><span class="line">    //可以传参</span><br><span class="line">    SuperType.call(this,&quot;Tom&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">var instance2 = new SubType();</span><br><span class="line"></span><br><span class="line">instance1.color.push(&quot;black&quot;);</span><br><span class="line">console.log(instance1.color); //[&quot;red&quot;,&quot;black&quot;]</span><br><span class="line">console.log(instance2.color); //[&quot;red&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//只继承了构造函数中的属性和方法，没有继承原型中的方法</span><br><span class="line">console.log(instance1.getSuperValue()) //error</span><br><span class="line"></span><br><span class="line">console.log(instance1 instanceof SuperType)//false</span><br></pre></td></tr></table></figure>
<h5 id="6-2-3组合继承"><a href="#6-2-3组合继承" class="headerlink" title="6.2.3组合继承"></a>6.2.3组合继承</h5><p>基本思路：原型链实现对原型属性和方法的继承<br>构造函数实现对实力属性的继承。</p>
<p>优点:实现了函数复用，又保证每个实例都有自己的属性</p>
<p>缺点:创建子类型时，会调用两次超类型的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.color=[&quot;red&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype=&#123;</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">    SuperType.call(this,name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType();</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType(&quot;Tom&quot;,&quot;29&quot;);</span><br><span class="line">var instance2 = new SubType(&quot;Jack&quot;,&quot;21&quot;);</span><br><span class="line"></span><br><span class="line">//修改引用类型属性不会影响其他实例</span><br><span class="line">instance1.color.push(&quot;black&quot;); </span><br><span class="line">console.log(instance1.color,instance2.color);//[&quot;red&quot;,&quot;black&quot;],[&quot;red&quot;]</span><br><span class="line"></span><br><span class="line">// 继承了超类型的原型方法,并且实现了复用</span><br><span class="line">console.log(instance1.sayName()); //Tom</span><br><span class="line">console.log(instance1.sayName==instance2.sayName); //True</span><br></pre></td></tr></table></figure>
<h5 id="6-2-4-原型式继承"><a href="#6-2-4-原型式继承" class="headerlink" title="6.2.4 原型式继承"></a>6.2.4 原型式继承</h5><p>想法：不必创建自定义类型，借助原型可以基于已有的对象创建新对象。</p>
<p>给出如下函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function object(o)&#123;</span><br><span class="line">    function F()&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br><span class="line">//本质是 object()对传入的对象执行了一次浅复制</span><br><span class="line"></span><br><span class="line">var person()&#123;</span><br><span class="line">    name:&quot;Tom&quot;,</span><br><span class="line">    friends:[&quot;Jack&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var anotherPerson = object(person);</span><br></pre></td></tr></table></figure></p>
<p>在ECMAsript 5新增了Object.create()方法来规范原型式继承。<br>接受两个参数（第二个可选):第一个参数是作为新对象原型的对象，第二个是为新对象额外定义属性的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name:&quot;Tom&quot;,</span><br><span class="line">    frineds:[&quot;Jack&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var anotherPerson = Object.create(person,&#123;name&#123;</span><br><span class="line">    value:&quot;Jack&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用场景：只想让一个对象与另一个对象保持类似的情况，没必要创建构造函数。</p>
<h5 id="6-3-5-寄生式继承"><a href="#6-3-5-寄生式继承" class="headerlink" title="6.3.5 寄生式继承"></a>6.3.5 寄生式继承</h5><p>思想:创建一个仅用于封装继承过程的函数，该函数内部以某种方式来增强对象，然后再返回对象。</p>
<p>缺点：</p>
<p>代码示范:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original)&#123;</span><br><span class="line">    var clone = Object.create(original);</span><br><span class="line">    clone.sayHi = function()&#123;</span><br><span class="line">        alert(&quot;HI&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//不一定是Object.create 任何可以返回同original相同的新对象的函数都可以</span><br></pre></td></tr></table></figure>
<h5 id="6-3-6-寄生组合式继承-最理想"><a href="#6-3-6-寄生组合式继承-最理想" class="headerlink" title="6.3.6 寄生组合式继承(最理想)"></a>6.3.6 寄生组合式继承(最理想)</h5><p>解决了组合式继承调用两次超类型构造函数的问题</p>
<p>基本模式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(SubType,SuperType)&#123;</span><br><span class="line">    var prototype = Object.create(SuperType.prototype);</span><br><span class="line">    prototype.constructor = SubType;</span><br><span class="line">    SubType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//修改前面组合继承的例子</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;Red&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype = &#123;</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">    SuperType.call(this,name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType,SuperType);</span><br><span class="line"></span><br><span class="line">var subtype =new SubType(&quot;Tom&quot;,21)</span><br><span class="line"></span><br><span class="line">//成功继承超类型原型对象中的方法</span><br><span class="line">console.log(subtype.sayName());//Tom</span><br></pre></td></tr></table></figure>
<h2 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h2><h2 id="第八章-迭代器和生成器-ES6"><a href="#第八章-迭代器和生成器-ES6" class="headerlink" title="第八章  迭代器和生成器 ES6"></a>第八章  迭代器和生成器 ES6</h2><h3 id="8-1-迭代器-amp-amp-生成器"><a href="#8-1-迭代器-amp-amp-生成器" class="headerlink" title="8.1 迭代器&amp;&amp;生成器"></a>8.1 迭代器&amp;&amp;生成器</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>是一种特殊对象，具有一些专门为迭代过程设计的专有接口。</p>
<ul>
<li>next() 每次调用返回一个结果对象{value,done} value表示下一个将要返回的值，done在没有更多数据返回时为true。</li>
<li>一个内部指针 用来指向当前集合中值的位置</li>
</ul>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器是一种返回迭代器的函数，通过function关键字后的星号（*）来表示，会用到新的关键字yield。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = createIterator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，createIterator()前面的星号表明他是一个生成器，yield可以用来指定调用迭代器的next方法时返回值及返回顺序。</p>
<p>每当执行完一条yield语句后函数就会自动停止执行，直到再次调用迭代器的next()方法才会继续执行。</p>
<p>yield只能在生成器内部使用，在其他地方使用会导致程序抛出错误，生成器内部的函数也不行。</p>
<p><strong>其他创建方式</strong></p>
<ul>
<li>函数表达式  let createIterator = function *(items){}</li>
<li>生成器对象 let o ={ *createIterator(item){}}   let iterator = o.createIterator([1,2,3]);</li>
</ul>
<h3 id="8-2-可迭代对象和for-of循环"><a href="#8-2-可迭代对象和for-of循环" class="headerlink" title="8.2 可迭代对象和for-of循环"></a>8.2 可迭代对象和for-of循环</h3><p>可迭代对象具有symbol.iterator属性，是一种与迭代器密切相关的对象。</p>
<p>symbol.iterator通过指定的函数可以返回一个作用于附属对象的迭代器。</p>
<p>for-of循环每执行一次都会调用可迭代对象的next()方法，并将迭代器返回的结果对象的value属性存储在一个变量中，循环将持续执行这一过程直到返回对象的done属性的值为true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> values)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//依次输出1，2，3</span></span><br></pre></td></tr></table></figure>
<p>如果只需迭代数组或者集合中的值，用for-of循环代替for循环是个不错的选择。</p>
<h4 id="访问默认迭代器"><a href="#访问默认迭代器" class="headerlink" title="访问默认迭代器"></a>访问默认迭代器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> iterator = values[<span class="built_in">Symbol</span>.iterator]();</span><br></pre></td></tr></table></figure>
<p>由于具有symbol.iterator属性的对象都有默认的迭代器，因此可以用他来检测对象是否为可迭代对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">object</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] == <span class="string">"function"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建可迭代对象"><a href="#创建可迭代对象" class="headerlink" title="创建可迭代对象"></a>创建可迭代对象</h4><p>默认情况下，开发者定义的对象都是不可迭代对象，但可以通过给Symbol.iterator属性添加一个生成器，则可以将其变为可迭代对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = &#123;</span><br><span class="line">    items:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.items)&#123;</span><br><span class="line">    		<span class="keyword">yield</span> item;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> collection)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1,2,3</span></span><br></pre></td></tr></table></figure>
<h3 id="8-3-内建迭代器"><a href="#8-3-内建迭代器" class="headerlink" title="8.3 内建迭代器"></a>8.3 内建迭代器</h3><h4 id="集合对象迭代器"><a href="#集合对象迭代器" class="headerlink" title="集合对象迭代器"></a>集合对象迭代器</h4><p>ES6中有三种类型的集合对象：数组，Map集合，Set集合</p>
<p>这三种对象都内建了三种迭代器：</p>
<ul>
<li>entries() 返回一个迭代器，其值为多个键值对。</li>
<li>values() 返回一个迭代器，其值为集合的值。</li>
<li>keys() 返回一个迭代器，其值为集合中的所有键名</li>
</ul>
<h5 id="entries-迭代器"><a href="#entries-迭代器" class="headerlink" title="entries()迭代器"></a>entries()迭代器</h5><p>每次调用next方法，entries()迭代器都会返回一个数组，数组中的两个元素分别表示每个元素的键和值。</p>
<ul>
<li>数组：第一个元素是数字类型的索引，第二哥元素是数组值</li>
<li>set集合：第一个和第二个元素都是值</li>
<li>map集合，第一个元素为键名，第二个元素为键值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>,<span class="number">5678</span>,<span class="number">9012</span>]);</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">"title"</span>,<span class="string">"ES6"</span>);</span><br><span class="line">data.set(<span class="string">"format"</span>,<span class="string">"ebook"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> color.entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entrt);  <span class="comment">//[0,"red"] [1,"green"] [2,"blue"]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> tracking.entried())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entrt); <span class="comment">//[1234,1234] [5678,5678] [9012,9012]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> data.entried())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry);  <span class="comment">//["title","ES6"] ["format","ebook"]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="values-迭代器"><a href="#values-迭代器" class="headerlink" title="values()迭代器"></a>values()迭代器</h5><p>调用value()迭代器会返回集合中所存的所有值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>,<span class="number">5678</span>,<span class="number">9012</span>]);</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">"title"</span>,<span class="string">"ES6"</span>);</span><br><span class="line">data.set(<span class="string">"format"</span>,<span class="string">"ebook"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> color.values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);  <span class="comment">//"red" "green" "blue"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> tracking.values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">//1234 5678 9012</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> data.values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);  <span class="comment">//"ES6" "ebook"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="keys迭代器"><a href="#keys迭代器" class="headerlink" title="keys迭代器"></a>keys迭代器</h5><p>keys迭代器会返回集合中存在的每一个键</p>
<ul>
<li>数组：返回数字类型的键，数组本身的其他属性不会被返回</li>
<li>set集合：键与值相同，返回和values相同的迭代器</li>
<li>map集合：返回每个独立的键</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>,<span class="number">5678</span>,<span class="number">9012</span>]);</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">"title"</span>,<span class="string">"ES6"</span>);</span><br><span class="line">data.set(<span class="string">"format"</span>,<span class="string">"ebook"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">of</span> colors.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);   <span class="comment">//0 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">of</span> tracking.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);   <span class="comment">//1234,5678,9012</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">of</span> data.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);   <span class="comment">//"title" "format"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="不同集合类型的默认迭代器"><a href="#不同集合类型的默认迭代器" class="headerlink" title="不同集合类型的默认迭代器"></a>不同集合类型的默认迭代器</h5><p>每个集合类型都有一个默认的迭代器，在for-of循环中，如果没有显示指定则使用默认的迭代器。</p>
<p>数组和set组合的默认迭代器是values()方法，Map集合的默认迭代器是entries()方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1234</span>,<span class="number">5678</span>,<span class="number">9012</span>]);</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">"title"</span>,<span class="string">"ES6"</span>);</span><br><span class="line">data.set(<span class="string">"format"</span>,<span class="string">"ebook"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> color)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);  <span class="comment">//"red" "green" "blue"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> tracking)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);  <span class="comment">//1234 5678 9012</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> data)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry);  <span class="comment">//["title","ES6]  ["format","ebook"]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解构语法使map访问更简单</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [value,key] <span class="keyword">of</span> data)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value+<span class="string">","</span>+key)  <span class="comment">//"title,ES6"  "format,ebook"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符串迭代器"><a href="#字符串迭代器" class="headerlink" title="字符串迭代器"></a>字符串迭代器</h4><p>解决双字节字符问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"A 𠮷 B"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> message)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//(空)</span></span><br><span class="line"><span class="comment">//𠮷</span></span><br><span class="line"><span class="comment">//(空)</span></span><br><span class="line"><span class="comment">//B</span></span><br></pre></td></tr></table></figure>
<h4 id="NodeList迭代器"><a href="#NodeList迭代器" class="headerlink" title="NodeList迭代器"></a>NodeList迭代器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> div <span class="keyword">of</span> divs)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(div.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="展开运算符与非数组可迭代对象"><a href="#展开运算符与非数组可迭代对象" class="headerlink" title="展开运算符与非数组可迭代对象"></a>展开运算符与非数组可迭代对象</h4><p>展开运算符可以操作所有可迭代对象，并根据默认迭代器来选取要引用的值，从迭代器读取所有值，然后按照返回顺序将他们依次插入到数组中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]),</span><br><span class="line">    array = [...Set];</span><br><span class="line"><span class="built_in">console</span>.log(array);    <span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">"name"</span>,<span class="string">"Nicholas"</span>],[<span class="string">"ages"</span>,<span class="number">25</span>]]),</span><br><span class="line">    array = [...map];</span><br><span class="line"><span class="built_in">console</span>.log(array);   <span class="comment">//[["name","Nicholas"],["ages",25]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在数组字面量中可以多次使用展开运算符，将可迭代对象中的多个元素依次插入新数组中，替换原来展开运算符所在的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> smallNumber = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    bigNumber = [<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>],</span><br><span class="line">    allNumber = [<span class="number">0</span>,...smallNumber,...bigNumber];</span><br><span class="line"><span class="built_in">console</span>.log(allNumber.length); <span class="comment">//7</span></span><br><span class="line"><span class="built_in">console</span>.log(allNumber); <span class="comment">//[0,1,2,3,100,101,102]</span></span><br></pre></td></tr></table></figure>
<p>将可迭代对象转换为数组，最简单的方法就是使用展开运算符。可以将字符串中的每一个字符存入新数组中，可以刻将nodeList对象中的每一个节点存入新数组中。</p>
<h3 id="8-4-高级迭代器功能"><a href="#8-4-高级迭代器功能" class="headerlink" title="8.4 高级迭代器功能"></a>8.4 高级迭代器功能</h3><h4 id="给迭代器传递参数"><a href="#给迭代器传递参数" class="headerlink" title="给迭代器传递参数"></a>给迭代器传递参数</h4><p>如果给迭代器的next()方法传递参数，则这个参数的值就会替代生成器内部上一条yield语句的返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span>;   <span class="comment">//4+2</span></span><br><span class="line">    <span class="keyword">yield</span> second+<span class="number">3</span>;   <span class="comment">//5+3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">//&#123;value:1,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>)); <span class="comment">//&#123;value:6,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">5</span>)); <span class="comment">//&#123;value:8,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">//&#123;value:undefined,done:true&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="生成器返回语句"><a href="#生成器返回语句" class="headerlink" title="生成器返回语句"></a>生成器返回语句</h4><p>生成器也是函数，因此可以通过return语句提前退出函数执行。</p>
<p>在生成器中，return表示所有操作已经完成，属性done被设置为true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">//&#123;value:1,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());  <span class="comment">//&#123;value:42,done:true&#125;</span></span><br></pre></td></tr></table></figure>
<p>展开运算符与for-of循环语句会直接忽略通过return语句指定的任何返回值，因为只要done一变成true就立即停止读取其他的值。</p>
<h4 id="委托生成器"><a href="#委托生成器" class="headerlink" title="委托生成器"></a>委托生成器</h4><p>将两个迭代器合二为一，创建一个生成器，再给yield语句添加星号，就可以将生成数据的过程委托给其他迭代器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumberItetator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createColorIterator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"red"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"green"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> *createNumberIterator();</span><br><span class="line">    <span class="keyword">yield</span> *createColorIterator();</span><br><span class="line">    <span class="keyword">yield</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = createCombinedIterator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:1,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:2,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:"red",done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:"green",done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:true,done:false&#125;</span></span><br></pre></td></tr></table></figure>
<p>每一次调用next方法就会委托相应的迭代器生成相应的值，直到迭代器无法返回更多的值，此时执行最后一条yield语句并返回true。</p>
<h3 id="8-5-异步任务执行"><a href="#8-5-异步任务执行" class="headerlink" title="8.5 异步任务执行"></a>8.5 异步任务执行</h3><h4 id="8-5-1-简单任务执行器"><a href="#8-5-1-简单任务执行器" class="headerlink" title="8.5.1 简单任务执行器"></a>8.5.1 简单任务执行器</h4><p>yield语句会暂停当前函数的执行过程并等待下一次调用next()方法。因此可以创建一个函数，在函数中调用生成器生成相应的迭代器，从而可以不用回调函数实现异步调用next()。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> task = taskDef();</span><br><span class="line">    <span class="keyword">let</span> result = task.next();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环调用next()的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//如果任务未完成则继续执行</span></span><br><span class="line">        <span class="keyword">if</span>(!result.done)&#123;</span><br><span class="line">            result = task.next();</span><br><span class="line">            step();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>
<h4 id="8-5-2-像任务执行器传递数据"><a href="#8-5-2-像任务执行器传递数据" class="headerlink" title="8.5.2 像任务执行器传递数据"></a>8.5.2 像任务执行器传递数据</h4><p>传递数据最简单的方法是，把yield返回的值传入下一次next()方法的调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上述代码中修改传入的生成器函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span>); <span class="comment">//1</span></span><br><span class="line">    value = <span class="keyword">yield</span> value+<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">//4</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="8-5-3-异步任务执行器"><a href="#8-5-3-异步任务执行器" class="headerlink" title="8.5.3 异步任务执行器"></a>8.5.3 异步任务执行器</h4><p>等待异步过程时，任务执行器需要知晓回调函数是什么以及如何使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//返回一个异步函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                callback(<span class="literal">null</span>, <span class="string">"Hello"</span>);</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> task = taskDef();</span><br><span class="line">        <span class="keyword">let</span> result = task.next();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">                <span class="comment">//如果result.value是一个函数，则传入一个回调函数作为参数来调用</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span>  result.value === <span class="string">"function"</span>) &#123;</span><br><span class="line">                    result.value(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                            result = task.throw(err);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        result = task.next(data);</span><br><span class="line">                        step();</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="comment">//如果不是函数则直接把值传入next方法</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = task.next(result.value);</span><br><span class="line">                    step();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">        value = <span class="keyword">yield</span> fetchData();</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"world"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出  一秒钟后连续输出hello world</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以和循环配合，循环输出</span></span><br><span class="line"></span><br><span class="line">    run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">yield</span> fetchData(<span class="string">"hello"</span>+i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="第十章-DOM"><a href="#第十章-DOM" class="headerlink" title="第十章 DOM"></a>第十章 DOM</h2><p>DOM(文档对象模型)是针对HTML和XML文档的一个API（应用程序编程接口）</p>
<h3 id="10-1-节点层次"><a href="#10-1-节点层次" class="headerlink" title="10.1 节点层次"></a>10.1 节点层次</h3><p>DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构</p>
<h4 id="10-1-1-Node类型"><a href="#10-1-1-Node类型" class="headerlink" title="10.1.1 Node类型"></a>10.1.1 Node类型</h4><p>每个节点都有一个nodeType属性，用于表明节点的类型</p>
<h5 id="nodeName和nodeValue属性"><a href="#nodeName和nodeValue属性" class="headerlink" title="nodeName和nodeValue属性"></a><strong>nodeName和nodeValue属性</strong></h5><p>这两个属性的值完全取决于节点的类型</p>
<h5 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a><strong>节点关系</strong></h5><p>节点间的各种关系可以用传统的家族关系来描述：在html中，可以将body看成是html的子元素，html是body的父元素；body是head的同胞元素。</p>
<ul>
<li><p>每个节点都有一个<strong>childNodes</strong>属性，其中保存着一个NodeList对象（NodeList是一个类数组对象，并不是Array的实例，独特之处在于他是基于DOM结构动态执行查询的结果，能够自动反应DOM结构的变化）</p>
<pre><code>访问方式： 
</code></pre></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstChild = someNode.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> secondChild = someNode.childNodes.item(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> count = someNode.childNodes.length;<span class="comment">//表示的是访问这一刻NodeList包含的节点数量</span></span><br></pre></td></tr></table></figure>
<p>可以通过<strong>Aarray.prototype.slice()</strong>方法将NodeList转化为数组（IE8以下不支持)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">covertToArray</span>(<span class="params">nodes</span>)</span>&#123;</span><br><span class="line">  	 <span class="keyword">var</span> array = <span class="literal">null</span>;</span><br><span class="line">  	 <span class="keyword">try</span>&#123;</span><br><span class="line">       	array = <span class="built_in">Array</span>.prototype.slice.call(nodes);</span><br><span class="line">  	 &#125;<span class="keyword">catch</span>(ex)&#123;</span><br><span class="line">       	array = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">       	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;nodes.length;i++)&#123;</span><br><span class="line">           array.push(nodes[i]);</span><br><span class="line">       	&#125;       </span><br><span class="line">    	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>每个节点都有一个<strong>parent</strong>属性，指向文档树中的父节点</p>
<p>包含在childerNodes列表中的每个节点之间都是同袍节点，可以用<strong>previousSibling</strong>和<strong>nextSlibing</strong>来访问邻近的节点。</p>
<p>父节点的<strong>firstChild</strong>和<strong>lastChild</strong>属性分别指向childNodes列表中的第一个和最后一个子节点</p>
</li>
<li><p><strong>hasChildNodes()</strong></p>
<p>这个方法在包含一个或多个子节点的情况下返回true</p>
</li>
<li><p><strong>ownerDocument</strong>属性指向表示整个文档的文档节点，可以不用层层回溯直接访问文档节点</p>
</li>
</ul>
<h5 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h5><ul>
<li><p><strong>appendChild()</strong> 向childNodes列表的末尾添加一个节点，返回值是新增的节点</p>
<p>参数：要添加的节点</p>
<p>返回：添加的新节点</p>
<p><em>注意：任何DOM节点不能同时出现在文档的多个位置</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> returnedNode = someNode.appendChild(newNode);</span><br><span class="line">alert(returnedNode == newNode); <span class="comment">//true</span></span><br><span class="line">alert(someNode.lastChild == newNode); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果appendChild()传入了父节点的第一个节点，那么这个节点就会成为父节点的最后一个节点</span></span><br><span class="line"><span class="keyword">var</span> resurnedNode = someNode.appendChild(someNode.firstChild);</span><br><span class="line">alert(returnedNode == someNode.firstChild); <span class="comment">//false</span></span><br><span class="line">alert(returnedNode == someNode.lastChild);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>insertBefore()</strong>  把节点放入childNodes列表中某个特定的位置上</p>
<p>参数:要插入的节点，参照节点</p>
<p>返回：要插入的节点</p>
<p>插入节点后，要插入的节点会成为参照节点的previousSibling</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入后成为第一个节点</span></span><br><span class="line">returnedNode = someNode.insertBefore(node,someNode.firstNode);</span><br><span class="line">alert(returnedNode == someNode.firstNode) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>replaceChild</strong> 替换节点</p>
<p>参数：要插入的节点，被替换的节点</p>
<p>返回：被替换的节点</p>
<p>要替换的节点被从文档树中移除，被要插入的节点替换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换第一个节点</span></span><br><span class="line">returnedNode = someNode.replaceChild(newNode,someNode.firstChild);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>removeChild</strong> 移除节点</p>
<p>参数：要移除的节点</p>
<p>返回：被移除的节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除最后一个节点</span></span><br><span class="line">returnedNode = someNode.removeChild(someNode.lastChild)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="一些其他方法"><a href="#一些其他方法" class="headerlink" title="一些其他方法"></a>一些其他方法</h5><ul>
<li><p><strong>cloneNode</strong> 创建调用这个方法的节点的一个完全相同的副本</p>
<p>参数：一个布尔值参数 </p>
<pre><code>true:执行深复制，复制节点及其整个子节点树

false:执行浅复制，只复制节点本身
</code></pre><p>返回：复制好的副本</p>
<p><em>注意：这个方法不会复制添加到DOM节点的js属性，如时间处理程序等</em></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--假设已经将ul元素的引用保存在了变量myList中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> deepList = myList.cloneNode(<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">    alert(deepList.childNodes.length); <span class="comment">//3</span></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> shallowList = myList.cloneNode(<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">    alert(shallowList.childNodes.length); <span class="comment">//0</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>normalize() 处理文档树中的文本节点（后面补充）</p>
</li>
</ul>
<h4 id="10-1-2-Document类型"><a href="#10-1-2-Document类型" class="headerlink" title="10.1.2 Document类型"></a>10.1.2 Document类型</h4><p>JS通过Document类型表示文档。</p>
<p>document对象是HTMLDocument的一个实例，表示整个HTML界面。</p>
<p>document对象是window对象的一个属性，可以作为全局对象来访问</p>
<p><strong>Document节点具有以下特征：</strong></p>
<ul>
<li>nodeType的值为9</li>
<li>nodeName的值为”#document“</li>
<li>nodeValue的值为null</li>
<li>parentNode的值为null</li>
<li>owenerDocument的值为null</li>
</ul>
<h5 id="document的子节点"><a href="#document的子节点" class="headerlink" title="document的子节点"></a>document的子节点</h5><ul>
<li><p><strong>documentElement</strong> 属性   始终指向html页面中的html元素</p>
<p>document的documentElement属性，firstChild属性，以及childNodes[0]都指向html</p>
</li>
<li><p><strong>body</strong> 属性   指向body元素</p>
</li>
<li><p><strong>doctype</strong> 属性   指向&lt;!DOCTYPE&gt;标签</p>
</li>
</ul>
<h5 id="document的属性"><a href="#document的属性" class="headerlink" title="document的属性"></a>document的属性</h5><ul>
<li><p><strong>title</strong>属性：包含着<title>元素中的文本  可以获得当前页面的标题，也可以修改</title></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> originalTitle = <span class="built_in">document</span>.title;</span><br><span class="line"><span class="built_in">document</span>.title = <span class="string">"New page title"</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>URL</strong> <strong>domain</strong> <strong>referrer</strong></p>
<p>URL:保存页面完整的URL</p>
<p>domain:只包含页面的域名</p>
<p>referrer:链接到当前页面的页面的URL（没有来源页面的情况下，可能包含空字符串）</p>
</li>
</ul>
<h5 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h5><ul>
<li><p><strong>document.getElementById()</strong></p>
<p>参数：要取得的元素的ID</p>
<p>返回：返回要取得的元素，如果没有该元素则返回NULL</p>
</li>
<li><p><strong>document.getElementsByTagName()</strong> </p>
<p>参数：要取得元素的标签名</p>
<p>返回：HTML文档中返回一个HTMLCollection对象，对象中的元素数量可以通过length属性取得</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> images = ducoment.getElementsByTagName(<span class="string">"img"</span>);</span><br><span class="line">alert(images.length);</span><br><span class="line">alert(images[<span class="number">0</span>].src);</span><br><span class="line">alert(images.item(<span class="number">0</span>).src);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTMLCollection对象方法:namedItem() 可以通过name特性取得集合中的项</span></span><br><span class="line"><span class="comment">//假设页面中包含如下img元素</span></span><br><span class="line">&lt;img src=<span class="string">"myImage.gif"</span> name=<span class="string">"myImage"</span>&gt;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> myImage = images.namedItem(<span class="string">"myImage"</span>);</span><br><span class="line"><span class="keyword">var</span> myImage = images[myImage] <span class="comment">//也支持按名称访问</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>getElementsByName()</strong>  </p>
<p>参数：name值</p>
<p>返回：带有给定name特性的所有元素</p>
</li>
</ul>
<h5 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h5><p> document对象还有一些特殊的集合，这些特殊的集合都是HTMLCollection对象，为访问文档常用的部分提供了快捷方式</p>
<ul>
<li>document.anchors  包含文档中所有带name特性的<a>元素</a></li>
<li>document.forms      包含文档中所有的form元素</li>
<li>document.images    包含文档中所有的Image元素</li>
<li>document.links         包含文档中所有带href的a元素</li>
</ul>
<h5 id="一致性检测"><a href="#一致性检测" class="headerlink" title="一致性检测"></a>一致性检测</h5><h5 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h5><h4 id="10-1-3-Element类型"><a href="#10-1-3-Element类型" class="headerlink" title="10.1.3 Element类型"></a>10.1.3 Element类型</h4><p>Element类型用于表现XML或HTML元素，提供了对元素标签名，子节点以及特性的访问。</p>
<p>具有以下特性：</p>
<ul>
<li>nodeType的值为1</li>
<li>nodeName的值为元素的标签名</li>
<li>nodeValue的值为null</li>
<li>parentNode可能是Document或Element</li>
<li>其子节点可能是Element,Text,Comment,ProcessingInstruction,CDATASection或EntityReference</li>
</ul>
<p>nodeName和tagName都会返回元素的标签名</p>
<h5 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h5><p>所有的HTML元素都由HTMLElement类型的子类型来表示。该类型直接继承Element并添加了一下属性。</p>
<p>添加的这些属性分别对应于每个HTML元素中都存在的标准特性：</p>
<ul>
<li>id 元素在文档中的唯一标识符</li>
<li>title 有关元素的附加信息</li>
<li>lang 元素内容的语言代码</li>
<li>dir 语言的方向（ltr rtl)</li>
<li>className 对应元素的class属性</li>
</ul>
<h5 id="取得特性"><a href="#取得特性" class="headerlink" title="取得特性"></a>取得特性</h5><p>操作特性的三个主要方法:<strong>getAttribute()、setAttribute()、removeAttribute()</strong></p>
<p>这三个方法可以针对任何特性使用，包括自定义特性。</p>
<p>取得特性是：<strong>getAttribute()</strong>  </p>
<ul>
<li>参数：特性名称（id,class,title,lang或自定义特性）</li>
<li>返回：特性值</li>
</ul>
<p>有两类特殊的特性，属性的值与通过getAttribute返回的值不相同：style,onclick</p>
<h5 id="设置特性-amp-amp-删除特性"><a href="#设置特性-amp-amp-删除特性" class="headerlink" title="设置特性&amp;&amp;删除特性"></a>设置特性&amp;&amp;删除特性</h5><p><strong>setAttribute()</strong></p>
<ul>
<li>参数：要设置的特性名，特性值</li>
<li>如果特性已经存在会用特性值替换已有的值，如果不存在就创建特性并设定相应的值</li>
</ul>
<p>所有的特性都是属性，也可以直接给属性赋值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div.id = <span class="string">"someOtherId"</span></span><br><span class="line">div.align = <span class="string">"left"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是通过赋值添加新的自定义属性,属性不会成为元素的特性</span></span><br><span class="line">div.mycolor = <span class="string">"red"</span></span><br><span class="line">alert(div.getAttribute(<span class="string">"mycolor"</span>))  <span class="comment">//null</span></span><br></pre></td></tr></table></figure>
<p><strong>removeAttribute()</strong></p>
<p>不仅会清除特性的值，也会从元素中完全删除特性。</p>
<h5 id="arrtibute属性"><a href="#arrtibute属性" class="headerlink" title="arrtibute属性"></a>arrtibute属性</h5><p>Element类型是使用attribute属性的唯一一个DOM节点类型。</p>
<p>attribute属性中包含一个NameNodeMap,与NodeList类似，也是一个动态的集合。<strong>元素中的每一个特性都由一个Arrt节点表示，每个节点的nodeName就是特性的名称，而节点的nodeValue就是特性的值。</strong>每个节点都保存在NameNodeMap对象中。该对象拥有下列方法：</p>
<ul>
<li>getNamedItem(name):返回nodeName属性等于name的节点</li>
<li>removeNamedItem(name):从列表中移除nodeName属性等于name的节点</li>
<li>setNamedItem(node):像列表中添加节点，以节点的nodeName属性为索引</li>
<li>item(pos)：返回位于数字pos位置的节点</li>
</ul>
<p>取得元素的id特性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = element.attributes.getNamedItem(<span class="string">"id"</span>).nodeValue;</span><br><span class="line"><span class="keyword">var</span> id =element.attributes[<span class="string">"id"</span>].nodeValue;</span><br></pre></td></tr></table></figure>
<p>给id特性设置新值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.attributes[<span class="string">"id"</span>].nodeValue = <span class="string">"someOtherId"</span>;</span><br></pre></td></tr></table></figure>
<p>删除特性</p>
<p>调用removeNamedItem()和在元素上调用removeAttribute()的效果相同，直接删除具有给定名称的特性。</p>
<p>但是removeNamedItem()会返回表示被删除特性的Attr节点。</p>
<p>一般来说，操作element特性时更多的使用getAttribute(),removeAttribute(),setAttribute()这三个方法</p>
<p>但是遍历元素特性时，attributes属性就会比较有用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>,ien = element.attributes.length;i&lt;len;i++)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h5><p>方法：document.createElement()</p>
<p>参数：要创建元素的标签名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个div元素</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line"><span class="comment">//可以操作新创建的元素，为他添加更多的子节点</span></span><br><span class="line">div.id = <span class="string">"myNewDiv"</span>;</span><br><span class="line">div.className = <span class="string">"box"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在新元素上设置特性只是赋予相应的信息，还未添加到文档树中，要显示在浏览器中，必须要添加到文档树中</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line"><span class="comment">//或者使用insertBefore,replaceChild</span></span><br></pre></td></tr></table></figure>
<h5 id="元素的子节点"><a href="#元素的子节点" class="headerlink" title="元素的子节点"></a>元素的子节点</h5><p>元素可以有任意数目的子节点和后代节点，因为元素可以是其他元素的子节点。</p>
<p>元素的childNodes属性包含了它的所有子节点，这些子节点有可能是元素，文本节点，注释或者处理指令。</p>
<p>不同的浏览器看待节点方面存在着显著的不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"myList"</span>&gt;</span><br><span class="line">    &lt;li&gt;Item <span class="number">1</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Item 2&lt;/</span>li&gt;</span><br><span class="line">	&lt;li&gt;Item <span class="number">3</span>&lt;<span class="regexp">/li&gt;  </span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>
<p>上述代码在IE中，<ul>元素会有3个子节点，分别是3个<li>元素。</li></ul></p>
<p>在其他浏览器中，<ul>元素有7个子节点，分别是3个<li>元素，以及<ul>和<li>之间的2个空白符,</li><li></li><li>之间的2个空白符。</li></ul></li></ul></p>
<p>所以如果需要在元素类型的子节点上进行某些操作，要先检查一下nodeType属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len = element.childrenNodes.length;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(element.childrenNodes[i].nodeType == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//需要执行的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以通过特定的标签名来取得子节点或者后代节点，使用<strong>getElementsByTagName()</strong></p>
<p>除了搜索节点是当前元素外，其他都跟通过document调用相同。因此也会只返回符合条件的当前元素的后代。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得ul元素包含的所有li元素</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"myList"</span>);</span><br><span class="line"><span class="keyword">var</span> li = ul.getElementsByTagName(<span class="string">"li"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="10-1-4-Text类型"><a href="#10-1-4-Text类型" class="headerlink" title="10.1.4  Text类型"></a>10.1.4  Text类型</h4><p>包含可以按照字面解释的纯文本内容，可以包含转义后的HTML字符，但是不能包含HTML代码</p>
<p><strong>text节点具有以下特征：</strong></p>
<ul>
<li>nodeType的值为3</li>
<li>nodeName的值为”#text“</li>
<li>nodeValue的值为节点所包含的文本</li>
<li>parentNode是一个Element</li>
<li>不支持没有子节点</li>
</ul>
<p>nodeValue和data属性都可以访问文本节点中的文本</p>
<p><strong>节点操作方法</strong></p>
<ul>
<li>appendValue(text):将text添加到节点末尾</li>
<li>deleteDate(offset,count) ：从offset指定的位置开始删除count个字符</li>
<li>insertData(offset,text)：在offset指定的位置插入text</li>
<li>replaceData(offset,count,text)：用text替换从offset指定的位置开始到offset+count为止处的文本</li>
<li>splitText(offset)：从offset指定的位置将当前文本分成两个文本节点</li>
<li>substringData(offset,count)：提取从offset指定的位置开始到offset+count为止处的字符串</li>
</ul>
<p>文本节点还有一个length属性，保存着节点中字符的数目</p>
<p>nodeValue.length和data.length中也保存着相同的值。</p>
<h5 id="创建文本节点"><a href="#创建文本节点" class="headerlink" title="创建文本节点"></a>创建文本节点</h5><p>方法：document.createTextNode()</p>
<p>参数：要插入节点中的文本（按照HTML或XML的格式进行编码）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"&lt;strong&gt;Hello&lt;/strong&gt; world"</span>);</span><br></pre></td></tr></table></figure>
<p>要将新节点添加到文档树中已经存在的节点中才能使新节点在浏览器中展示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">element.className = <span class="string">"message"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world"</span>);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br></pre></td></tr></table></figure>
<h5 id="规范化文本节点"><a href="#规范化文本节点" class="headerlink" title="规范化文本节点"></a>规范化文本节点</h5><p>DOM文档中存在相邻的同胞文本节点很容易导致混乱，因此产生了一个能够将相邻文本节点合并的方法。</p>
<p>这个方法是：<strong>normalize()</strong> ，由Node类型定义，因此所有节点类型都存在该方法</p>
<p>如果在含有一个或多个文本节点的父元素上调用这个方法，则会将所有的文本节点合并成一个节点，节点的nodeValue等于将合并前每个文本节点的nodeValue值拼接起来的值。</p>
<p><em>浏览器在解析文档时永远不会创建相邻的文本节点，只有在执行DOM操作时会出现</em></p>
<h5 id="分割文本节点"><a href="#分割文本节点" class="headerlink" title="分割文本节点"></a>分割文本节点</h5><p>Text类型提供了一个作用跟normalize()相反的方法：<strong>splitText()</strong></p>
<p>这个方法会将一个文本节点分成两个文本节点</p>
<p>原来的节点包含从开始到指定位置之前的内容，新文本节点包含剩下的文本，返回新文本节点。新文本节点个原节点的parentNode相同</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">element.className = <span class="string">"message"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello World"</span>);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newNode = element.firstChild.splitText(<span class="number">5</span>);</span><br><span class="line">alert(element.firstChild.nodeValue); <span class="comment">//Hello</span></span><br><span class="line">alert(newNode.nodeValue); <span class="comment">//World</span></span><br><span class="line">alert(element.childrenNodes.length);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h4 id="10-1-5-Attr类型"><a href="#10-1-5-Attr类型" class="headerlink" title="10.1.5  Attr类型"></a>10.1.5  Attr类型</h4><p>区分特性（attribute）和属性（property）：</p>
<p>元素的特性在DOM中以attr来表示，从技术角度讲，特性就是存在于元素的attributes属性中的节点。</p>
<p>特性用来描述属性</p>
<p>Attr对象有3个属性：name,value,specified</p>
<p>name：特性名称（与nodeName的值相同）</p>
<p>value:   特性的值   (与nodeValue的值相同)</p>
<p>specified：一个布尔值，用以区别特性是在代码中指定的还是默认的。</p>
<h3 id="10-2-DOM操作技术"><a href="#10-2-DOM操作技术" class="headerlink" title="10.2 DOM操作技术"></a>10.2 DOM操作技术</h3><h4 id="10-2-1-动态脚本"><a href="#10-2-1-动态脚本" class="headerlink" title="10.2.1 动态脚本"></a>10.2.1 动态脚本</h4><p>动态脚本指的是：在页面加载时不存在，但将来的某一时刻通过修改DOM动态添加的脚本</p>
<h4 id="10-2-2-动态样式"><a href="#10-2-2-动态样式" class="headerlink" title="10.2.2 动态样式"></a>10.2.2 动态样式</h4><h4 id="10-2-3-操作表格"><a href="#10-2-3-操作表格" class="headerlink" title="10.2.3 操作表格"></a>10.2.3 操作表格</h4><h4 id="10-2-4-使用nodeList"><a href="#10-2-4-使用nodeList" class="headerlink" title="10.2.4 使用nodeList"></a>10.2.4 使用nodeList</h4><h2 id="第十一章-DOM扩展"><a href="#第十一章-DOM扩展" class="headerlink" title="第十一章  DOM扩展"></a>第十一章  DOM扩展</h2><p>两个主要的扩展是：Selectors API 和 HTML5</p>
<h3 id="11-1-选择符API"><a href="#11-1-选择符API" class="headerlink" title="11.1 选择符API"></a>11.1 选择符API</h3><p>Selectors API是由W3C发起指定的标准，致力于让浏览器原生支持CSS查询。这样一来，解析和树查询操作可以在浏览器内部通过编译后的代码来完成，极大地改善了性能。(jquery就是通过css选择符查询DOM获得文档的应用)</p>
<p>两个核心方法：querySelector()和querySelectorAll()。在兼容的浏览器中，可以通过Document及Element类型的实例来调用。</p>
<h4 id="11-1-1-querySelector"><a href="#11-1-1-querySelector" class="headerlink" title="11.1.1 querySelector()"></a>11.1.1 querySelector()</h4><p>方法：document(element).querySelector()</p>
<p>参数：css选择符</p>
<p>返回：与该模式匹配的第一个元素，没有找到则返回null</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">"body"</span>);<span class="comment">//取得body元素</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.querySelector(<span class="string">"#myDiv);//取得ID为myDiv的元素</span></span><br><span class="line"><span class="string">var select = document.querySelector("</span>.selected<span class="string">")//取得class为selected的第一个元素</span></span><br><span class="line"><span class="string">var img = myDiv.querySelector("</span>img.button<span class="string">") //取得myDiv子代中第一个class为button的img元素</span></span><br></pre></td></tr></table></figure>
<h4 id="11-1-2-querySelectorAll"><a href="#11-1-2-querySelectorAll" class="headerlink" title="11.1.2 querySelectorAll()"></a>11.1.2 querySelectorAll()</h4><p>方法：document(element).querySelectorAll()</p>
<p>参数：css选择符</p>
<p>返回：返回一个nodeList对象，包含匹配的元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ems = <span class="built_in">document</span>.querySelector(<span class="string">"myDiv"</span>).querySelectorAll(<span class="string">"em"</span>) <span class="comment">//取得myDiv中的所有em元素</span></span><br><span class="line"><span class="keyword">var</span> selecteds = <span class="built_in">document</span>.querySelectorALL(<span class="string">".selected"</span>) <span class="comment">//取得所有class为selected的元素</span></span><br><span class="line"><span class="keyword">var</span> strongs = <span class="built_in">document</span>.querySelectorAll(<span class="string">"p strong"</span>) <span class="comment">//取得所有p元素的strong元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取得返回nodeList中的每一个元素</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>,len = strongs.length;i&lt;len;i++)&#123;</span><br><span class="line">    strong = strongs[i] <span class="comment">//或者strong.item(i)</span></span><br><span class="line">    <span class="comment">//执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-1-3-matchedSelector"><a href="#11-1-3-matchedSelector" class="headerlink" title="11.1.3 matchedSelector()"></a>11.1.3 matchedSelector()</h4><p>为Element类型新增的方法</p>
<p>方法：element.matchedSelector()</p>
<p>参数：css选择符</p>
<p>返回：ture,flase; 如果调用元素与选择符匹配则返回ture，否则返回fasle</p>
<h3 id="11-2-元素遍历（不包含空白文本节点）"><a href="#11-2-元素遍历（不包含空白文本节点）" class="headerlink" title="11.2 元素遍历（不包含空白文本节点）"></a>11.2 元素遍历（不包含空白文本节点）</h3><p>对于元素空格，IE9及之前不会返回文本节点，其他浏览器都会。为了弥补这一差异，E定义了一组新的属性。</p>
<p>添加了以下五个属性：</p>
<ul>
<li>childElementCount:返回子元素（不包括文本节点和注释）的个数</li>
<li>firstElementChild:指向第一个元素</li>
<li>lastElementChild:指向最后一个元素</li>
<li>previousElementSibling:指向前一个同胞元素</li>
<li>nextElementSibling:指向后一个同胞元素</li>
</ul>
<p>这些属性返回的元素都不包含空白文本节点</p>
<p>遍历所有子元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i,len,child = element.firstElementChild;</span><br><span class="line"><span class="keyword">while</span>(child!=element.lastElementChild)&#123;</span><br><span class="line">    <span class="comment">//某些操作</span></span><br><span class="line">    child = child.nextElementSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-3-HTML5"><a href="#11-3-HTML5" class="headerlink" title="11.3 HTML5"></a>11.3 HTML5</h4><h4 id="11-3-1-与类相关的扩充"><a href="#11-3-1-与类相关的扩充" class="headerlink" title="11.3.1  与类相关的扩充"></a>11.3.1  与类相关的扩充</h4><p>新增了很多致力于简化CSS类的用法</p>
<h5 id="getElementsByClassName-方法"><a href="#getElementsByClassName-方法" class="headerlink" title="getElementsByClassName() 方法"></a>getElementsByClassName() 方法</h5><p>方法：getElementsByClassName()</p>
<p>参数：一个包含一或多个类名的字符串</p>
<p>返回：带有指定类的所有元素的NodeList</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得所有类中包含“username"和”current"的元素</span></span><br><span class="line"><span class="keyword">var</span> allCurrentUsernames = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"username current"</span>);</span><br><span class="line"><span class="comment">//取得ID为"myDiv"的元素中带有类名"selectd"的所有元素</span></span><br><span class="line"><span class="keyword">var</span> selectd = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).getElementsByClassName(<span class="string">"selected"</span>);</span><br></pre></td></tr></table></figure>
<h5 id="classList-属性"><a href="#classList-属性" class="headerlink" title="classList 属性"></a>classList 属性</h5><p>操作类名时，通过className属性添加，删除和替换类名。但是因为className是一个字符串，所以即使只是修改字符串一部分也必须都设置整个字符串的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个div元素一共有三个类名，要从中删除一个类名需要把三个类名拆开，然后删除再拼接</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"bd user disabled"</span>&gt;....&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>HTML5为所有元素添加classList属性以便操作类名。有包含多少元素的length属性，取得每个元素可以使用item()方法，也可以使用方括号[]。</p>
<p>新类型定义的方法如下：</p>
<ul>
<li>add(value):将给定的字符串添加到列表中</li>
<li>contains(value):表示列表中是否存在给定的值，如果存在则返回true，否则返回false</li>
<li>remove(value)：从列表中删除给定的字符</li>
<li>toggle(value)：如果列表中存在给定的值，删除它；如果列表中没有给定的值，添加它</li>
</ul>
<p>比如从上面的div元素中删除user类</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.classList.remove(<span class="string">"user"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="11-3-2-焦点管理"><a href="#11-3-2-焦点管理" class="headerlink" title="11.3.2 焦点管理"></a>11.3.2 焦点管理</h4><p>新增document.activeElement属性，这个属性始终会引用DOM中当前获得了焦点的元素（页面加载，用户输入，代码调用focus）。</p>
<p>默认情况下，文档刚加载完这个属性保存的是document.body元素，加载期间，这个属性的值为null。</p>
<p>新增方法：document.hasFocus()，用于确定文档是否获得了焦点。</p>
<h4 id="11-3-3-HEMLDocument的变化"><a href="#11-3-3-HEMLDocument的变化" class="headerlink" title="11.3.3 HEMLDocument的变化"></a>11.3.3 HEMLDocument的变化</h4><h5 id="readyState属性"><a href="#readyState属性" class="headerlink" title="readyState属性"></a>readyState属性</h5><p>两个可能的值：</p>
<ul>
<li>loading:正在加载文档</li>
<li>complete:已经加载完文档</li>
</ul>
<p>应用：实现一个指定文档已经加载完的指示器。</p>
<p>在这个属性之前，必须借助onload时间处理程序设置一个标签来表明文档已经加载完毕。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.readyState == <span class="string">"complete"</span>)&#123;</span><br><span class="line">    <span class="comment">//执行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-3-4-自定义数据属性"><a href="#11-3-4-自定义数据属性" class="headerlink" title="11.3.4 自定义数据属性"></a>11.3.4 自定义数据属性</h4><p>HTML5规定可以为元素添加非标准的属性，但是要添加前缀data-。目的是为元素提供与渲染无关的信息，或者提供语义信息。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">data-appID</span>=<span class="string">"12345"</span> <span class="attr">data-mynane</span>=<span class="string">"Jack"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以通过元素的dataset属性来访问自定义数据属性。dataset属性的值是DOMStringMap的一个实例，是一个名值对的映射。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"><span class="keyword">var</span> appId = div.dataset.appID;</span><br><span class="line"><span class="keyword">var</span> myname = div.dataset.myname;</span><br><span class="line">alert(<span class="string">"hello,"</span>+appid+myname);<span class="comment">//hello,12345Jack</span></span><br><span class="line"></span><br><span class="line">也可以修改值</span><br><span class="line">div.dataset.appID=<span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<h3 id="11-4-一些专有扩展"><a href="#11-4-一些专有扩展" class="headerlink" title="11.4 一些专有扩展"></a>11.4 一些专有扩展</h3><h2 id="第十二章-DOM2和DOM3"><a href="#第十二章-DOM2和DOM3" class="headerlink" title="第十二章 DOM2和DOM3"></a>第十二章 DOM2和DOM3</h2><h3 id="12-1-DOM变化"><a href="#12-1-DOM变化" class="headerlink" title="12.1 DOM变化"></a>12.1 DOM变化</h3><h3 id="12-2-DOM操作样式"><a href="#12-2-DOM操作样式" class="headerlink" title="12.2 DOM操作样式"></a>12.2 DOM操作样式</h3><p>DOM级样式提供了一套API来操作样式。</p>
<h4 id="12-2-1-访问元素的样式"><a href="#12-2-1-访问元素的样式" class="headerlink" title="12.2.1 访问元素的样式"></a>12.2.1 访问元素的样式</h4><p>任何支持style特性的HTML元素在javascript中都有一个对应的style属性。在style特性中指定的任何CSS属性都将表现为这个style对象的相应属性。</p>
<p>style对象不包含与外部样式表或嵌入样式表经层叠而来的样式。</p>
<p>js访问时，对于使用短划线的css属性，必须将其转换为驼峰大小写形势</p>
<table>
<thead>
<tr>
<th>CSS属性</th>
<th>JavaScript属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>background-imgae</td>
<td>style.backgroundImage</td>
</tr>
<tr>
<td>color</td>
<td>style.color</td>
</tr>
<tr>
<td>display</td>
<td>style.display</td>
</tr>
<tr>
<td>font-family</td>
<td>style.fontFamily</td>
</tr>
</tbody>
</table>
<p>多数情况下都可以通过转换属性名的格式来实现转换，但是css属性float不能，因为float是javascript的保留字，不能用作属性名。DOM2规范规定相应属性名为cssFloat，大部分浏览器都支持，但是IE支持的是styleFloat。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置样式</span></span><br><span class="line">myDiv.style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line">myDiv.style.border=<span class="string">"1px solid red"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取样式</span></span><br><span class="line">alert(myDiv.style.background) <span class="comment">//red;</span></span><br></pre></td></tr></table></figure>
<h5 id="DOM样式属性和方法"><a href="#DOM样式属性和方法" class="headerlink" title="DOM样式属性和方法"></a>DOM样式属性和方法</h5><p>为style对象定义了一些方法和属性：</p>
<ul>
<li>cssText:访问到style特性中的css代码</li>
<li>length:应用给元素的css属性的数量</li>
<li>parentRule:表示css信息的CSSRule对象</li>
<li>getPropertyCSSValue(propertyName):返回包含给定属性值的CSSValue对象（CSSValue对象包含两个属性：cssText,cssValueType。cssText属性的值和getPropertyValue()返回的值相同；cssValueType属性的值是一个数据常量，表示值的类型：0表示继承的值，1表示基本的值，2表示值列表，3表示自定义的值）</li>
<li>getPropertyPriority(propertyName):如果给定的属性使用了!important设置，返回”important”，否则返回空字符串</li>
<li>getPropertyValue(propertyName):返回给定属性的字符串值</li>
<li>item(index):返回给定位置的css属性的名称</li>
<li>removeProperty(propertyName):从样式中删除给定属性</li>
<li>setProperty(propertyName,value,priority):将给定属性设置为相应的值，并加上优先权标志(important或空字符串）</li>
</ul>
<h5 id="计算的样式"><a href="#计算的样式" class="headerlink" title="计算的样式"></a>计算的样式</h5><p>document.defaultView提供了getComputedStyle()方法</p>
<p>方法：getComputedStyle()</p>
<p>参数：要计算样式的元素，一个伪元素字符串（不选为null）</p>
<p>返回：一个CSSStyleDeclaration对象（与style属性的类型相同），包含当前元素的所有计算的样式</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span> = <span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.myDiv</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv1"</span> <span class="attr">class</span>=<span class="string">"myDiv"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv2"</span> <span class="attr">class</span>=<span class="string">"myDiv"</span> <span class="attr">style</span>=<span class="string">"background-color:red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> myDiv1 = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv1"</span>); </span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(myDiv1.style.width) <span class="comment">//"" undifined 无法访问到嵌入样式表的样式</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> computedStyle = <span class="built_in">document</span>.defaultView.getComputedStyle(myDiv1,<span class="literal">null</span>);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(computedStyle.width); <span class="comment">//100px</span></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> myDiv2 = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv2"</span>); </span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(myDiv1.style.backgroundColor); <span class="comment">//red</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(myDiv1.style.width); <span class="comment">//undefined</span></span></span><br><span class="line"><span class="undefined">   </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="12-2-2-操作样式表"><a href="#12-2-2-操作样式表" class="headerlink" title="12.2.2 操作样式表"></a>12.2.2 操作样式表</h4><h4 id="12-2-3-元素大小"><a href="#12-2-3-元素大小" class="headerlink" title="12.2.3 元素大小"></a>12.2.3 元素大小</h4><h3 id="12-3-遍历"><a href="#12-3-遍历" class="headerlink" title="12.3 遍历"></a>12.3 遍历</h3><p>NodeIterator和TreeWalker</p>
<p>深度优先的遍历</p>
<h3 id="12-4-范围"><a href="#12-4-范围" class="headerlink" title="12.4 范围"></a>12.4 范围</h3><p>##第十三章 事件</p>
<p>JavaScript与HTML之间的交互式通过事件来实现的。</p>
<h3 id="13-1-事件流"><a href="#13-1-事件流" class="headerlink" title="13.1 事件流"></a>13.1 事件流</h3><p>事件流描述的是从页面中接收事件的顺序。</p>
<h4 id="13-1-1-事件冒泡"><a href="#13-1-1-事件冒泡" class="headerlink" title="13.1.1 事件冒泡"></a>13.1.1 事件冒泡</h4><p>IE的事件流叫做事件冒泡，事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接受，然后逐级向上传播到较为不具体的节点（文档）</p>
<h4 id="13-1-2-事件捕获"><a href="#13-1-2-事件捕获" class="headerlink" title="13.1.2 事件捕获"></a>13.1.2 事件捕获</h4><p>不太具体的节点应该更早接收到事件，最具体的节点应该最后接收到事件</p>
<h4 id="13-1-3-DOM事件流"><a href="#13-1-3-DOM事件流" class="headerlink" title="13.1.3 DOM事件流"></a>13.1.3 DOM事件流</h4><p>DOM2级事件规定的事件流包括三个阶段：事件捕获阶段，处于目标阶段和事件冒泡阶段</p>
<ul>
<li>事件捕获阶段：从Document查找到最具体元素之前的阶段</li>
<li>处于目标阶段：最具体元素</li>
<li>事件冒泡阶段：从最具体元素冒泡到Document</li>
</ul>
<h3 id="13-2-事件处理程序"><a href="#13-2-事件处理程序" class="headerlink" title="13.2 事件处理程序"></a>13.2 事件处理程序</h3><p>响应某个事件的函数叫做事件处理程序（或事件监听器）</p>
<p>事件处理程序的名字以“on”开头，如：click事件的时间处理程序就是onclick，load事件的时间处理程序就是onload。为事件指定处理程序的方式有很多</p>
<h4 id="12-2-1-HTML事件处理程序"><a href="#12-2-1-HTML事件处理程序" class="headerlink" title="12.2.1 HTML事件处理程序"></a>12.2.1 HTML事件处理程序</h4><p>这个操作是通过指定onclick特性并将一些JavaScript代码作为它的值来定义的。因此不能使用未转义的HTML语法字符。</p>
<p>HTML时间处理程序可以包含要执行的具体动作，也可以调用在页面其他地方定义的脚本</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//具体动作</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"button"</span> <span class="attr">value</span> = <span class="string">"click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert('clicked')"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">//其他地方定义的脚本</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">showMessage</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">"Hello world!"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click Me"</span> <span class="attr">onclick</span>=<span class="string">"showMessage()"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="12-2-2-DOM0级事件处理程序"><a href="#12-2-2-DOM0级事件处理程序" class="headerlink" title="12.2.2 DOM0级事件处理程序"></a>12.2.2 DOM0级事件处理程序</h4><p>传统方式：将一个函数赋值给一个事件处理程序属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Clicked"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用DOM0级方法指定的时间处理程序被认为是元素的方法，因此这时的时间处理程序是在元素的作用域中运行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id);   <span class="comment">//"myBtn"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。</p>
<p>也可以删除事件处理程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick=<span class="literal">null</span></span><br></pre></td></tr></table></figure>
<h4 id="13-2-3-DOM2级事件处理程序"><a href="#13-2-3-DOM2级事件处理程序" class="headerlink" title="13.2.3 DOM2级事件处理程序"></a>13.2.3 DOM2级事件处理程序</h4><p>处理指定事件处理程序：<strong>addEventListener()</strong></p>
<p>删除指定事件处理程序：<strong>removeEventListener()</strong></p>
<p>都接受3个参数：要处理的事件名，作为事件处理程序的函数，一个布尔值（true捕获阶段调用，false冒泡阶段调用）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   <span class="comment">//可以添加多个事件处理程序</span></span><br><span class="line">    alert(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>通过addEventListener添加的事件处理程序只能通过removeEventListener()来移除，移除时传入的参数与添加时相同，但像上面代码中的匿名函数无法被删除。</p>
<p>大多数情况下都是将事件处理程序添加到事件流的冒泡阶段</p>
<h4 id="13-2-4-IE事件处理程序"><a href="#13-2-4-IE事件处理程序" class="headerlink" title="13.2.4 IE事件处理程序"></a>13.2.4 IE事件处理程序</h4><p>两个类似的方法：attachEvent(),detachEvent()</p>
<p>主要区别在于这两个方法的事件处理程序会在全局作用域中运行，this等于window</p>
<h3 id="13-3-事件对象"><a href="#13-3-事件对象" class="headerlink" title="13.3 事件对象"></a>13.3 事件对象</h3><p>在触发DOM上的某个对象时，会产生一个事件对象event，这个对象包含着所有与事件有关的信息，包括事件的元素，事件的类型以及其他与特性时间相关的信息。</p>
<h4 id="13-3-1-DOM中的事件对象"><a href="#13-3-1-DOM中的事件对象" class="headerlink" title="13.3.1 DOM中的事件对象"></a>13.3.1 DOM中的事件对象</h4><p>兼容DOM的浏览器会将一个event对象传入到事件处理程序中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    alert(event.type); <span class="comment">//"click"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    alert(event.type);  <span class="comment">//"click"</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<h5 id="target-currentTarget"><a href="#target-currentTarget" class="headerlink" title="target currentTarget"></a>target currentTarget</h5><p>在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标。如果直接将事件处理程序指定了目标元素，则三个值相同。如果把事件处理程序指定了目标元素的父节点中，则this,currentTarget指的是父节点，而target指的是目标元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&quot;myBtn&quot;);</span><br><span class="line">btn.onclick = function(event)&#123;</span><br><span class="line">    alert(this == event.currentTarget); //true</span><br><span class="line">    alert(this == event.target);        //true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.body.onclick = function(event)&#123;</span><br><span class="line">    alert(event.currentTarget == document.body);//true</span><br><span class="line">    alert(event.currentTarget == this); //true</span><br><span class="line">    alert(event.target == myBtn);  //true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h5><p>通过一个函数处理多个事件可以用type</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(event.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">            alert(<span class="string">"Clicked"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"mouseover"</span>:</span><br><span class="line">            event.target.style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"mouseout"</span>:</span><br><span class="line">            event.target.style.backgroundColor = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">break</span>;           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">btn.onclick = handler;</span><br><span class="line">btn.onmouseover = handler;</span><br><span class="line">btn.onmouseout = handler;</span><br></pre></td></tr></table></figure>
<h4 id="13-4-事件类型"><a href="#13-4-事件类型" class="headerlink" title="13.4 事件类型"></a>13.4 事件类型</h4><h4 id="13-5-内存性能-amp-amp-模拟事件"><a href="#13-5-内存性能-amp-amp-模拟事件" class="headerlink" title="13.5 内存性能&amp;&amp;模拟事件"></a>13.5 内存性能&amp;&amp;模拟事件</h4><h4 id="13-5-1-事件委托"><a href="#13-5-1-事件委托" class="headerlink" title="13.5.1  事件委托"></a>13.5.1  事件委托</h4><p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的事情。不需要给每个可单击的元素分别添加事件处理程序。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"palette"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:crimson"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:bisque"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:blueviolet"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:coral"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:chartreuse"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:darkolivegreen"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:cyan"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"background-color:#194738"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> uList = <span class="built_in">document</span>.querySelector(<span class="string">"ul"</span>);</span></span><br><span class="line"><span class="javascript">uList.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        thisLi = event.target;  <span class="comment">//获得用户实际点击的li</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(thisLi);</span></span><br><span class="line"><span class="javascript">         <span class="comment">//执行某些操作</span></span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="第十四章-表单脚本"><a href="#第十四章-表单脚本" class="headerlink" title="第十四章 表单脚本"></a>第十四章 表单脚本</h2><p>JavaScript最初的一个应用就是分担服务器处理表单的责任，打破处处依赖服务器的局面</p>
<h3 id="14-1-表单的基础知识"><a href="#14-1-表单的基础知识" class="headerlink" title="14.1 表单的基础知识"></a>14.1 表单的基础知识</h3><p>在HTML中，表单元素<form>，在javascript中，表单对应的则是HTMLFormElement类型。</form></p>
<p>一些除默认属性外的独特的属性和方法：</p>
<ul>
<li>acceptCharset:服务器能够处理的字符集，等价于HTML中的accept-charset特性</li>
<li>action 接受请求的URL，等价于HTML中的action特性</li>
<li>elements:表单中所有控件的集合</li>
<li>enctype:请求编码的类型</li>
<li>length:表单中控件的数量</li>
<li>method：要发送的HTTP请求类型（get,post)</li>
<li>name:表单的名称</li>
<li>reset():将所有表单域重置为默认值</li>
<li>submin():提交表单</li>
<li>target():用于发送请求和接受响应的窗口名称</li>
</ul>
<p>取得form元素引用的方式：</p>
<ul>
<li><p>将他看成和其他元素一样，添加id特性，然后使用getElementById()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"form1"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过document.forms可以取得页面中所有表单，在这个集合中可以通过数组索引或name值来取得特定的表单</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstForm = <span class="built_in">document</span>.forms[<span class="number">0</span>];   <span class="comment">//取得页面中第一个表单</span></span><br><span class="line"><span class="keyword">var</span> myForm = <span class="built_in">document</span>.forms[<span class="string">"form2"</span>];  <span class="comment">//取得页面中名称为"form2"的表单</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="14-1-1-提交表单"><a href="#14-1-1-提交表单" class="headerlink" title="14.1.1 提交表单"></a>14.1.1 提交表单</h4><h5 id="提交方法"><a href="#提交方法" class="headerlink" title="提交方法"></a>提交方法</h5><ol>
<li>使用<input>或<button>都可以定义提交按钮，只要将type特性设置为”submit”即可，而图像按钮则是通过将</button><input>的type特性设置为image来定义的 </li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"submit"</span> value=<span class="string">"Submit Form"</span></span><br><span class="line">&lt;button type=<span class="string">"submit"</span> value=<span class="string">"Submit Form"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;input type=<span class="string">"image"</span> src=<span class="string">"graphic.gif"</span>&gt;</span><br></pre></td></tr></table></figure>
<pre><code>只要表单中存在上面列出的任何一种按钮，那么在相应表单空间拥有焦点的情况下，按回车键就可以提交该表  单。

 以这种方式提交表单，浏览器会在将请求发送给服务期之前触发submit事件。这样就有机会验证表单数据，并以此决定是否允许表单提交。
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</span><br><span class="line">EventUtil.addHandler(form,<span class="string">"submit"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//阻止默认事件</span></span><br><span class="line">    EventUtil.preventDefault(event);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>也可以在js中以编程方式调用submit方法来提交</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</span><br><span class="line">form.submit();</span><br></pre></td></tr></table></figure>
<p>以这种方式调用submit的方式提交表单不会触发submit事件，因此要先验证表单数据。</p>
</li>
</ol>
<h5 id="解决出现的问题"><a href="#解决出现的问题" class="headerlink" title="解决出现的问题"></a>解决出现的问题</h5><p>可能出现的最大问题就是重复提交表单：如果服务器长时间没反应用户可能会反复单击提交按钮会造成错误</p>
<p>解决方法：</p>
<ul>
<li>在第一次提交表单后就禁用提交按钮</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(form,<span class="string">"submit"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> btn = target.element[<span class="string">"submit-btn"</span>];</span><br><span class="line">    btn.disabled = ture;   </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能使用onclick来实现这个功能，因为无法确定submit和禁用事件的执行顺序。因此最好通过监听submit事件来实现。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>利用onsubmit事件处理程序取消后续的表单提交操作</li>
</ul>
<h4 id="14-1-2-重置表单"><a href="#14-1-2-重置表单" class="headerlink" title="14.1.2 重置表单"></a>14.1.2 重置表单</h4><p>在用户单击重置按钮时，表单会被重置。使用type特性值为“reset”的input或button都可以创建重置按钮。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"reset"</span> value=<span class="string">"Reset Form"</span>&gt;</span><br><span class="line">&lt;button type=<span class="string">"reset"</span>&gt;Reset Form&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<p>重置表单时，所有表单字段都会恢复到页面刚加载完毕的初始值。</p>
<p>用户单击重置按钮重置表单时，会触发reset事件，利用这个机会，可以在必要时取消重置操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var form = document.getElementById(&quot;myForm&quot;);</span><br><span class="line">EventUtil.addHandler(form,&quot;reset&quot;,function(event)&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    </span><br><span class="line">    //阻止默认事件</span><br><span class="line">    EventUtil.preventDefault(event);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>与提交表单一样，重置也可以使用js,form.reset()即可</p>
<p>不一样的是，使用js调用也会像单击重置按钮一样触发reset事件。</p>
<h4 id="14-1-3-表单字段"><a href="#14-1-3-表单字段" class="headerlink" title="14.1.3 表单字段"></a>14.1.3 表单字段</h4><p>每个表单都有elements属性，该属性是表单中所有表单字段的集合。elements集合是一个有序列表，其中包含着表单中的所有字段，例如input textarea button filedset。表单字段在集合中的顺序，与他们出现在标记中的顺序相同，可以按照位置和name特性来访问他们。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> field1 = form.elements[<span class="number">0</span>]; <span class="comment">//取得表单中第一个字段</span></span><br><span class="line"><span class="keyword">var</span> field2 = form.elements[<span class="string">"textbox1"</span>] <span class="comment">//去的表单中名为”textbox1"的字段</span></span><br><span class="line"><span class="keyword">var</span> fieldCout = form.elements.length;  <span class="comment">//取得表单中包含的字段数量</span></span><br></pre></td></tr></table></figure>
<p>如果有多个表单控件都在使用一个name(如单选按钮)，那么就会返回一个以该name命名的一个NodeList。</p>
<h5 id="共用的表单字段属性"><a href="#共用的表单字段属性" class="headerlink" title="共用的表单字段属性"></a>共用的表单字段属性</h5><p>除了fieldset元素之外，所有表单字段都拥有相同的一组属性。表单字段共有的属性如下：</p>
<ul>
<li>disabled:布尔值，表示当前字段是否被禁用</li>
<li>form:指向当前字段所属表单的指针（只读）</li>
<li>name:当前字段的名称</li>
<li>readOnly:布尔值，表示当前字段是否只读</li>
<li>tabIndex:表示当前字段的切换序号</li>
<li>type:当前字段的类型（checkbox,radio)</li>
<li>value:当前字段将被提交给服务器的值，对于文件字段来说这个属性只读，包含文件在计算机中的路径。</li>
</ul>
<p>除了form属性，可以通过JS来修改其他任何属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</span><br><span class="line"><span class="keyword">var</span> field = form.elements[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">field.value=<span class="string">"Another value"</span>;</span><br><span class="line">alert(field.form === form)  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">field.disabled=ture;<span class="comment">//禁用当前字段</span></span><br></pre></td></tr></table></figure>
<h5 id="共有的表单字段方法"><a href="#共有的表单字段方法" class="headerlink" title="共有的表单字段方法"></a>共有的表单字段方法</h5><p>每个表单字段都有两个方法：focus()和blur()。</p>
<p><strong>focus：</strong>将浏览器的焦点设置到表单字段，即激活表单字段。</p>
<p>例如，可以在页面加载完毕后，将焦点转移到表单的第一个字段。（监听load事件，并在事件发生时在表单的第一个字段上调用focus方法）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(<span class="built_in">window</span>,<span class="string">"load"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="number">0</span>].focus();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果上述表单中第一个表单字段是input,并且type特性的值为hidden，则上述代码会导致错误。css的display和visibility属性也会导致错误</span></span><br></pre></td></tr></table></figure>
<p>HTML5新增autofocus属性。不用js也能自动移动焦点</p>
<p>input type=”text” autofocus</p>
<p><strong>blur:</strong> 从元素中移走焦点</p>
<p>调用blur()方法时，并不会把焦点转移到某个特定的元素上，仅仅是将焦点从调用这个方法的元素上面移走。</p>
<h5 id="共用的表单字段事件"><a href="#共用的表单字段事件" class="headerlink" title="共用的表单字段事件"></a>共用的表单字段事件</h5><p>除了支持鼠标，键盘，更改和HTML时间之外，所有的表单都支持下列三个事件：</p>
<ul>
<li>blur:当前字段失去焦点时触发</li>
<li>change:对于input和textarea元素，失去焦点且value值改变时触发；对于select元素，在选项值改变时触发</li>
<li>focus：当前字段获得焦点时触发</li>
</ul>
<h3 id="14-2-文本框脚本"><a href="#14-2-文本框脚本" class="headerlink" title="14.2 文本框脚本"></a>14.2 文本框脚本</h3><p>input 单行文本框</p>
<ul>
<li>表现文本框必须将input元素的type特性设置为text</li>
<li>size：指定文本框中能够显示的字符数</li>
<li>value:设置文本框的初始值</li>
<li>maxlength：指定文本框个可以接受的最大字符数</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">size</span>=<span class="string">"25"</span> <span class="attr">maxlength</span>=<span class="string">"50"</span> <span class="attr">value</span>=<span class="string">"initial value"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><textarea> 多行文本框</textarea></p>
<ul>
<li>rows：指定文本框的字符行数</li>
<li>cols：指定文本框的字符列数</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"25"</span> <span class="attr">cols</span>=<span class="string">"5"</span>&gt;</span>inital value<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>两种文本框都会将用户输入的内容保存在value属性中，可以通过这个属性来读取和设置文本框的值。</p>
<h4 id="14-2-1-选择文本"><a href="#14-2-1-选择文本" class="headerlink" title="14.2.1  选择文本"></a>14.2.1  选择文本</h4><p>上述两种文本框都支持select()方法，这个方法用于选择文本框中的所有文本。调用select()方法是，大多数浏览器会将焦点设置到文本框中。</p>
<p>在文本获得焦点是选择所有文本。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(textbox,<span class="string">"focus"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">    </span><br><span class="line">    target.select();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="选择事件"><a href="#选择事件" class="headerlink" title="选择事件"></a>选择事件</h5><p>在选择了文本框的文本后，就会触发select事件。用户选择了文本或者调用select方法都会触发select事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(textbox,<span class="string">"select"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">    </span><br><span class="line">    alert(target.value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="取得选择的文本"><a href="#取得选择的文本" class="headerlink" title="取得选择的文本"></a>取得选择的文本</h5><p>HTML通过扩展方案以便顺利取得选择的文本。</p>
<p>添加两个属性：selectionStart  selectionEnd</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSelectedText</span>(<span class="params">textbox</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> textbox.value.substring(textbox.selectionStart,textbox.selectionEnd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="选择部分文本"><a href="#选择部分文本" class="headerlink" title="选择部分文本"></a>选择部分文本</h5><p>方法：setSelectionRange()</p>
<p>参数：要选择的第一个字符的索引和最后一个字符之后的字符的索引</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">textbox.value = <span class="string">"Hello world"</span>;</span><br><span class="line"></span><br><span class="line">textbox.setSelectionRange(<span class="number">0</span>,textbox.value.length);<span class="comment">//Hello world</span></span><br><span class="line">textbox.setSelectionRange(<span class="number">0</span>,<span class="number">3</span>) <span class="comment">//Hel</span></span><br></pre></td></tr></table></figure>
<p>要见到选择的文本必须在调用该方法之前或者之后立即将焦点设置到文本框</p>
<h4 id="14-2-2-过滤输入"><a href="#14-2-2-过滤输入" class="headerlink" title="14.2.2 过滤输入"></a>14.2.2 过滤输入</h4><h5 id="屏蔽字符"><a href="#屏蔽字符" class="headerlink" title="屏蔽字符"></a>屏蔽字符</h5><p>屏蔽所有按键操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(textbox,<span class="string">"keypress"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    EventUtil.preventDefault(event);   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>屏蔽特定的字符：检测keypress事件对应的字符编码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只允许用户输入数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正则表达式判断不是数字(\d)的字符要屏蔽同时这个字符编码大于9(不屏蔽非字符键)</span></span><br><span class="line"><span class="comment">//复制粘贴等组合需要用到ctrl键，需要确保用户没有按下ctrl键 !event.ctrlKey</span></span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(text,<span class="string">"keypress"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">    <span class="keyword">var</span> charCode = EventUtil.getCharCode(event);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!<span class="regexp">/\d/</span>.text(<span class="built_in">String</span>.fromCharCode(charcode))&amp;&amp;charCode&gt;<span class="number">9</span>&amp;&amp;!event.ctrlKey)&#123;  <span class="comment">//fromCharCode()将字符编码转换为字符串</span></span><br><span class="line">        EventUtil.preventDefault(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="操作剪贴板-424"><a href="#操作剪贴板-424" class="headerlink" title="操作剪贴板 424"></a>操作剪贴板 424</h5><h4 id="14-2-3-自动切换焦点-P426"><a href="#14-2-3-自动切换焦点-P426" class="headerlink" title="14.2.3 自动切换焦点 P426"></a>14.2.3 自动切换焦点 P426</h4><h4 id="14-2-4-HTML5约束验证API-P427"><a href="#14-2-4-HTML5约束验证API-P427" class="headerlink" title="14.2.4 HTML5约束验证API P427"></a>14.2.4 HTML5约束验证API P427</h4><h3 id="14-3-选择框脚本"><a href="#14-3-选择框脚本" class="headerlink" title="14.3 选择框脚本"></a>14.3 选择框脚本</h3><p>选择框脚本是通过<select>和<option>元素创建的。</option></select></p>
<p>HTMLSelectElement类型特有的属性和方法：</p>
<ul>
<li>add(newOption,relOption):向控件插入新<option>元素，位置在相关项(relOption)之前</option></li>
<li>multiple:布尔值，是否允许多项选择；允许：type:select-multiple; 不允许：type:select-one;</li>
<li>options:控件中所有<option>元素的HTMLCollection</option></li>
<li>remove(index):移除给定位置的选项</li>
<li>selectedIndex:基于0的选中项的索引，如果没有则为1.多选空间只保存选中项中第一项的索引</li>
<li>size:选择框中可见的行数</li>
</ul>
<p>type属性由multiple决定</p>
<p>value属性由当前选择项决定（1.没有选中项为空字符串 2.有选中项等于其value值 3.选中项没有value值等于文本值 4.有多个选中项根据2.3取第一个选中项的值）</p>
<p>每个<option>元素都有一个HTMLOptionElement对象。属性如下：</option></p>
<ul>
<li>index:当前选项在options集合中的索引</li>
<li>label:当前选项的标签</li>
<li>selected:布尔值，表示当前选项是否被选中</li>
<li>text:选项的文本</li>
<li>value:选项的值</li>
</ul>
<h4 id="14-3-1-选择选项"><a href="#14-3-1-选择选项" class="headerlink" title="14.3.1 选择选项"></a>14.3.1 选择选项</h4><p>对于只允许选择一项的选择框，访问选择项的最简单方式，就是使用选择框的selectedIndex属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selectedOption = selectbox.options[selectbox.selectedIndex];</span><br></pre></td></tr></table></figure>
<p>对于多选的选择框，可以循环遍历选项集合，测试每个选项的selected属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSelectedOptions</span>(<span class="params">selectbox</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">var</span> option = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=selectbox.options.length;i&lt;len;i++)&#123;</span><br><span class="line">        option = selectbox.options[i];</span><br><span class="line">        <span class="keyword">if</span>(option.selected == <span class="literal">true</span>)&#123;</span><br><span class="line">            result.push(option[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-3-2-添加选项"><a href="#14-3-2-添加选项" class="headerlink" title="14.3.2 添加选项"></a>14.3.2 添加选项</h4><ol>
<li><p>使用DOM方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newOption = <span class="built_in">document</span>.createElement(<span class="string">"option"</span>);</span><br><span class="line">newOption.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Option text"</span>));</span><br><span class="line">newOption.setAttribute(<span class="string">"value"</span>,<span class="string">"Option value"</span>);</span><br><span class="line"></span><br><span class="line">selectbox.appendChild(newOption);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用option构造函数，兼容DOM的浏览器会返回一个<option>元素。接受两个参数，文本和值，值可选。</option></p>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newOption = <span class="keyword">new</span> Option(<span class="string">"Option text"</span>,<span class="string">"Option Value"</span>);</span><br><span class="line">selectbox.appendChild(newOption);  <span class="comment">//IE8之前有问题</span></span><br></pre></td></tr></table></figure>
</code></pre></li>
<li><p>使用选择框的add方法。接受两个参数：要添加的项和位于新项之后的选项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newOption = <span class="keyword">new</span> Option(<span class="string">"Option text"</span>,<span class="string">"Option Value"</span>);</span><br><span class="line">selectbox.add(newOption,<span class="literal">undefined</span>);  <span class="comment">//最佳方案  undefined会让新选项位于列表最后</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="14-3-3-移除选项"><a href="#14-3-3-移除选项" class="headerlink" title="14.3.3 移除选项"></a>14.3.3 移除选项</h4><p>三种方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">selectbox.removeChild(selectbox.options[<span class="number">0</span>]);</span><br><span class="line">selectbox.remove(<span class="number">0</span>);<span class="comment">//接受一个参数，被移除项的索引</span></span><br><span class="line">selecrbox.options[<span class="number">0</span>]=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<h4 id="14-3-4-移动和重排序"><a href="#14-3-4-移动和重排序" class="headerlink" title="14.3.4 移动和重排序"></a>14.3.4 移动和重排序</h4><p>移动:appendChild()传入一个已有的元素，会先从该元素的父节点中移除它，再把它添加到指定的位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selectbox1 = <span class="built_in">document</span>.getElementById(<span class="string">"selLocations1"</span>);</span><br><span class="line"><span class="keyword">var</span> selectbox2 = <span class="built_in">document</span>.getElementById(<span class="string">"selLocations2"</span>);</span><br><span class="line"></span><br><span class="line">selectbox2.appendChild(selectbox1.options[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>重排序：insertBefore()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optionToMove = selectbox.options[<span class="number">1</span>];</span><br><span class="line">selectbox.insertBefore(optionToMove,selectbox.options[optionToMove.index<span class="number">-1</span>]);<span class="comment">//前移一个</span></span><br><span class="line">selectbox.insertBefore(optionToMove,selectbox.options[optionToMove.index+<span class="number">2</span>]);<span class="comment">//后移一个</span></span><br></pre></td></tr></table></figure>
<h3 id="14-4-表单序列化-P436"><a href="#14-4-表单序列化-P436" class="headerlink" title="14.4 表单序列化 P436"></a>14.4 表单序列化 P436</h3><h3 id="14-5-富文本编辑"><a href="#14-5-富文本编辑" class="headerlink" title="14.5 富文本编辑"></a>14.5 富文本编辑</h3><p>本质：在页面中嵌入一个包含HTML页面的iframe。通过设置designMode属性，这个空白的HTML可以被编辑，编辑的对象则是该页面<body>元素的HTML代码。</body></p>
<p>design属性有两个可能的值：off on  当设置为on时，整个文档都会变得可以编辑。</p>
<p>design属性只有在页面加载完才能被设定，因此需要使用onload事件处理程序来设置。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"richedit"</span> <span class="attr">style</span>=<span class="string">"height:100px;width:100px;"</span> <span class="attr">src</span>=<span class="string">"blank.htm"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span> = <span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    EventUtil.addHandler(<span class="built_in">window</span>,<span class="string">"load"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        frames[<span class="string">"richedit"</span>].document.designMode = <span class="string">"on"</span>;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="14-5-1-使用contenteditable属性"><a href="#14-5-1-使用contenteditable属性" class="headerlink" title="14.5.1 使用contenteditable属性"></a>14.5.1 使用contenteditable属性</h4><p>把contenteditable属性应用给页面中的任何元素，然后用户就可以立即编辑该元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"editable"</span> id=<span class="string">"richedit"</span> contenteditable&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//js方法</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"richedit"</span>);</span><br><span class="line">div.contenteditable = <span class="literal">true</span>; <span class="comment">//true表示打开，false表示关闭，inherit表示从父元素继承</span></span><br></pre></td></tr></table></figure>
<h4 id="14-5-2-操作富文本"><a href="#14-5-2-操作富文本" class="headerlink" title="14.5.2 操作富文本"></a>14.5.2 操作富文本</h4><p>主要方式：document.execCommand()</p>
<p>参数：要执行的命令名称，浏览器是否为当前命令提供用户界面的一个布尔值，执行命令必须的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frames[<span class="string">"richedit"</span>].document.execCommand(<span class="string">"bold"</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">frames[<span class="string">"richedit"</span>].document.execCommand(<span class="string">"createlink"</span>,<span class="literal">false</span>,<span class="string">"http//www.wrox.com"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="14-5-3-富文本选区"><a href="#14-5-3-富文本选区" class="headerlink" title="14.5.3 富文本选区"></a>14.5.3 富文本选区</h4><p>使用frame的getSelection()方法，可以确定实际选择的文本。返回一个表示当前选择文本的selection对象。</p>
<p>提供了一些方法，支持对选取的操作 P442</p>
<h4 id="14-5-4-表单与富文本"><a href="#14-5-4-表单与富文本" class="headerlink" title="14.5.4 表单与富文本"></a>14.5.4 表单与富文本</h4><p>富文本中的HTML不会被自动提交给服务器，需要手动来提取并提交。</p>
<p>通常添加一个隐藏表单字段，在提交表单之前，从iframe中提取出HTML，并插入隐藏的字段中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(form,<span class="string">"submit"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">    </span><br><span class="line">    target.elements[<span class="string">"comments"</span>].value = frames[<span class="string">"richedit"</span>].document.body.innerHTML;<span class="comment">//frame元素</span></span><br><span class="line">    target.elements[<span class="string">"comments"</span>].value = <span class="built_in">document</span>.getElementById(<span class="string">"richedit"</span>).innerHTML <span class="comment">//contentditable元素</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

      
    
    </div>
    
      

      
  <hr class="copy-line">
  <div class="post-copyright">
    <div class="copy-author">
      <span>Author :</span>
      <span>Nian</span>
    </div>
    <div class="copy-url">
      <span>Url :</span>
      <a href="http://cuteanian.top/2018/10/29/JS笔记/">http://cuteanian.top/2018/10/29/JS笔记/</a>
    </div>
    <div class="copy-origin">
      <span>Origin :</span>
      <a href="http://cuteanian.top">http://cuteanian.top</a>
    </div>
    <div class="copy-license">
      
      著作权归作者所有，转载请联系作者获得授权。
    </div>
  </div>

    
  </article>
  
    
  <nav class="article-page">
    
      <a href="/2018/10/29/HTML/" id="art-left" class="art-left">
        <span class="next-title">
          <i class="iconfont icon-left"></i>HTML笔记
        </span>
      </a>
    
    
  </nav>

    
  <i id="com-switch" class="iconfont icon-more jumping-in long infinite" style="font-size:24px;display:block;text-align:center;transform:rotate(180deg);"></i>
  <div class="post-comments" id="post-comments" style="display: block;margin: auto 16px;">
    
    
    

    

  </div>



  
  
    
  
  <aside class="post-toc">
    <span class="title" id="toc-switch"><span>Index</span></span>
    <div class="toc-inner syuanpi back-1" style="display:none;">
      <li class="title-link"><a href="javascript:;" class="toTop">JS笔记</a></li>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第六章-面向对象的程序设计"><span class="toc-text">第六章 面向对象的程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-对象"><span class="toc-text">6.1 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-1-理解对象"><span class="toc-text">6.1.1 理解对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-2-创建对象"><span class="toc-text">6.1.2 创建对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-继承"><span class="toc-text">6.2 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-1-原型链继承"><span class="toc-text">6.2.1 原型链继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-2-借用构造函数"><span class="toc-text">6.2.2 借用构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-3组合继承"><span class="toc-text">6.2.3组合继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-4-原型式继承"><span class="toc-text">6.2.4 原型式继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-5-寄生式继承"><span class="toc-text">6.3.5 寄生式继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-6-寄生组合式继承-最理想"><span class="toc-text">6.3.6 寄生组合式继承(最理想)</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#第七章-函数"><span class="toc-text">第七章 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第八章-迭代器和生成器-ES6"><span class="toc-text">第八章  迭代器和生成器 ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-迭代器-amp-amp-生成器"><span class="toc-text">8.1 迭代器&amp;&amp;生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代器"><span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生成器"><span class="toc-text">生成器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-可迭代对象和for-of循环"><span class="toc-text">8.2 可迭代对象和for-of循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#访问默认迭代器"><span class="toc-text">访问默认迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建可迭代对象"><span class="toc-text">创建可迭代对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-内建迭代器"><span class="toc-text">8.3 内建迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#集合对象迭代器"><span class="toc-text">集合对象迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#entries-迭代器"><span class="toc-text">entries()迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#values-迭代器"><span class="toc-text">values()迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#keys迭代器"><span class="toc-text">keys迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#不同集合类型的默认迭代器"><span class="toc-text">不同集合类型的默认迭代器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串迭代器"><span class="toc-text">字符串迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NodeList迭代器"><span class="toc-text">NodeList迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#展开运算符与非数组可迭代对象"><span class="toc-text">展开运算符与非数组可迭代对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-高级迭代器功能"><span class="toc-text">8.4 高级迭代器功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#给迭代器传递参数"><span class="toc-text">给迭代器传递参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生成器返回语句"><span class="toc-text">生成器返回语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#委托生成器"><span class="toc-text">委托生成器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-异步任务执行"><span class="toc-text">8.5 异步任务执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-1-简单任务执行器"><span class="toc-text">8.5.1 简单任务执行器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-2-像任务执行器传递数据"><span class="toc-text">8.5.2 像任务执行器传递数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-3-异步任务执行器"><span class="toc-text">8.5.3 异步任务执行器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第十章-DOM"><span class="toc-text">第十章 DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-节点层次"><span class="toc-text">10.1 节点层次</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-1-Node类型"><span class="toc-text">10.1.1 Node类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#nodeName和nodeValue属性"><span class="toc-text">nodeName和nodeValue属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#节点关系"><span class="toc-text">节点关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#操作节点"><span class="toc-text">操作节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#一些其他方法"><span class="toc-text">一些其他方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-2-Document类型"><span class="toc-text">10.1.2 Document类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#document的子节点"><span class="toc-text">document的子节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#document的属性"><span class="toc-text">document的属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#查找元素"><span class="toc-text">查找元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#特殊集合"><span class="toc-text">特殊集合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#一致性检测"><span class="toc-text">一致性检测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#文档写入"><span class="toc-text">文档写入</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-3-Element类型"><span class="toc-text">10.1.3 Element类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HTML元素"><span class="toc-text">HTML元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#取得特性"><span class="toc-text">取得特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#设置特性-amp-amp-删除特性"><span class="toc-text">设置特性&amp;&amp;删除特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#arrtibute属性"><span class="toc-text">arrtibute属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#创建元素"><span class="toc-text">创建元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#元素的子节点"><span class="toc-text">元素的子节点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-4-Text类型"><span class="toc-text">10.1.4  Text类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#创建文本节点"><span class="toc-text">创建文本节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#规范化文本节点"><span class="toc-text">规范化文本节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分割文本节点"><span class="toc-text">分割文本节点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-5-Attr类型"><span class="toc-text">10.1.5  Attr类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-DOM操作技术"><span class="toc-text">10.2 DOM操作技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-1-动态脚本"><span class="toc-text">10.2.1 动态脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-2-动态样式"><span class="toc-text">10.2.2 动态样式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-3-操作表格"><span class="toc-text">10.2.3 操作表格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-4-使用nodeList"><span class="toc-text">10.2.4 使用nodeList</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第十一章-DOM扩展"><span class="toc-text">第十一章  DOM扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-选择符API"><span class="toc-text">11.1 选择符API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-1-querySelector"><span class="toc-text">11.1.1 querySelector()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-2-querySelectorAll"><span class="toc-text">11.1.2 querySelectorAll()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-3-matchedSelector"><span class="toc-text">11.1.3 matchedSelector()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-元素遍历（不包含空白文本节点）"><span class="toc-text">11.2 元素遍历（不包含空白文本节点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-HTML5"><span class="toc-text">11.3 HTML5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-1-与类相关的扩充"><span class="toc-text">11.3.1  与类相关的扩充</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#getElementsByClassName-方法"><span class="toc-text">getElementsByClassName() 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#classList-属性"><span class="toc-text">classList 属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-2-焦点管理"><span class="toc-text">11.3.2 焦点管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-3-HEMLDocument的变化"><span class="toc-text">11.3.3 HEMLDocument的变化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#readyState属性"><span class="toc-text">readyState属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-4-自定义数据属性"><span class="toc-text">11.3.4 自定义数据属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-一些专有扩展"><span class="toc-text">11.4 一些专有扩展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第十二章-DOM2和DOM3"><span class="toc-text">第十二章 DOM2和DOM3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-DOM变化"><span class="toc-text">12.1 DOM变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-DOM操作样式"><span class="toc-text">12.2 DOM操作样式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-1-访问元素的样式"><span class="toc-text">12.2.1 访问元素的样式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DOM样式属性和方法"><span class="toc-text">DOM样式属性和方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#计算的样式"><span class="toc-text">计算的样式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-2-操作样式表"><span class="toc-text">12.2.2 操作样式表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-3-元素大小"><span class="toc-text">12.2.3 元素大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-遍历"><span class="toc-text">12.3 遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-范围"><span class="toc-text">12.4 范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-事件流"><span class="toc-text">13.1 事件流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-1-事件冒泡"><span class="toc-text">13.1.1 事件冒泡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-2-事件捕获"><span class="toc-text">13.1.2 事件捕获</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-3-DOM事件流"><span class="toc-text">13.1.3 DOM事件流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-事件处理程序"><span class="toc-text">13.2 事件处理程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-1-HTML事件处理程序"><span class="toc-text">12.2.1 HTML事件处理程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-2-DOM0级事件处理程序"><span class="toc-text">12.2.2 DOM0级事件处理程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-3-DOM2级事件处理程序"><span class="toc-text">13.2.3 DOM2级事件处理程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-4-IE事件处理程序"><span class="toc-text">13.2.4 IE事件处理程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-事件对象"><span class="toc-text">13.3 事件对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-1-DOM中的事件对象"><span class="toc-text">13.3.1 DOM中的事件对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#target-currentTarget"><span class="toc-text">target currentTarget</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Type"><span class="toc-text">Type</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-4-事件类型"><span class="toc-text">13.4 事件类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-5-内存性能-amp-amp-模拟事件"><span class="toc-text">13.5 内存性能&amp;&amp;模拟事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-5-1-事件委托"><span class="toc-text">13.5.1  事件委托</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第十四章-表单脚本"><span class="toc-text">第十四章 表单脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-表单的基础知识"><span class="toc-text">14.1 表单的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-1-提交表单"><span class="toc-text">14.1.1 提交表单</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#提交方法"><span class="toc-text">提交方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#解决出现的问题"><span class="toc-text">解决出现的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-2-重置表单"><span class="toc-text">14.1.2 重置表单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-3-表单字段"><span class="toc-text">14.1.3 表单字段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#共用的表单字段属性"><span class="toc-text">共用的表单字段属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#共有的表单字段方法"><span class="toc-text">共有的表单字段方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#共用的表单字段事件"><span class="toc-text">共用的表单字段事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-文本框脚本"><span class="toc-text">14.2 文本框脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-1-选择文本"><span class="toc-text">14.2.1  选择文本</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#选择事件"><span class="toc-text">选择事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#取得选择的文本"><span class="toc-text">取得选择的文本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#选择部分文本"><span class="toc-text">选择部分文本</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-2-过滤输入"><span class="toc-text">14.2.2 过滤输入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#屏蔽字符"><span class="toc-text">屏蔽字符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#操作剪贴板-424"><span class="toc-text">操作剪贴板 424</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-3-自动切换焦点-P426"><span class="toc-text">14.2.3 自动切换焦点 P426</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-4-HTML5约束验证API-P427"><span class="toc-text">14.2.4 HTML5约束验证API P427</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-选择框脚本"><span class="toc-text">14.3 选择框脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-1-选择选项"><span class="toc-text">14.3.1 选择选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-2-添加选项"><span class="toc-text">14.3.2 添加选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-3-移除选项"><span class="toc-text">14.3.3 移除选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-4-移动和重排序"><span class="toc-text">14.3.4 移动和重排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-表单序列化-P436"><span class="toc-text">14.4 表单序列化 P436</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-富文本编辑"><span class="toc-text">14.5 富文本编辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5-1-使用contenteditable属性"><span class="toc-text">14.5.1 使用contenteditable属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5-2-操作富文本"><span class="toc-text">14.5.2 操作富文本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5-3-富文本选区"><span class="toc-text">14.5.3 富文本选区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5-4-表单与富文本"><span class="toc-text">14.5.4 表单与富文本</span></a></li></ol></li></ol></li>
    </div>
  </aside>



  


        </div>
      </main>

      <footer class="footer syuanpi fadeIn" id="footer">
  <hr>
  <div class="footer-wrapper">
    <div class="left">
      <div class="contact-icon">
    
    
    
    
    
    
    
    
        
        
        
        
        
            <a href="https://www.facebook.com/1" class="iconfont icon-facebook" title="facebook"></a>
        
        
        
    
        
        
        
            <a href="https://twitter.com/2" class="iconfont icon-twitter" title="twitter"></a>
        
        
        
        
        
    
        
        
        
        
        
        
        
            <a href="https://www.instagram.com/3" class="iconfont icon-ins" title="instagram"></a>
        
    
        
        
            <a href="https://weibo.com/4" class="iconfont icon-weibo" title="weibo"></a>
        
        
        
        
        
        
    
        
        
        
        
            <a href="https://www.zhihu.com/people/5" class="iconfont icon-zhihu" title="zhihu"></a>
        
        
        
        
    
        
            <a href="https://github.com/6" class="iconfont icon-github" title="github"></a>
        
        
        
        
        
        
        
    
        
        
        
        
        
        
            <a href="https://www.linkedin.com/in/7" class="iconfont icon-linkedin" title="linkedin"></a>
        
        
    
</div>
    </div>
    <div class="right">
      <div class="copyright">
    <div class="info">
        <span>&copy;</span>
        <span>2016 ~ 2018</span>
        <span>❤</span>
        <span>Nian</span>
    </div>
    <div class="theme">
        <span>
            Powered by
            <a href="http://hexo.io/" target="_blank">Hexo </a>
        </span>
        <span>
            Theme
            <a href="https://github.com/ColMugX/hexo-theme-Nlvi"> Nlvi </a>
        </span>
    </div>
    
</div>

    </div>
  </div>
</footer>
    </div>
  </div>
  <script src="/script/lib/jquery/jquery-3.2.1.min.js"></script>


  <script src="/script/lib/lightbox/js/lightbox.min.js"></script>








<script src="/script/src/nlvi.js"></script>

  <script src="/script/scheme/banderole.js"></script>

<script src="/script/bootstarp.js"></script>


<div class="backtop syuanpi melt toTop" id="backtop">
    <i class="iconfont icon-up"></i>
    <span style="text-align:center;font-family:Georgia;"><span style="font-family:Georgia;" id="scrollpercent">1</span>%</span>
</div>


  <div class="search" id="search">
    <div class="mask" id="mask"></div>
    <div class="search-wrapper syuanpi">
      <h2 id="search-header" class="syuanpi">搜索一下？</h2>
      <div class="input">
        <input type="text" id="local-search-input" results="0" name="">
      </div>
      <div id="local-search-result"></div>
    </div>
  </div>


</body>
</html>
